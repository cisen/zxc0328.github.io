<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zindex&#39;s blog</title>
  <subtitle>Frontend Rocks</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-01T08:40:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zindex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的2016</title>
    <link href="http://yoursite.com/2016/12/26/my2016/"/>
    <id>http://yoursite.com/2016/12/26/my2016/</id>
    <published>2016-12-26T06:58:46.000Z</published>
    <updated>2017-01-01T08:40:08.000Z</updated>
    
    <content type="html">&lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;回看我的进度，1月的时候我开始写简历生成器和学而的后台，那段时间我对于前端工程化很痴迷。把Dan Abramov的视频看了很多遍。主要用React写东西。&lt;/p&gt;
&lt;p&gt;寒假主要是写学而后台，写个人主页，看YDKJS和《JavaScript忍者秘籍》。寒假里面我发现了大批的电子书，对于JS的语言有了更深入的了解。也开始对公司和业务有一些自己的思考。我对于浏览器的探索也在那个时候开始了，主要是看了Mozilla工程师写的自制浏览器那一系列的博客。从进度上来看，那个时候真是热火朝天的学学学，新事物扑面而来，整个人还是很有干劲的。&lt;/p&gt;
&lt;p&gt;在找工作这问题上，当时我还是很没有底的。&lt;/p&gt;
&lt;p&gt;那段时间还在刷PAT，打算去参加春季的考试，但最后还是没有去，觉得没有准备好。&lt;/p&gt;
&lt;p&gt;接下来就是3月了，开学了，要上课要辅修，事情很多。学习的进度就没有那么快了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.14&lt;/p&gt;
&lt;p&gt;投简历+学而+团队+i华大 = 爆炸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来就是接触简单的算法，去网易面试。&lt;/p&gt;
&lt;p&gt;4月学校的出版社实习期间开始看jQuery源码。&lt;/p&gt;
&lt;h3 id=&quot;找工作&quot;&gt;&lt;a href=&quot;#找工作&quot; class=&quot;headerlink&quot; title=&quot;找工作&quot;&gt;&lt;/a&gt;找工作&lt;/h3&gt;&lt;p&gt;3月开始面试，第一个面的是阿里，二面挂了，一些很简单的问题没有准备，比如正则和简单的DOM API。后来面了饿了么，过了。在面试网易的时候，饿了么表示如果不能确定offer那就算了，于是我就在没有保底offer的情况下，去网易面试了。&lt;/p&gt;
&lt;p&gt;去网易的面试算是我第一次很正式的面试。总的来说，其实很平稳，但对我来说，记忆犹新。最让我感到印象深刻的还是面试期间那种忐忑的心情。好在最后一切顺利。现在看来，觉得还是挺幸福的。&lt;/p&gt;
&lt;h3 id=&quot;团队&quot;&gt;&lt;a href=&quot;#团队&quot; class=&quot;headerlink&quot; title=&quot;团队&quot;&gt;&lt;/a&gt;团队&lt;/h3&gt;&lt;p&gt;5月份的时候，团队出了大事，主要就是工作室要装修。领导为了面子工程，把我们的304改成了展示厅。对当时的我来说这真是和晴天霹雳一般。&lt;/p&gt;
&lt;p&gt;匆忙的租了房子，其实最后也没起多大作用。这次搬家对我们来说，意味着很多。和过去告别。真正的成长，担起团队的责任。&lt;/p&gt;
&lt;p&gt;这个时候，我们确立了核心成员的概念。一个团队，只需要核心成员，不是核心成员的都可以离开了。一个团队的人数并不是关键，团队的凝聚力和战斗力才是最关键的。&lt;/p&gt;
&lt;p&gt;其他的话，其实从我进度里看，关于团队的很多。大部分都是一些消极的抱怨，还有一些思考。暑假的时候，和大家远程交流，开会。很困难，到最后其实很有多的摩擦。但无论如何，事情都算是过去了。&lt;/p&gt;
&lt;p&gt;在12月的时候，我决定从团队的日常事务中抽身，专心做自己的事情。经过这段时间来看，团队是可以自己正常运转的。很开心啊，像是自己的孩子长大了一样。&lt;/p&gt;
&lt;h3 id=&quot;在网易的三个月&quot;&gt;&lt;a href=&quot;#在网易的三个月&quot; class=&quot;headerlink&quot; title=&quot;在网易的三个月&quot;&gt;&lt;/a&gt;在网易的三个月&lt;/h3&gt;&lt;p&gt;在网易的实习经历，在业务上是比较平淡的。做的有数这个平台的确是很复杂的，但我加入的时候这个平台已经比较成熟了，所以也没有太多挑战性的东西。没有见证初期的技术选型和架构的选择，所以在这方面没有学到太多想学到的。在大公司，技术选型这个是一个多方博弈的结果，要考虑公司本身的基础设施，并不是简单的引入开源项目就可以的。&lt;/p&gt;
&lt;p&gt;在网易主要是写了一个Regular-devtool，其他的话就写了一些简单的业务。生活的话，可以说还是非常幸福的。环境这些都挺不错的。现在想来还挺怀念呢。&lt;/p&gt;
&lt;h3 id=&quot;华师匣子&quot;&gt;&lt;a href=&quot;#华师匣子&quot; class=&quot;headerlink&quot; title=&quot;华师匣子&quot;&gt;&lt;/a&gt;华师匣子&lt;/h3&gt;&lt;p&gt;这个可以直接看之前写的&lt;a href=&quot;https://zxc0328.github.io/2016/12/19/ios-story/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;华师匣子开发记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一些新的探索&quot;&gt;&lt;a href=&quot;#一些新的探索&quot; class=&quot;headerlink&quot; title=&quot;一些新的探索&quot;&gt;&lt;/a&gt;一些新的探索&lt;/h3&gt;&lt;p&gt;函数式编程，以及相关的一些，还有编译原理。这两个Topic是我下半年的核心。这是我最近觉得最感兴趣的方向。对这些方向只进行了一些初步的探索。&lt;/p&gt;
&lt;p&gt;前端工具上，7月我写了Ninja，在团队的项目中用了半年。说实话这个是我最自豪的事情。&lt;/p&gt;
&lt;p&gt;12月开始写Build your own Vuejs，希望能顺利写完。&lt;/p&gt;
&lt;h3 id=&quot;未来打算&quot;&gt;&lt;a href=&quot;#未来打算&quot; class=&quot;headerlink&quot; title=&quot;未来打算&quot;&gt;&lt;/a&gt;未来打算&lt;/h3&gt;&lt;p&gt;我现在的一个理念，就是，你想学什么，那就自己写一个。光用是不行的。比如像了解前端MVVM框架，就自己实现一个。想学编译原理，可以自己实现一个简单的编译器。我认为这是很有趣的事情，也是很了不起的事情。&lt;/p&gt;
&lt;p&gt;未来打算在前端工具和框架这个方向上深入的研究。然后正式学习函数式编程。以及DSL相关的知识。保持好奇心。保持对生活的热爱！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从0到1：我和木犀的故事</title>
    <link href="http://yoursite.com/2016/12/19/muxi-story/"/>
    <id>http://yoursite.com/2016/12/19/muxi-story/</id>
    <published>2016-12-19T03:28:47.000Z</published>
    <updated>2016-12-23T07:12:39.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一个人的i华大技术中心&quot;&gt;&lt;a href=&quot;#一个人的i华大技术中心&quot; class=&quot;headerlink&quot; title=&quot;一个人的i华大技术中心&quot;&gt;&lt;/a&gt;一个人的i华大技术中心&lt;/h3&gt;&lt;p&gt;2014年开始，虽然我们还是习惯说自己是技术部的，但名义上已经是i华大技术中心了。底下分技术研发部和视觉设计部。&lt;/p&gt;
&lt;p&gt;说一个人，我指的是技术方面，设计那边还是很强大的。除了做主任的学姐和炳权学长，其他人并不会技术，然后之前的主任学姐三四月份就跑路了，炳权学长也很早就在名义上退出了。因此这个技术部就只有我一个人了。&lt;/p&gt;
&lt;p&gt;然后就是2014年四月份，技术中心春招。我依稀记得那个时候来了有大概三四十号人。然后我在306做培训，其实就是教他们切页面。&lt;/p&gt;
&lt;p&gt;那个时候也没想着要做一个技术团队，就想要把技术中心做好吧。当时我自己其实也是小白，也教不了他们什么。这三四十号人也并不是完全合适，因此最后待的比较久的，就只有龚红霞一个人。&lt;/p&gt;
&lt;p&gt;2014年的上半年还发生了一件事情，就是桂声10周年庆，请了很多高校的团队来交流，有武大和理工人的来了。当时我们的技术实力几乎为0，然而却在PPT上写了我们用Node，现在想起来还是觉得脸红。我听他们讲JSON，API这些，完全不懂。想来这应该就是我想打造一个技术团队的最初来源吧。&lt;/p&gt;
&lt;h3 id=&quot;木犀&quot;&gt;&lt;a href=&quot;#木犀&quot; class=&quot;headerlink&quot; title=&quot;木犀!&quot;&gt;&lt;/a&gt;木犀!&lt;/h3&gt;&lt;p&gt;木犀这个名字，想来应该就是14年下半年提出的。之所以叫木犀，是因为华师的桂花很出名，但直接叫桂花又太俗。我偶然得知木犀是桂花的学名，于是就选用了这个名字。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有个插曲，炳权曾经提议说我们可以叫handle，现在想起来还是觉得很搞笑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2014年的秋招，来了很多人，胡薇、韩伟、老王、王露晨、梁晓怡，这都是之后设计组的核心，想来之后那段时间也是设计组的黄金时代。小桂漫画，壁纸，表情，都是那段时间做的。&lt;/p&gt;
&lt;p&gt;还有一个人，那就是朱承浩。&lt;/p&gt;
&lt;p&gt;对我建设团队帮助最大的还是炳权，因为炳权那个时候已经在冰岩了（虽然我到15年上半年才知道），他会给我们很多建议，我也拓宽了很多视野。&lt;/p&gt;
&lt;p&gt;2014年下半年我们开始学Python，决定用Python做后端的语言。但那个时候还没有能力去完成一个网站的后台。那段时间我主要是用Drupal这个CMS来做学而的第一版。&lt;/p&gt;
&lt;p&gt;学而第一版其实反响还是很不错的，现在数据库里都还有那个时候的评论。这对我来说是一个鼓励，说明产品是有需求的。然后Drupal这个东西，开发难度很大，这坚定了我们自己学后台的决心。&lt;/p&gt;
&lt;p&gt;2015年的到来，是一切奇迹的开始。放弃Drupal和各种前端插件，真正的踏入Web开发的大门，就是从哪个时候开始的。所以说木犀的成长史，也是技术的成长史。&lt;/p&gt;
&lt;p&gt;首先我们在15年2月全面使用了Tower（这个时间点之前设计组好像就已经在用了）。大家看我和承浩的进度都是从15年2月开始的。至于Tower，对，没错，是炳权告诉我的，因为冰岩在用。&lt;/p&gt;
&lt;p&gt;之后就是承浩的时间了。他学了Flask，我们用Flask搭的第一个网站是什么，我已经忘了。我只记得那个时候，光部署网站，就要花好几天，因为书上讲的是AWS这种云服务的部署。手动的部署还是有一些门槛的。那个时候，因为了解的层次比较低，会觉得很多东西是玄学。&lt;/p&gt;
&lt;p&gt;3月我们去了联创交流，具体可以参见我的&lt;a href=&quot;http://zxc0328.github.io/2015/03/27/联创交流行/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;5月份和6月份其实还有一次转折。5月份的时候，理工的token团队办了十五周年庆，我们去参加了技术交流会。这次是我们第一次以木犀团队的名义出去交流。也是从2015年上半年开始，我们慢慢习惯以木犀团队的身份出现在所有人的眼中。这次交流会上，我们依然没有太多的干货，相比于其他团队，我们感受到了我们还太年轻。&lt;/p&gt;
&lt;p&gt;6月联创Hackday。我们主要是去感受了一下气氛。3月和6月两次去启明，对于我和承浩两个做技术的人来说，这个冲击不亚于工业文明对封建社会的冲击。首先是感受到了华科那边浓厚的技术气氛，其次是感到了一些压力，因为我们团队是如此的弱小，而华师的技术氛围又不想。当然是压力也是动力，不管如何，从2015上半年之后，我们团队在技术上便开始了不断的进步。&lt;/p&gt;
&lt;p&gt;联创Hackday&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150606_230735.jpg&quot; alt=&quot;hackday&quot;&gt;&lt;/p&gt;
&lt;p&gt;暑假承浩买了Mac，从此就一发不可收拾。那个暑假我在极验实习。其他人进行了我们第一次的夏令营（夏令营这个想法也是炳权提供的）。那个夏令营还是很愉快的，我们做出了第一版的内网，对于Flask的掌握已经好很多了。&lt;/p&gt;
&lt;p&gt;夏令营照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/0067HQaegw1ew2zdt5kfvj318g0xc7kh.jpg&quot; alt=&quot;xialy&quot;&gt;&lt;/p&gt;
&lt;p&gt;夏令营最后去落雁岛玩的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/64c45edcjw1fb0mmjzukkj21ci0ya4qp.jpg&quot; alt=&quot;lyd&quot;&gt;&lt;/p&gt;
&lt;p&gt;2015年9月，团队已经初具规模了。后面的事情，15级的同学应该都清楚了。&lt;/p&gt;
&lt;p&gt;接下来的事情就是2015年下半年开发的学而的第二版，完全用Flask写，有同步的路由和REST API组成，前端移动版是一个SPA，用了Webpack和React。这就是我们第一个工程化的产品。&lt;/p&gt;
&lt;p&gt;技术团队的成长，其实就是我的成长，承浩的成长，已经后面14级其他同学和15级同学的成长，每次有一个人成长为核心成员，团队就变的更加的强大。&lt;/p&gt;
&lt;h3 id=&quot;番外：304-306-502&quot;&gt;&lt;a href=&quot;#番外：304-306-502&quot; class=&quot;headerlink&quot; title=&quot;番外：304-306-502&quot;&gt;&lt;/a&gt;番外：304-306-502&lt;/h3&gt;&lt;p&gt;一开始，i华大技术中心的办公地点是在304。那时候我们还是非常自由的，304可以随意的改造。经历过那段时刻的同学应该知道，那段时间是很有归属感的一段时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/0067HQaegw1ew2zdsct9bj30hs0hsgpb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150402_202558.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;直到今年5月份，304和306装修。我仓皇中去合租了一间房子，在教工宿舍，作为我们的临时工作室：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/IMG20160622155941.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那段时光是难忘的，也是别扭的，痛苦的。那只狗，上门的邻居，狭小的空间，和我自己当时的各种压力混合在一起。&lt;/p&gt;
&lt;p&gt;现在我们主要在306活动，也在304。虽然归属感没有以前这么强了，但因为大家更熟悉了，核心成员也更多了，所以团队的气氛要更好一些。&lt;/p&gt;
&lt;p&gt;我还是希望我们能有一间独立的工作室。我们要时刻保持危机感，来应对未来的无限的可能。&lt;/p&gt;
&lt;h3 id=&quot;前端之路&quot;&gt;&lt;a href=&quot;#前端之路&quot; class=&quot;headerlink&quot; title=&quot;前端之路&quot;&gt;&lt;/a&gt;前端之路&lt;/h3&gt;&lt;p&gt;我个人的前端之路，其实也是木犀从0到1的一个很好的注脚。&lt;/p&gt;
&lt;p&gt;我其实在15年的上半年才开始正式学计算机。那个学期在武大开始辅修，然后在团队开始学Flask和Python。5月的时候，我的前端水平是只会写简单的Banner，相比之前Banner都要用插件的水平来说，算是好一些。那个时候是标准的过程式的编程。&lt;/p&gt;
&lt;p&gt;5月的时候看了一本单页应用开发的书，里面讲到了IIFE，闭包等等。我如获至宝，写个什么组件（其实我当时并没有组件的意识）就用IIFE，其实这算是最初的模块化，工程化意识吧。只不过我那个时候并不清楚模块化和工程化，也不知道正常的编程语言都是自带模块的。&lt;/p&gt;
&lt;p&gt;7月和8月我主要在极验实习，切了不少的页面，里面有一些用jQuery做的组件。这个时候我写展示型的页面以及比较熟练了，CSS也掌握的不错（毕竟在写桂声那些主要就是CSS）。但对于前端的那些Grunt什么的工具，其实我并不是很清楚为什么要用。&lt;/p&gt;
&lt;p&gt;所以对于模块的理解，对我来说是一道坎。真正理解模块和工程，还有闭包，大概是今年的事情了。&lt;/p&gt;
&lt;p&gt;9月回学校之后我看了React，后来就开始用Backbone写学而。那个时候我对MVC了解的还是比较多的，因为之前后端用的就是MVC。写React的时候比较初步的理解了组件化。之后对于Webpack之类的工具也用的很顺手了。&lt;/p&gt;
&lt;p&gt;这个学期对面向对象也略有了解。但对于View和Model的分层，以及组件的抽象，还没有到能手写的地步。那个时候我看Backbone源码，并没有太多感觉。而现在我回头看，就觉得抽象非常的清晰了。&lt;/p&gt;
&lt;p&gt;那个时候我对很多事情的理解都比较的浅薄。对于React Native很崇拜，觉得Web的目标就是取代原生应用。觉得Web就是要做单页应用。也没有很深入的理解前端工具为什么存在，以及组件化的发展史。&lt;/p&gt;
&lt;p&gt;现在来看，其实Web有Web的特点，需要动态化、快速上线、展示型的东西都可以用Web来做，这只是一个简单的技术选型的问题。&lt;/p&gt;
&lt;p&gt;总得来说，这是一个&lt;strong&gt;技术视野&lt;/strong&gt;的问题。如果你用过很多别的语言，那你就应该很容易的理解模块的存在。如果你开发过原生应用，那你就应该很好的理解为什么Web开发的UI应该是组件化的。&lt;/p&gt;
&lt;p&gt;今年开始，我把兴趣移到了函数式，编程语言，还有计算机基础上面。对于前端，我主要在开发工具解决我们自己的工作流中的问题，还有就是研究框架和工具的源码，进一步深入。&lt;/p&gt;
&lt;p&gt;现在回过头来看，我就能发现前端学习的一个最佳的路径，DOM可以不用花很多心思，但组件一定要自己去手动实现。模块可以直接用标准的模块。前端无非是普通的客户端软件开发，从这个视角去看的话，事情就清楚多了。&lt;/p&gt;
&lt;p&gt;计算机基础加上足量的工程经验，应该就可以成就一个好的工程师了。我的前端之路还算顺利，大家的学习道路，在我们这些先行者的踩坑之后，肯定会更加顺利。但有一点是肯定的，要把一样事情学好，需要你的热情，时间，和精力。&lt;/p&gt;
&lt;p&gt;还有一点，就是你的视野是随着你的经验而增长的，视野对你理解一些技术是非常有帮助的。平时我们在安排学习路线时也会特意的去安排背景阅读材料，或者是讲一些思想和Lab结合起来，努力让大家能够尽快的熟悉那些方法论层面的东西。同时，你自己的思考也是离不开的。我经常会思考，踱步。好的书常看常新，经典的思想，也是需要反复的思忖才能领悟的。&lt;/p&gt;
&lt;h3 id=&quot;我们在路上，前方不会太远&quot;&gt;&lt;a href=&quot;#我们在路上，前方不会太远&quot; class=&quot;headerlink&quot; title=&quot;我们在路上，前方不会太远&quot;&gt;&lt;/a&gt;我们在路上，前方不会太远&lt;/h3&gt;&lt;p&gt;2016年，团队最大的新闻当然就是华师匣子的上线。这个是我们的第一款移动应用，也是将来一切产品的推广基础。&lt;/p&gt;
&lt;p&gt;在我看来，团队最大的成长，一个是技术团队在工程化上慢慢摸索，有了自己的方向。我们的方向就是&lt;strong&gt;通过造轮子来深入原理，积极的实践最新的技术，写完善的文档，在社区中争取拥有一定的影响力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在团队的管理上，确立了早读制度，试行了导师制度，管理工作组共同管理团队，成功的进行了秋游，招新算是顺利，团队管理层平滑更换。这些都是一个团队平稳运行的基石。如果说这个大框架搭好了，我们就可以把精力投入到具体的产品和新人培养中去了。&lt;/p&gt;
&lt;p&gt;在接下里的日子里，我们要把产品的汇报制度完善，项目组的气氛要更好，全员大会要常态化，组内技术积累要抓紧，新人双轨培养的计算机基础方向需要花很大的力气建设，UED部门要重新上路。&lt;/p&gt;
&lt;p&gt;对于团队的期望，我不想说太多，我只能说，作为一个木犀人，你就算毕业了，也依然要参与到团队的建设中去，只是不在第一线了而已。只有这样才能慢慢的把事情做好。我们追求的是理想中的团队，可能我们永远都无法到达那个理想中的境界，但一直在成长，一直在进步的话，大家开开心心的，就挺好。&lt;/p&gt;
&lt;p&gt;我们在路上，前方不会太远。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>华师匣子iOS版开发记</title>
    <link href="http://yoursite.com/2016/12/19/ios-story/"/>
    <id>http://yoursite.com/2016/12/19/ios-story/</id>
    <published>2016-12-19T03:28:35.000Z</published>
    <updated>2016-12-21T12:44:19.000Z</updated>
    
    <content type="html">&lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是匣子iOS的Github提交图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-12-21%20at%208.39.43%20PM.png&quot; alt=&quot;iOS Github&quot;&gt;&lt;/p&gt;
&lt;p&gt;上个学期我接下iOS版开发的任务时，其实我心里是没底的。没学过iOS是一方面，关键是我也没有任何客户端开发的经验。当时我对客户端开发的了解几乎为0。之前有接触过一点安卓。但iOS这边玄学的StoryBoard和新语言Swift都让我比较没底。&lt;/p&gt;
&lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h3&gt;&lt;p&gt;我首先看了斯坦福的&lt;a href=&quot;http://web.stanford.edu/class/cs193p/cgi-bin/drupal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS开发课程&lt;/a&gt;。这个课程是一个非常不错的课程。里面实现一个计算器，代码的结构非常的合理，也充分发挥了Swift的特性。当时我的感觉就是，写APP或者其他业务并不是会调API就好，如果想要写漂亮的代码，那还是需要扎实的计算机基础。&lt;/p&gt;
&lt;p&gt;我看着课程，但我并没有跟着写，因为时间不多了。我在了解了基本的MVC架构、StoryBoard中拖控件、拖Outlet和Action、Auto Layout之后，就开始写匣子的几个界面。&lt;/p&gt;
&lt;p&gt;当时写了界面之后，就有所感触了。首先Auto Layout的确是一个非常好的布局方式，让我不再怀念CSS。然后，原生APP中首先所有的组件都是有与之对应的对象实例的，这是顺理成章的事情。但在Web这边，组件需要自己抽象，而且在Web Component没有普及之前，没有原生级别的支持。写iOS的过程中我越发明白，DOM其实只是Web界面UI的实现细节。我们要用某种方式去封装DOM，在UI抽象层编写代码。iOS就完全符合这种方式。想来客户端软件理应是这样的。只不过Web技术从一开始并不是为客户端软件打造的，因此这几年前端走的路，基本就是补上之前落下的课。&lt;/p&gt;
&lt;p&gt;当然Web前端数据驱动，双向绑定这些，在我看来已经是最前沿的东西了。iOS这边肯定也有。但因为我对前端更了解一些，所以觉得前端要更优雅一些。&lt;/p&gt;
&lt;p&gt;最开始做图书馆，于是就遇到了输入框键盘如何收起的问题。点击return，点击屏幕的其他地方都会收起键盘。这里要提到一点，就是这次0基础做iOS，是我第一次在全英文的环境下从头开始学一门技术。这次我全程一行中文都没有看。回头想想，很难想象如何在中文社区解决这些问题。&lt;/p&gt;
&lt;h3 id=&quot;深入&quot;&gt;&lt;a href=&quot;#深入&quot; class=&quot;headerlink&quot; title=&quot;深入&quot;&gt;&lt;/a&gt;深入&lt;/h3&gt;&lt;p&gt;接下来就是各个技术点的学习了。数据持久化要用Core Data，其实就是一个本地的SQLite数据库。这个我基本是当Key Value存储来用了。对数据库还是不是很了解。然后有触摸事件的处理等等。网络请求用Alamofire和SwiftyJSON。学用iOS的Cocoapad装依赖。&lt;/p&gt;
&lt;p&gt;学习的过程中，说起来只有一个比较理论的知识，就是delegate、protocol、extension这些。&lt;/p&gt;
&lt;p&gt;之前在看斯坦福课程的时候还不是很了解。后来用UITableView以及需要不同VC直接通信的时候，就慢慢了解了delegate。我对delegate的了解就是一种委托的模式。任意一个实现了对应接口的对象都可以作为委托的对象。后来在安卓那边了解了一下，大致有同样的实现。&lt;/p&gt;
&lt;p&gt;UITableView实在是一种很经典的接口设计。除了那几个delegate方法之外，UITableView会对Table Cell进行回收的做法，也让我明白了之前面试时问我的长列表优化问题的答案。在Web端我们也可以控制列表只保留可视区域的DOM元素，来做优化。这样不管列表有多少元素，都可以顺利的渲染。&lt;/p&gt;
&lt;h3 id=&quot;课程表&quot;&gt;&lt;a href=&quot;#课程表&quot; class=&quot;headerlink&quot; title=&quot;课程表&quot;&gt;&lt;/a&gt;课程表&lt;/h3&gt;&lt;p&gt;课程表一度是我迟迟不愿意动手的一个模块。其实匣子里大部分模块的逻辑都是简单的查询和拉取数据。课程表也不例外，但课程表的View相对来说比较复杂。我咨询了安卓的同学之后才知道要自己画View，自己handle触摸事件。于是就写了一个双向的滑动，在触摸事件中修改View的偏移。&lt;/p&gt;
&lt;p&gt;画课表的格子也花了我一段时间，最后算是解决了。后期还要再完善。课程表的实现让我得以一窥iOS开发的常态———自定义View。实际上大部分的控件应该还是需要自己来写的，毕竟大家的APP看上去都很Unique。&lt;/p&gt;
&lt;p&gt;iOS的View可以自定义drawRect方法。这应该就是暴露了底层的2D绘图API，类似于Web中的Canvas。&lt;/p&gt;
&lt;h3 id=&quot;收尾&quot;&gt;&lt;a href=&quot;#收尾&quot; class=&quot;headerlink&quot; title=&quot;收尾&quot;&gt;&lt;/a&gt;收尾&lt;/h3&gt;&lt;p&gt;其他大大小小的问题还有很多，比如我一度纠结于如何取消Navigation bar上面返回按钮的文字，结果发现在Story Board里面的Back Button打一个空格就行了。踩了很多坑，有一个很大的坑就是我一度用中文做了包名，导致后来数据迁移一直报错。&lt;/p&gt;
&lt;p&gt;Banner的话，最后是用原生的UIPageView实现的。之前一度以为要自己实现一个。想来自己的水平还是不够的。&lt;/p&gt;
&lt;p&gt;后期陆续完成了数据迁移，远程推送，本地推送，闪屏处理，还有和后端元信息API的整合。&lt;/p&gt;
&lt;p&gt;上线的时候，担心我们的服务器不支持IPv6，担心不会过审。不过最后很顺利的过审核了。苹果的工作效率没有想象中的那么低。&lt;/p&gt;
&lt;p&gt;苹果要求HTTPS和IPv6，Safari10支持全部ES6属性。这意味着苹果一直走在时代的最前沿。在这一点上我要给苹果点赞。&lt;/p&gt;
&lt;p&gt;这次iOS的开发算是让我获得了iOS的初级开发经验，点亮了客户端开发的技能点。为后续我的Hybrid研究开了一个好头。&lt;/p&gt;
&lt;h3 id=&quot;关于Swift&quot;&gt;&lt;a href=&quot;#关于Swift&quot; class=&quot;headerlink&quot; title=&quot;关于Swift&quot;&gt;&lt;/a&gt;关于Swift&lt;/h3&gt;&lt;p&gt;Swift给我的印象还是很不错的。静态类型，经典的面向对象，外加和JS类似的函数式特性，我用起来觉得很顺手。OC看起来太恐怖了，如果不是有Swift，想来我也不会鼓起勇气去写iOS。Swift未来还会进军服务端，虽然是Apple自家的东西，但开源了，想来发展应该会是不错的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Build your own Vuejs Chapter1 Vue Overview</title>
    <link href="http://yoursite.com/2016/12/12/build-your-own-vuejs-1/"/>
    <id>http://yoursite.com/2016/12/12/build-your-own-vuejs-1/</id>
    <published>2016-12-12T09:11:50.000Z</published>
    <updated>2016-12-12T09:17:47.000Z</updated>
    
    <content type="html">&lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Chapter1-Vuejs-Overview&quot;&gt;&lt;a href=&quot;#Chapter1-Vuejs-Overview&quot; class=&quot;headerlink&quot; title=&quot;Chapter1: Vuejs Overview&quot;&gt;&lt;/a&gt;Chapter1: Vuejs Overview&lt;/h2&gt;&lt;p&gt;Vuejs is a simple yet powerful MVVM library. It helps us to build a modern user interface for the web.&lt;/p&gt;
&lt;p&gt;By the time of writing, Vuejs has 36,312 stars on Github. And 230,250 monthly downloads on npm. Vuejs 2.0 brings in a lightweight virtual DOM implementation for render layer. This unlock more possibilities like server-side rendering and native component rendering.&lt;/p&gt;
&lt;p&gt;Vuejs claims to be a progressive JavaScript framework. Though the core library of Vuejs is quite small. Vuejs has many accompanying tools &amp;amp; supporting libraries. So you can build large-scale application using the Vuejs ecosystem.&lt;/p&gt;
&lt;h3 id=&quot;Components-of-Vuejs-internals&quot;&gt;&lt;a href=&quot;#Components-of-Vuejs-internals&quot; class=&quot;headerlink&quot; title=&quot;Components of Vuejs internals&quot;&gt;&lt;/a&gt;Components of Vuejs internals&lt;/h3&gt;&lt;p&gt;Let’s get acquaintance with the core components of Vuejs internals. Vue internals falls into serval parts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Vue%20source%20overview.png&quot; alt=&quot;Vue internal&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Instance-lifecycle&quot;&gt;&lt;a href=&quot;#Instance-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;Instance lifecycle&quot;&gt;&lt;/a&gt;Instance lifecycle&lt;/h4&gt;&lt;p&gt;A new Vue instance will go through several phases. Such as observing data, initializing events, compiling the template, and render. And you can register  lifecycle hooks that will be called in the specific phase.&lt;/p&gt;
&lt;h4 id=&quot;Reactivity-system&quot;&gt;&lt;a href=&quot;#Reactivity-system&quot; class=&quot;headerlink&quot; title=&quot;Reactivity system&quot;&gt;&lt;/a&gt;Reactivity system&lt;/h4&gt;&lt;p&gt;The so called &lt;em&gt;reactivity system&lt;/em&gt; is where vue’s data-view binding magic comes from. When you set vue instance’s data, the view updated accordingly, and vice versa. &lt;/p&gt;
&lt;p&gt;Vue use &lt;code&gt;Object.defineProperty&lt;/code&gt; to make data object’s property reactive. Along with the famous &lt;em&gt;Observer Pattern&lt;/em&gt; to link data change and view render together.&lt;/p&gt;
&lt;h4 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h4&gt;&lt;p&gt;Virtual DOM is the tree representation of the actual DOM tree that lives in the memory as JavaScript Objects. &lt;/p&gt;
&lt;p&gt;When data changes, vue will render a brand new virtual DOM tree, and keep the old one. The virtual DOM module diff two trees and patch the change into the actual DOM tree.&lt;/p&gt;
&lt;p&gt;Vue use &lt;a href=&quot;https://github.com/snabbdom/snabbdom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;snabbdom&lt;/a&gt; as the base of its virtual DOM implementation. And modify a bit to make it work with Vue’s other component.&lt;/p&gt;
&lt;h4 id=&quot;Compiler&quot;&gt;&lt;a href=&quot;#Compiler&quot; class=&quot;headerlink&quot; title=&quot;Compiler&quot;&gt;&lt;/a&gt;Compiler&lt;/h4&gt;&lt;p&gt;The job of the compiler is to compile template into render functions(ASTs). It parses HTML along with Vue directives (Vue directives are just plain HTML attribute) and other entities into a tree. It also detects the maximum static sub trees (sub trees with no dynamic bindings) and hoists them out of the render. The HTML parser Vue uses is originally written by &lt;a href=&quot;http://ejohn.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John Resig&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We will not cover the implementation detail of the Compiler in this book. Since we can use build tools to compile vue template into render functions in build time, Compiler is not a part of vue runtime. And we can even write render functions directly, so Compiler is not an essential part to understand vue internals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Set-up-development-environment&quot;&gt;&lt;a href=&quot;#Set-up-development-environment&quot; class=&quot;headerlink&quot; title=&quot;Set up development environment&quot;&gt;&lt;/a&gt;Set up development environment&lt;/h3&gt;&lt;p&gt;Before we can start building our own Vue.js, we need to set up a few things. Including module bundler and testing tools, since we will use a test-driven workflow.&lt;/p&gt;
&lt;p&gt;Since this is a JavaScript project, and we’gonna use some fancy tools, the first thing to do is run &lt;code&gt;npm init&lt;/code&gt; and set up some information about this project. &lt;/p&gt;
&lt;h4 id=&quot;Set-up-Rollup-for-module-bundling&quot;&gt;&lt;a href=&quot;#Set-up-Rollup-for-module-bundling&quot; class=&quot;headerlink&quot; title=&quot;Set up Rollup for module bundling&quot;&gt;&lt;/a&gt;Set up Rollup for module bundling&lt;/h4&gt;&lt;p&gt;We will use Rollup for module bundling. &lt;a href=&quot;http://rollupjs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rollup&lt;/a&gt; is a JavaScript module bundler. It allows you to write your application or library as a set of modules – using modern ES2015 import/export syntax. And Vuejs use Rollup for module bundling too.&lt;/p&gt;
&lt;p&gt;We gotta write a configuration for Rollup to make it work. Under root directory, touch &lt;code&gt;rollup.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  entry: &amp;#39;src/instance/index.js&amp;#39;,
  format: &amp;#39;umd&amp;#39;,
  moduleName: &amp;#39;Vue&amp;#39;,
  dest: &amp;#39;dist/vue.js&amp;#39; 
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And don’t forget to run &lt;code&gt;npm install rollup rollup-watch --save-dev&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;Set-up-Karma-and-Jasmine-for-testing&quot;&gt;&lt;a href=&quot;#Set-up-Karma-and-Jasmine-for-testing&quot; class=&quot;headerlink&quot; title=&quot;Set up Karma and Jasmine for testing&quot;&gt;&lt;/a&gt;Set up Karma and Jasmine for testing&lt;/h4&gt;&lt;p&gt;Testing will require quite a few packages, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install karma jasmine karma-jasmine karma-chrome-launcher
 karma-rollup-plugin --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Under root directory, touch &lt;code&gt;karma.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(config) {
  config.set({
    frameworks: [&amp;#39;jasmine&amp;#39;],
    files: [
      &amp;#39;./test/**/*.js&amp;#39;
    ],
    browsers: [&amp;#39;Chrome&amp;#39;],
    preprocessors: {
     &amp;#39;./test/**/*.js&amp;#39;: [&amp;#39;rollup&amp;#39;]
    },
    rollupPreprocessor: {
      format: &amp;#39;iife&amp;#39;,
      sourceMap: &amp;#39;inline&amp;#39;
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Directory-structure&quot;&gt;&lt;a href=&quot;#Directory-structure&quot; class=&quot;headerlink&quot; title=&quot;Directory structure&quot;&gt;&lt;/a&gt;Directory structure&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- package.json
- rollup.conf.js
- node_modules
- dist
- test
- src
    - observer
    - instance
    - util
    - vdom
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Bootstrapping&quot;&gt;&lt;a href=&quot;#Bootstrapping&quot; class=&quot;headerlink&quot; title=&quot;Bootstrapping&quot;&gt;&lt;/a&gt;Bootstrapping&lt;/h3&gt;&lt;p&gt;We’ll add some npm script for convenience. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;package.json&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
   &amp;quot;build&amp;quot;: &amp;quot;rollup -c&amp;quot;,
   &amp;quot;watch&amp;quot;: &amp;quot;rollup -c -w&amp;quot;,
   &amp;quot;test&amp;quot;: &amp;quot;karma start&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To bootstrap our own Vuejs, let’s write our first test case.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;test/options/options.spec.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &amp;quot;../src/instance/index&amp;quot;;

describe(&amp;#39;Proxy test&amp;#39;, function() {
  it(&amp;#39;should proxy vm._data.a = vm.a&amp;#39;, function() {
      var vm = new Vue({
          data:{
              a:2
          }
      })
    expect(vm.a).toEqual(2);
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This test case tests whether props on vm’s data like &lt;code&gt;vm._data.a&lt;/code&gt; are proxied to vm itself, like &lt;code&gt;vm.a&lt;/code&gt;. This is one of Vue’s little tricks.&lt;/p&gt;
&lt;p&gt;So we can write our first line of real code now, in &lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/index.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initMixin } from &amp;#39;./init&amp;#39;

function Vue (options) {
  this._init(options)
}

initMixin(Vue)

export default Vue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is nothing exciting, just Vue constructor calling &lt;code&gt;this._init&lt;/code&gt;. So let’s find out how the &lt;code&gt;initMixin&lt;/code&gt; fucntion work:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/init.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initState } from &amp;#39;./state&amp;#39;

export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
      var vm = this
      vm.$options = options
      initState(vm)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The instance method of Vue Class are injected using a mixin pattern. We’ll find this mixin pattern quite common when writing Vuejs’s instance method later. Mixin is just a function that takes a constructor, add some methods to its prototype, and return the constructor.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;initMixin&lt;/code&gt; add &lt;code&gt;_init&lt;/code&gt; method to &lt;code&gt;Vue.prototype&lt;/code&gt;. And this method calls &lt;code&gt;initState&lt;/code&gt; from &lt;code&gt;state.js&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/state.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
export function initState(vm) {
  initData(vm)
}

function initData(vm) {
  var data = vm.$options.data
  vm._data = data
  // proxy data on instance
  var keys = Object.keys(data)

  var i = keys.length
  while (i--) {
    proxy(vm, keys[i])
  }
}

function proxy(vm, key) {
    Object.defineProperty(vm, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter() {
        return vm._data[key]
      },
      set: function proxySetter(val) {
        vm._data[key] = val
      }
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we got to the place where proxy takes place. &lt;code&gt;initState&lt;/code&gt; calls &lt;code&gt;initData&lt;/code&gt;, and &lt;code&gt;initData&lt;/code&gt; iterates all keys of &lt;code&gt;vm._data&lt;/code&gt;, calls &lt;code&gt;proxy&lt;/code&gt; on each value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt; define a property on &lt;code&gt;vm&lt;/code&gt; using the same key, and this property has both getter and setter, which actually get/set data from &lt;code&gt;vm._data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So that’s how &lt;code&gt;vm.a&lt;/code&gt; is proxied to &lt;code&gt;vm._data.a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;npm run build&lt;/code&gt; and &lt;code&gt;npm run test&lt;/code&gt;. You should see something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn4.snapgram.co/images/2016/12/11/ScreenShot2016-12-12at2.02.17AM.png&quot; alt=&quot;success&quot;&gt;&lt;/p&gt;
&lt;p&gt;Bravo! You successfully bootstrapped your own Vuejs! Keep working!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊Chrome Devtools的Timeline</title>
    <link href="http://yoursite.com/2016/11/29/timeline/"/>
    <id>http://yoursite.com/2016/11/29/timeline/</id>
    <published>2016-11-29T12:15:49.000Z</published>
    <updated>2016-11-30T08:46:41.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Timeline的使用场景&quot;&gt;&lt;a href=&quot;#Timeline的使用场景&quot; class=&quot;headerlink&quot; title=&quot;Timeline的使用场景&quot;&gt;&lt;/a&gt;Timeline的使用场景&lt;/h3&gt;&lt;p&gt;Timeline的使用场景一个是在页面发生明显的卡顿时，比如CSS动画或者页面滚动时，用来分析卡顿的原因。还有一个场景便是进行页面渲染性能的评估，看页面渲染性能是否有优化的空间，或者通过截图观察页面渲染的过程，优化&lt;a href=&quot;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Speed Index&lt;/a&gt;来提升用户体验。&lt;/p&gt;
&lt;h3 id=&quot;关于渲染&quot;&gt;&lt;a href=&quot;#关于渲染&quot; class=&quot;headerlink&quot; title=&quot;关于渲染&quot;&gt;&lt;/a&gt;关于渲染&lt;/h3&gt;&lt;p&gt;我们知道，如果以每秒16-24帧的速度连续播放图片，那人就会产生动画的幻觉。在UI动画中，因为目前主流显示设备的刷新率达到了60Hz，我们追求的的帧率是60fps。那理想情况下，每一帧的时间应该是&lt;code&gt;1/60=16.67ms&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;又因为JavaScript是单线程事件驱动的模型。所以浏览器在一帧之内要完成JavaScript脚本的运行，然后计算，合成这帧画面，并渲染。&lt;/p&gt;
&lt;h3 id=&quot;Long-Frame&quot;&gt;&lt;a href=&quot;#Long-Frame&quot; class=&quot;headerlink&quot; title=&quot;Long Frame&quot;&gt;&lt;/a&gt;Long Frame&lt;/h3&gt;&lt;p&gt;所谓的Long Frame，也就是我们在Timeline的FPS中被标注为红色（如下图）的那些帧，便是用时超过正常标准的那些帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/longframe.png&quot; alt=&quot;longframe&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;long frame&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Long Frame往往意味着卡顿，因为帧率低于60fps，甚至30fps。我们会通过查看这帧中的JS运行情况，浏览器渲染情况，以及浏览器用户触发事件的情况来分析卡顿的原因。&lt;/p&gt;
&lt;h3 id=&quot;Timeline中有价值的数据&quot;&gt;&lt;a href=&quot;#Timeline中有价值的数据&quot; class=&quot;headerlink&quot; title=&quot;Timeline中有价值的数据&quot;&gt;&lt;/a&gt;Timeline中有价值的数据&lt;/h3&gt;&lt;h4 id=&quot;JS调用栈&quot;&gt;&lt;a href=&quot;#JS调用栈&quot; class=&quot;headerlink&quot; title=&quot;JS调用栈&quot;&gt;&lt;/a&gt;JS调用栈&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/jsstack.png&quot; alt=&quot;jscallstack&quot;&gt;&lt;br&gt;&lt;em&gt;JS Call Stack&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果是JS运行时间过长，比如超过10ms，那我们就有必要检查这个JS的调用栈，可以通过查看Details一栏中的Bottom-up选项卡来看到自顶向下的调用信息。分析那个函数调用占用了过多的时间，并加以解决。&lt;/p&gt;
&lt;h4 id=&quot;浏览器渲染信息&quot;&gt;&lt;a href=&quot;#浏览器渲染信息&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染信息&quot;&gt;&lt;/a&gt;浏览器渲染信息&lt;/h4&gt;&lt;p&gt;浏览器渲染每一帧画面，需要经过这些阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/frame-full.jpg&quot; alt=&quot;render&quot;&gt;&lt;br&gt;&lt;em&gt;render pipeline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中我们需要避免的主要就是Layout，如果触发了Layout的重新计算，那就意味着你的页面需要重绘，这是一个非常expensive的任务。如果我们在CSS动画时使用了GPU加速，那这些动画就不会造成重绘，而是作为一个单独的层在Compose阶段进行组合。&lt;/p&gt;
&lt;p&gt;如果是浏览器渲染用时过多，我们就需要检查代码中是否触发了不必要的浏览器重绘。这方面的优化主要是针对CSS的优化，是一个专门的专题。一般的措施是采用CSS3 transform进行动画，开启硬件加速来避免浏览器重绘。&lt;/p&gt;
&lt;h4 id=&quot;事件输入&quot;&gt;&lt;a href=&quot;#事件输入&quot; class=&quot;headerlink&quot; title=&quot;事件输入&quot;&gt;&lt;/a&gt;事件输入&lt;/h4&gt;&lt;p&gt;我们可以在Flame Chart的Interaction部分看到浏览器在这段时间触发的事件。&lt;/p&gt;
&lt;p&gt;用户注册的事件，都有对应的回调函数。因此如果这个回调函数包含大量的逻辑，并且这个事件触发非常频繁的话，比如scroll或者touchmove，那我们就需要对事件触发的频率进行限制。在防止回调函数频繁触发层面，对应的办法有JS层面的节流函数。在限制事件注册的数量层面，我们可以使用事件代理，尽量避免在一个DOM元素上注册多个触发频繁的事件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题外话：在调试移动端页面时，我发现Chrome在Timeline里标出了pinch这样的事件。说明浏览器的渲染层是支持这样的高级事件的。但在DOM的标准中没有找到这样的事件。需要大家用touch事件来合成。Chrome的这个做法不知道应该理解成浏览器面向未来的支持，还是浏览器私有的实现。当然，在移动端的操作系统层面，识别pinch应该不是一个难事。DOM的touch event中没有支持pinch，swipe等事件，这个问题值得思考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;其他数据&quot;&gt;&lt;a href=&quot;#其他数据&quot; class=&quot;headerlink&quot; title=&quot;其他数据&quot;&gt;&lt;/a&gt;其他数据&lt;/h4&gt;&lt;p&gt;Timeline中还有很多有价值的数据，比如CPU占有率，JS的Heap大小（可以简单的理解成JS的内存占用情况），DOM节点的数量，事件监听器的数量等等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unix·Talk 聊聊工程</title>
    <link href="http://yoursite.com/2016/11/19/unix-talk-engineering/"/>
    <id>http://yoursite.com/2016/11/19/unix-talk-engineering/</id>
    <published>2016-11-19T02:43:14.000Z</published>
    <updated>2016-11-29T14:50:59.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;工程是什么&quot;&gt;&lt;a href=&quot;#工程是什么&quot; class=&quot;headerlink&quot; title=&quot;工程是什么&quot;&gt;&lt;/a&gt;工程是什么&lt;/h3&gt;&lt;p&gt;首先请大家观察这两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-11-27%20at%207.00.59%20PM.png&quot; alt=&quot;vs&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果说左边的小草房是课程作业的话，那右边的高楼大厦，就是我们所说的工程。&lt;/p&gt;
&lt;p&gt;大家可以思考一下，建造两者的过程有何不同。建左边的小房子也许不需要太多的材料，也不需要对材料进行深度的加工。在设计上，只要有基本的构想即可，不需要精准的蓝图。在施工上也相对随性一些。&lt;/p&gt;
&lt;p&gt;而右边的高楼大厦，需要钢筋混凝土这种深度加工的材料去构建，需要严密的蓝图和施工周期。同时也需要数百倍于左图的人力去建造。&lt;/p&gt;
&lt;p&gt;从产出的规模和流程的复杂度来说，软件工程师和建筑工程师或者电气工程师一样，都在一套成熟的流程和体系下，打造大规模的产品。&lt;/p&gt;
&lt;p&gt;所以，在互联网行业，工程就是一套完整的产品研发方法论。同时也包括项目开发周期中的项目管理，前期估算，后期测试等流程。&lt;/p&gt;
&lt;p&gt;那为什么我们需要这套方法论呢？很简单。如果没有这套方法论指导，我们就无法顺利的开发出大型的软件，或者，我们的开发效率会很低。我们需要用工具来加速我们的开发，自动化一些无聊的工作。我们需要用设计模式来解耦我们的代码，让代码的可维护性更高。我们也需要项目管理，来让不同分工的工程师协同工作，顺利完工。&lt;/p&gt;
&lt;p&gt;而这套方法论，学校里是很少有讲到的。这也是因为，工程相关的方法论需要工程师在项目开发的过程中不断的实践总结，毕竟纸上得来终觉浅，而工程这种和实际问题特别相关的方向，则更需要在实际的项目才能有更深入的理解。&lt;/p&gt;
&lt;h3 id=&quot;工程的几个关键词&quot;&gt;&lt;a href=&quot;#工程的几个关键词&quot; class=&quot;headerlink&quot; title=&quot;工程的几个关键词&quot;&gt;&lt;/a&gt;工程的几个关键词&lt;/h3&gt;&lt;h4 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h4&gt;&lt;p&gt;俗话说，没有金刚钻，就不揽瓷器活。无论是客户端还是服务端，大家都有专属的神兵利器。&lt;/p&gt;
&lt;p&gt;其中大家使用频率最高的便是编辑器或者IDE。前端有Sublime，安卓有Android Studio，iOS有Xcode，后端有Vim。强大的IDE往往&lt;br&gt;包含了从代码提示到编译打包的一条路服务。而Sublime这样的轻量级编辑器，需要我们进行各种DIY，打造成自己想要的样子。好用的编辑器往往会提高开发的效率，带来生产力的提高。&lt;/p&gt;
&lt;p&gt;在客户端开发中，打包构建工具也是一个重要的类别。好用的打包工具不仅仅可以降低打包的时间，在前端等领域，好用的打包工具甚至代表了一种工具生态，串联起了一个完整的工具链。&lt;/p&gt;
&lt;p&gt;开发中用到的工具还有很多。很多小工具的诞生，往往是为了解决某一个具体问题的。程序员往往希望一切机械的事务都可以自动化。并且也喜欢将繁杂的数据可视化。这两个动机驱动了很多小工具的诞生。&lt;/p&gt;
&lt;p&gt;趁手的工具代表了先进的生产力。这也是构建大型工程时必须借助的垫脚石。工程化程度高的技术团队，往往都有着自己的先进工具。&lt;/p&gt;
&lt;h4 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h4&gt;&lt;p&gt;编码规范包括代码风格，目录结构等等。这些编码规范的存在，一方面是约束团队成员的代码质量，使得一些低级错误和语言中的bad practice得到提醒和控制。一方面，代码规范中的一些代码风格相关的部分，是为了让团队成员的代码风格统一，这样有利于后期代码库的维护和迭代。&lt;/p&gt;
&lt;p&gt;我们可以使用一些Lint工具和持续集成等技术来将编码规范落地。一个团队的编码规范应该被写在一个单独的仓库或者文档里，以供团队成员参考。&lt;/p&gt;
&lt;h4 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h4&gt;&lt;p&gt;设计模式有很多，从常见的工厂模式，单例模式，观察者模式，装饰器模式等到应用架构层面的MVC，MVVM等。&lt;/p&gt;
&lt;p&gt;设计模式主要帮我们将一个大型的系统解耦成不同的层次。比如将数据层和视图层分离，并用一个中间层将二者联系起来。&lt;/p&gt;
&lt;p&gt;因为大型的系统的模块数量众多，不同模块之间关系复杂。我们要用设计模式来将不同的模块划入不同的层次。&lt;/p&gt;
&lt;p&gt;而观察者模式这样的设计模式主要是为了使模块之间可以实现松耦合下的通信。虽然模块之间有着各种的依赖和调用关系，但我们并不打算让不同模块直接相互调用，而是实现一套接口，并借助中间人通信。这样如果某个模块被替换，只要新的模块实现了相同的接口，整个系统依然可以正常运行。&lt;/p&gt;
&lt;p&gt;在开发软件时，我们一般都遵循一套成熟的模式，在此基础上，完成业务代码的编写。设计模式也是大型软件的基石。&lt;/p&gt;
&lt;p&gt;对于设计模式，关键点往往不是你能说出几个设计模式，而是你懂得在什么情况下使用合适的设计模式。&lt;/p&gt;
&lt;h4 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h4&gt;&lt;p&gt;现在主流的版本控制工具是Git。Git主要的作用是版本控制，同时也帮助我们进行多人的协作。&lt;/p&gt;
&lt;p&gt;没有Git的话，如果我们需要保留多个不同版本的代码，就需要手动保存。在多人协作时，没有Git也是无法想象的。比如用FTP进行协作，每次都覆盖式的保存，这样的的代码管理无疑是非常原始的。&lt;/p&gt;
&lt;p&gt;事实上Git的Branch以及Github的pull request等等机制造就了一套独特的Git工作流。这套工作流无疑是团队协作的最佳选择之一。&lt;/p&gt;
&lt;h4 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h4&gt;&lt;p&gt;其实编程的精华便在于对过程（precedure）以及数据的抽象。这是一种编程的内功。通过对过程的抽象，我们可以将程序中可复用的模块提取成单独的函数，然后进行组合，这样可以大大增强程序的表现力。通过对数据的抽象，我们可以封装数据的细节，从一个更通用的维度来对数据进行操作。&lt;/p&gt;
&lt;p&gt;对于抽象，推荐大家看《计算机程序的构造与解释》这本书。当然抽象要合理才行，过度的抽象也会使代码的易读性受损。&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h4&gt;&lt;p&gt;测试主要是为了保证软件的质量。在软件被开发完成之后，会进行一系列的测试，以保证软件的高可用性。一般团队会有专门的测试工程师。负责测试用例的编写。&lt;/p&gt;
&lt;p&gt;对于后端这样主要负责数据处理的逻辑，我们可以编写自动化的单元测试，并且进行持续集成。单元测试以一个模块为单元进行测试，这样我们在错误发生时，可以准确的定位到具体的模块。单元测试也被用在测试驱动的开发中，测试驱动的开发就是先写测试用例，然后编写可以通过这个测试用例的代码。&lt;/p&gt;
&lt;p&gt;对于客户端代码来说，因为UI复杂多变。所以自动化的单元测试只有在对框架/库的代码进行测试时比较实际，在业务逻辑层面，比如视图层，我们一般采用人工测试。当然现在也有自动化的UI测试方案。&lt;/p&gt;
&lt;h4 id=&quot;项目管理&quot;&gt;&lt;a href=&quot;#项目管理&quot; class=&quot;headerlink&quot; title=&quot;项目管理&quot;&gt;&lt;/a&gt;项目管理&lt;/h4&gt;&lt;p&gt;项目管理，是学校软件工程课程中主要涉及的。这个主要涉及传统软件的开发流程。从需求分析，成本估算，开发流程到最后的测试。&lt;/p&gt;
&lt;p&gt;互联网的开发模型上主要还是比较敏捷的迭代。通常以一个月甚至几周的周期进行迭代。其中Web应用的特点便是可以随时发布更新，所以在这方面显得更突出一些。&lt;/p&gt;
&lt;p&gt;关于项目管理或者软件工程，大家可以去看《人月神话》，《构建之法》等书。虽然这些书主要针对的是传统软件工程，但我们在互联网产品的开发中还是可以从中汲取一些经验的。&lt;/p&gt;
&lt;h3 id=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;a href=&quot;#适合我们团队的一套工程化流程&quot; class=&quot;headerlink&quot; title=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;/a&gt;适合我们团队的一套工程化流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技术选型&lt;/strong&gt;-选用最合适的技术栈，当然为了把玩新技术而选用比较新的技术栈也是可以的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合适的工具&lt;/strong&gt;-鼓励大家，没有在开源社区找到符合自己要求的工具时，打造自己专属的工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git协作&lt;/strong&gt;-Git工作流&lt;/li&gt;
&lt;li&gt;代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;项目架构&lt;/strong&gt;-合适的抽象，不仅仅是MVC等架构，也包括其他可以复用的组件和Utility模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码审查&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单元测试（后端）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人肉或自动测试（客户端）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制Vue插件</title>
    <link href="http://yoursite.com/2016/11/13/vue-finger/"/>
    <id>http://yoursite.com/2016/11/13/vue-finger/</id>
    <published>2016-11-13T08:21:56.000Z</published>
    <updated>2016-11-30T08:48:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-finger，一个插件的诞生&quot; class=&quot;headerlink&quot; title=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;/a&gt;Vue-finger，一个插件的诞生&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-fin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊CSS Modules</title>
    <link href="http://yoursite.com/2016/11/12/css-modules/"/>
    <id>http://yoursite.com/2016/11/12/css-modules/</id>
    <published>2016-11-12T12:02:32.000Z</published>
    <updated>2016-11-13T09:22:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决全局作用域：Webpack-css-loader&quot;&gt;&lt;a href=&quot;#解决全局作用域：Webpack-css-loader&quot; class=&quot;headerlink&quot; title=&quot;解决全局作用域：Webpack css-loader&quot;&gt;&lt;/a&gt;解决全局作用域：Webpack css-loader&lt;/h3&gt;&lt;p&gt;Webpack的css-loader首先做出了解决全局作用域的尝试。解决办法就是在写CSS类名时加入&lt;code&gt;:local(...)&lt;/code&gt;这样的标记。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:local(.className) { background: red; }
:local .className { color: green; }
:local(.className .subClass) { color: green; }
:local .className .subClass :global(.global-class-name) { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转化为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;._23_aKvs-b8bW2Vg3fwHozO { background: red; }
._23_aKvs-b8bW2Vg3fwHozO { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 .global-class-name { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的办法就是把CSS类名转化为hash字符串，这样就可以保证每个类名都是独一无二的，自然也就不用在意命名冲突的问题了。只要在类名在当前模块内不会相互冲突就可以了。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules&quot;&gt;&lt;a href=&quot;#CSS-Modules&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules&quot;&gt;&lt;/a&gt;CSS Modules&lt;/h3&gt;&lt;p&gt;上述的办法，还是有一些不便。大多数情况下，比如在JavaScript中，变量都默认是局部变量。你想要声明一个全局变量，只能去全局作用域声明，或者把变量挂到local上（非严格模式下，不写var声明的是全局变量这种坑就不说了）。&lt;/p&gt;
&lt;p&gt;Webpack的开发者之后将css-loader中的local变成了默认设定，于是CSS Modules这个规范就呼之欲出了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/css-modules/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules规范&lt;/a&gt;。我们可以通过&lt;code&gt;css-loader?modules&lt;/code&gt;这个参数来开启CSS Modules。&lt;/p&gt;
&lt;p&gt;CSS Modules中的类名默认就是local的，如果你想要声明全局类名，可以加上&lt;code&gt;:global(...)&lt;/code&gt;这个标记。&lt;/p&gt;
&lt;h3 id=&quot;Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;Single Responsibility Principle&quot;&gt;&lt;/a&gt;Single Responsibility Principle&lt;/h3&gt;&lt;p&gt;讲CSS Modules的下一个特性之前。我们先聊点其他的，我们知道设计模式中有一条叫做Single Responsibility Principle。&lt;/p&gt;
&lt;p&gt;比如我们有一个button：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
    padding:2em;
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其把这些属性写在一个class里，我们可以把它拆分成多个单独的class：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--large{
    padding:2em;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在HTML中组合使用就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--large button--warnning&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的好处是什么呢？我们的UI中，一个组件往往有很多不同的状态。如果我们将每一个class写成只专注于一个属性，做好一件事，那就可以用这些class组合成所有我们想要的不同状态的组件。相比给每个状态的组件写一个单独的class，代码要更优雅简洁一些。&lt;/p&gt;
&lt;p&gt;比如我们想要一个small尺寸的普通button，只要加两个class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--small{
    padding:1em;
}
.button--large{
    padding:2em;
}
.button--normal{
    background-color:blue;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后组合就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--small button--normal&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;CSS-Classes-Composing&quot;&gt;&lt;a href=&quot;#CSS-Classes-Composing&quot; class=&quot;headerlink&quot; title=&quot;CSS Classes Composing&quot;&gt;&lt;/a&gt;CSS Classes Composing&lt;/h3&gt;&lt;p&gt;要想实现上述的这种组合，可以使用SASS的Mixin，但Mixin主要是提供了源代码中的抽象，最后生成的代码，和手写不同状态class的代码量，是一样的。&lt;/p&gt;
&lt;p&gt;CSS Modules提供的Classes Composing则刚好可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;比如我们想渲染一段文字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text{
  font-size: 20px;
  composes: red from &amp;quot;./common/color.css&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;color.css里是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.red{
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后渲染出的class是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;composes&lt;/code&gt;引入的类被作为一个单独的class引入，而不是和text类合在一起。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules和Vue工作流的整合&quot;&gt;&lt;a href=&quot;#CSS-Modules和Vue工作流的整合&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules和Vue工作流的整合&quot;&gt;&lt;/a&gt;CSS Modules和Vue工作流的整合&lt;/h3&gt;&lt;p&gt;Vue-loader在v9.8.0之后加入了对CSS Modules的支持。&lt;/p&gt;
&lt;p&gt;我们只要在&lt;code&gt;.vue&lt;/code&gt;文件的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;处加一个&lt;code&gt;module&lt;/code&gt;就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style lang=&amp;quot;sass&amp;quot; module&amp;gt;
.text{
  font-size: 20px;
  composes: red from &amp;quot;sass!./common/color.scss&amp;quot;;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有一点要注意，就是&lt;code&gt;composes&lt;/code&gt;引入的如果是需要预处理器处理的，要在前面加上预处理器的标记，比如SASS用户就加上&lt;code&gt;sass!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果需要对CSS Modules进行一些配置（其实这个是对Webpack的css-loader的配置，所以配置时可以参考&lt;a href=&quot;https://github.com/webpack/css-loader&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;css-loader的文档&lt;/a&gt;），写在vue-loader的配置的&lt;code&gt;cssModules&lt;/code&gt;属性里即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;loader: &amp;#39;vue&amp;#39;,
options: {
    cssModules: {
        localIdentName: &amp;#39;[name]-[local]-[hash:base64:5]&amp;#39;,
        camelCase: true
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vue-loader会自动将一个&lt;code&gt;$style&lt;/code&gt;属性注入到对应的Vue实例中。在模板中用class binding语法写就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div :class=&amp;quot;$style.app&amp;quot;&amp;gt;
    &amp;lt;div :class=&amp;quot;$style.text&amp;quot;&amp;gt;
      some text
    &amp;lt;/div&amp;gt;
    &amp;lt;main-text&amp;gt;&amp;lt;/main-text&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$style&lt;/code&gt;其实是一个原class名和处理之后class名的hash，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  app: &amp;quot;App-app-3cl75_0&amp;quot;,
  text: &amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我写一了一个简单的&lt;a href=&quot;https://github.com/zxc0328/css-modules-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO仓库&lt;/a&gt;，可以供参考。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;CSS Modules可以解决全局作用域和Class组合两个问题，加上SASS等预处理器，着实让我们在写CSS时的工程化程度大大提高了。&lt;/p&gt;
&lt;p&gt;对于使用Vue的同学来说，vue-loader可以使CSS Modules可以轻松的整合到已有的工作流中。如果你正在使用Vue，可以试试使用CSS Modules。&lt;/p&gt;
&lt;h3 id=&quot;Links&quot;&gt;&lt;a href=&quot;#Links&quot; class=&quot;headerlink&quot; title=&quot;Links&quot;&gt;&lt;/a&gt;Links&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://glenmaddern.com/articles/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules Welcome to the Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=zR1lOuyQEt8&amp;amp;index=29&amp;amp;list=LLHdx8Qwo6uxw0fj3gQ5yeTg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The case for CSS modules - Mark Dalgleish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React: CSS in JS by vjeux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>猪场实习感受-项目管理</title>
    <link href="http://yoursite.com/2016/10/03/project-management-in-netease/"/>
    <id>http://yoursite.com/2016/10/03/project-management-in-netease/</id>
    <published>2016-10-03T07:39:01.000Z</published>
    <updated>2016-10-03T08:08:53.000Z</updated>
    
    <content type="html">&lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;总的来说就是PM提出需求，交互出交互稿，然后这时研发和视觉可以同时开始进行。最后进行测试，测试通过后上线。这就是一个互联网产品版本迭代的过程。&lt;/p&gt;
&lt;h3 id=&quot;时间规划&quot;&gt;&lt;a href=&quot;#时间规划&quot; class=&quot;headerlink&quot; title=&quot;时间规划&quot;&gt;&lt;/a&gt;时间规划&lt;/h3&gt;&lt;p&gt;在上一个版本的开发过程中，PM和各个负责人就可以开始讨论下一个版本的需求，然后项目经理和大家一起确定这个版本的研发、测试和上线的时间节点。这个时间一旦确定，就必须严格执行，如果有需求无法完成要移到下一个版本做，必须经各个负责人确认后向大家发邮件说明。&lt;/p&gt;
&lt;h3 id=&quot;评审&quot;&gt;&lt;a href=&quot;#评审&quot; class=&quot;headerlink&quot; title=&quot;评审&quot;&gt;&lt;/a&gt;评审&lt;/h3&gt;&lt;p&gt;在我实习时，我作为开发，主要参加的就是交互的评审。这个评审的时间点在即将进入研发之前。其实主要就是交互设计师讲解交互稿，相关的开发人员提出自己的疑问，完善交互的可行性。&lt;/p&gt;
&lt;p&gt;按理来说应该还有需求评审、设计评审和代码评审。这些在实习时，比如代码评审因为时间的原因，没有做。在木犀的项目实践中，我觉得我们可以加入这些评审。时间的节点在视觉和开发完成，即将进入测试之前。&lt;/p&gt;
&lt;h3 id=&quot;JIRA&quot;&gt;&lt;a href=&quot;#JIRA&quot; class=&quot;headerlink&quot; title=&quot;JIRA&quot;&gt;&lt;/a&gt;JIRA&lt;/h3&gt;&lt;p&gt;JIRA是一款很有名的项目管理工具。在公司，我们一般是按需求创建Story，然后把交互、视觉和开发等任务关联到这个需求上。JIRA还有一个作用就是用来管理Bug。发现Bug的人可以提交Bug并指派给相关的责任人。JIRA有各种面板和筛选，可以方便的管理项目。&lt;/p&gt;
&lt;p&gt;我们暂时可以用Tower的任务来发挥JIRA的作用。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h3&gt;&lt;p&gt;测试主要是由专职的测试进行。测试负责编写测试用例，以及进行测试。&lt;/p&gt;
&lt;p&gt;当然，开发人员自己的自测是第一道防线。在开发完全之后，会进行冒烟测试，由测试提供用例，开发自行测试。用例主要和这一个版本的需求有关，主要就是检测一下需求中的功能是否被实现。只有冒烟测试通过了，才能进入真正的测试阶段。&lt;/p&gt;
&lt;p&gt;在测试人员进行测试的阶段。开发人员往往还要配合进行若干次的回归测试。同时要及时解决测试提出的Bug。&lt;/p&gt;
&lt;p&gt;首先测试开发环境下的项目，然后是测试环境，最后是预发布环境。预发布环境测试通过且Bug都解决的情况下，就可以上线了。&lt;/p&gt;
&lt;p&gt;对于我们这样的小团队来说，专职的测试是不太可能有的。主要就是在项目组中加入一位兼职的同学担任测试这个角色，然后各个模块的同学做到充分的自测。视觉、产品和交互进行走查（就是以用户的角度使用产品，来看是否有问题）。这样就可以保证较好的产品质量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个组件的诞生(下)</title>
    <link href="http://yoursite.com/2016/09/30/let-s-build-a-component-2/"/>
    <id>http://yoursite.com/2016/09/30/let-s-build-a-component-2/</id>
    <published>2016-09-30T02:34:07.000Z</published>
    <updated>2016-10-03T03:17:57.000Z</updated>
    
    <content type="html">&lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot;&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url1: &amp;quot;/somewhere/1.jpg&amp;quot;,
        url2: &amp;quot;/somewhere/2.jpg&amp;quot;
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction
            var indicators = document.querySelector(&amp;quot;.indicator&amp;quot;);
            indicators.map( (item, index) =&amp;gt; {
                _.removeClass(item, &amp;quot;hightLight&amp;quot;);
                if (index === data.index) {
                    _.addClass(item, &amp;quot;highLight&amp;quot;);
                }
            })    
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这的确可以实现我们想要的逻辑，但是看起来还是有点累赘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/4f19d188d43babcf6362d2372307492c_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们能把一部分逻辑写在模板里，然后在组件中，只需要修改数据，模板就会进行对应的渲染，是不是很酷呢？&lt;/p&gt;
&lt;p&gt;这就是所谓的&lt;strong&gt;数据驱动&lt;/strong&gt;。组件帮我们封装了底层的DOM操作细节。我们只需要声明组件的状态就可以了。用户的交互造成组件的状态改变，然后状态的改变又造成了DOM层面的重新渲染。组件就像是一个黑盒子，接收我们输入的数据，输出视图。计算机做的事情其实就是处理数据。因此，我们做这样的抽象，是非常&lt;strong&gt;符合本能的一种抽象&lt;/strong&gt;。可以让我们集中精力来关注业务逻辑。同时也&lt;strong&gt;降低了前端组件的复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那就让我们来试试吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url }}&amp;quot; for=&amp;quot;url in urls&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot; &amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot; 
        class=&amp;quot;{{ $index === index ? &#39;highLight&#39; : &#39;normal&#39; }}&amp;quot;
          for=&amp;quot;url in urls&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url: [&amp;quot;/somewhere/1.jpg&amp;quot;, &amp;quot;/somewhere/2.jpg&amp;quot;]
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction //更新index
            this.render() //重新渲染
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有一个新的&lt;code&gt;for=&amp;quot;url in urls&amp;quot;&lt;/code&gt;，我们把这个叫做指令。指令可以理解为为模板增加分支、循环等逻辑的标记。模板引擎在编译这个指令时就会按数据进行对应的渲染。这里用到的是循环指令，作用就是按给定的数据循环遍历，每遍历到一个就讲数据填充到模板中进行渲染。&lt;code&gt;$index&lt;/code&gt;是这个指令中一个特殊的变量，代表当前遍历到的元素的下标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样就清楚多啦。我们修改&lt;code&gt;data.index&lt;/code&gt;，然后调用&lt;code&gt;this.render()&lt;/code&gt;这个生命周期方法。不用操纵任何DOM节点。视图就更新了。是的，我们在某种程度上实现了数据驱动！&lt;/p&gt;
&lt;h3 id=&quot;Vue-and-beyond&quot;&gt;&lt;a href=&quot;#Vue-and-beyond&quot; class=&quot;headerlink&quot; title=&quot;Vue and beyond&quot;&gt;&lt;/a&gt;Vue and beyond&lt;/h3&gt;&lt;p&gt;大家可以对比一下Vue的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue({
  el: &amp;#39;#app&amp;#39;,
  data: {
    message: &amp;#39;Hello Vue.js!&amp;#39;
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和我们的组件的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        message: &amp;#39;Hello Vue.js!&amp;#39;
    },
    events: {
        &amp;quot;.some-button.click&amp;quot;: this.oClick,
    },
    methods: {
        onClick: function() {
            // 业务逻辑
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是很像呢，除了&lt;code&gt;events&lt;/code&gt;这个选项。因为Vue把这些逻辑都放到指令中了，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;button v-on:click=&amp;quot;reverseMessage&amp;quot;&amp;gt;Reverse Message&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以Vue的本质，就是一个用来构建用户界面的组件库。和我们一步步的设计API，调整模板，构建出来的这个组件，没有本质的区别。&lt;/p&gt;
&lt;p&gt;但Vue为什么好用呢？首先Vue有完善的指令系统，比如&lt;code&gt;v-for``v-for&lt;/code&gt;和&lt;code&gt;v-if&lt;/code&gt;等。其次是Vue实现了数据的双向绑定。双向绑定就是用户在界面上输入的数据，可以被同步到组件的状态中。刚才，我们在自己的组件中实现了将组件状态同步到界面，而双向绑定就以为着这个同步可以是反向的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双向绑定的实现是一个单独的话题。Angular使用的脏检查是一个流派。Vue使用&lt;code&gt;Object.defineProperty&lt;/code&gt;API来实现。React倒是没有数据绑定的概念，不过React的Virtual DOM Diff从某种角度来说，其实也是脏检查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们所实现的其实是一种粗犷的同步方式。并没有实现所谓的数据“绑定”。数据绑定就以为着为每个模板中被绑定的数据创建一个&lt;code&gt;Watcher&lt;/code&gt;，这个&lt;code&gt;Watcher&lt;/code&gt;决定数据变化时做什么操作。比如对于DOM中的表达式，&lt;code&gt;Watcher&lt;/code&gt;就会对这个表达式重新求值，然后更新这个表达式所在的DOM节点的对应属性。&lt;/p&gt;
&lt;p&gt;按之前我们的做法，如果一个数据变动，就会造成整个组件的重新渲染。这样明显是低效的。数据绑定可以做到特定DOM节点的更新，这是目前前端组件的主流。&lt;/p&gt;
&lt;h3 id=&quot;从MVC到MVVM&quot;&gt;&lt;a href=&quot;#从MVC到MVVM&quot; class=&quot;headerlink&quot; title=&quot;从MVC到MVVM&quot;&gt;&lt;/a&gt;从MVC到MVVM&lt;/h3&gt;&lt;p&gt;前端的MVC或者MVVM，View一般就指模板（模板可以看成是抽象的View，DOM则是这个抽象View的implementation detail）。我们的第一个组件构造器构造出来的对象其实是MVC中的Controller。里面的&lt;code&gt;data&lt;/code&gt;属性应该被单独拿出作为一个Model对象，这个对象可以通过观察者模式和Controller进行通信。&lt;/p&gt;
&lt;p&gt;MVVM中的Model就是一个plain object，比如我们打造的组件中的&lt;code&gt;data&lt;/code&gt;。Vue这样的MVVM框架，Vue实例其实是MVVM中的VM，即ViewModel。Model，如上文说的，是一个挂载在&lt;code&gt;data&lt;/code&gt;属性上的普通的对象。我们修改这个对象，就会驱动View的更新。MVVM的独特处之一就在于此。MVVM的独特处之二就是，Model和View直接数据的双向绑定。VM和MVC中Controller的不同之处在于通信方式的不同。MVVM中各个部分的联动比较复杂，我们叫reactive system。MVC中的事件广播模式，主要是在组件之间的通信这个层面比较明显。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个组件的诞生(上)</title>
    <link href="http://yoursite.com/2016/09/29/let-s-make-a-component/"/>
    <id>http://yoursite.com/2016/09/29/let-s-make-a-component/</id>
    <published>2016-09-29T02:24:27.000Z</published>
    <updated>2016-09-30T08:00:43.000Z</updated>
    
    <content type="html">&lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var banner = {
    init: function() {
        this.addEvent();
    },
    addEvent: function() {
        var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
        var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
        buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(1)
        })
        buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(-1)
        })

    },
    switchClassName: function(direction) {
        // 切换Class类名
    }
}

banner.init();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;1.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;2.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;3.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/monocle-guy/jolly-god-old-chap-thumb.jpg&quot; alt=&quot;old chap&quot;&gt;&lt;/p&gt;
&lt;p&gt;正当你觉得自己可以刷知乎的时候，主管把你叫到一边，告诉你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你这个页面上需要有两个banner，怎么办呢？复制粘贴吗?&lt;/li&gt;
&lt;li&gt;如果在需要在某个时间点从页面上移除banner，怎么办呢？手动remove节点吗，销毁对象吗？&lt;/li&gt;
&lt;li&gt;如果banner中图片的URL是从服务端API请求到的动态的数据，难道要用一个个用修改图片的src的方法来显示这些数据吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;听到这里，你的内心是崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/y-u-no/css-floats-y-u-no-clear-yourself-thumb.jpg&quot; alt=&quot;y no &quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;面向对象大法&quot;&gt;&lt;a href=&quot;#面向对象大法&quot; class=&quot;headerlink&quot; title=&quot;面向对象大法&quot;&gt;&lt;/a&gt;面向对象大法&lt;/h3&gt;&lt;p&gt;这时，你想起了大学时学过的面向对象。你把你的组件改成了这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Banner = function(options) {
}

Banner.prototype.init = function() {
    this.addEvent();
}

Banner.prototype.addEvent = function() {
    var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
    var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
    buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(1);
    })
    buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(-1);
    })
}

Banner.prototype.switchClassName = function(direction) {
    // 切换Class类名
}

Banner.prototype.destroy = function() {
    //todo:解绑事件
}

//初始化
var banner1 = new Banner();
var banner2 = new Banner();

//销毁
banner1.destroy();
banner2.destroy();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;棒，这样就可以轻松的使用多个banner，并通过调用&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;等生命周期方法来初始化和销毁组件了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生命周期&lt;br&gt;这是组件开发中的一个术语。如果把组件比作一个生物，我们设计的API，比如&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;就相当于这个生物的出生和死亡。一个组件从&lt;code&gt;init&lt;/code&gt;被调用时被初始化，渲染到页面上，然后和用户发生交互，这时调用的方法也属于生命周期的一部分。用户界面随着用户的交互而发生变化，所以组件也不是一成不变的。生命周期方法其实就是在组件的某个阶段会被调用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模板和渲染&quot;&gt;&lt;a href=&quot;#模板和渲染&quot; class=&quot;headerlink&quot; title=&quot;模板和渲染&quot;&gt;&lt;/a&gt;模板和渲染&lt;/h3&gt;&lt;p&gt;还有一个问题没有解决，那就是如何轻松的将数据填充到DOM节点中呢？&lt;/p&gt;
&lt;h4 id=&quot;字符串拼接大法&quot;&gt;&lt;a href=&quot;#字符串拼接大法&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接大法&quot;&gt;&lt;/a&gt;字符串拼接大法&lt;/h4&gt;&lt;p&gt;你首先想出了一个比较笨的办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var url = &amp;quot;/images/1.png&amp;quot;
var template = funtion(url) {
    return &amp;quot;&amp;lt;img src=&amp;#39;&amp;quot; + url + &amp;quot;&amp;#39;/&amp;gt;&amp;quot;;
}

template(url); // &amp;quot;&amp;lt;img src=&amp;#39;/images/1.png&amp;#39;/&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是传说中的字符串拼接大法。一种非常原始的“模板”。简单的说就是把HTML中不变的部分原样写成字符串，中间的变化的部分，我们叫模板的变量，会被作为参数输入到模板函数中。然后这些变量和字符串拼接起来，就生成了目标HTML字符串。&lt;/p&gt;
&lt;p&gt;上例中的&lt;code&gt;template&lt;/code&gt;函数做的事情，我们叫做“编译”模板。当然这个函数非常简单，只是拼接了一下字符串。一个成熟的模板引擎的编译函数做的事情，要更接近于传统意义上的“编译”。&lt;/p&gt;
&lt;h4 id=&quot;DOM-based模板&quot;&gt;&lt;a href=&quot;#DOM-based模板&quot; class=&quot;headerlink&quot; title=&quot;DOM based模板&quot;&gt;&lt;/a&gt;DOM based模板&lt;/h4&gt;&lt;p&gt;字符串拼接大法的问题，相信大家都看到了，就是写起来非常的麻烦，各种单引号和双引号。如果要换行还必须用&lt;code&gt;+&lt;/code&gt;号拼接。&lt;/p&gt;
&lt;p&gt;于是我们就想到了，如果我们把模板作为普通的HTML，那就会方便很多。我们只要像写HTML那样把模板写在HTML文件中，比如:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要向获取模板的内容，只需要这样：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的就是这个模板的字符串了。&lt;/p&gt;
&lt;p&gt;假设我们写了一个模板引擎，它的作用就是将&lt;code&gt;&lt;/code&gt;花括号内的表达式，在模板的context下面解析，并返回值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context，就是指一个特定的作用域。里面有当前作用域下面的变量（标识符）和对应的值之间的映射。模板的context就是指一个有模板中相关变量的作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个模板引擎是这样使用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#39;complie&amp;#39; from &amp;#39;templateEngine&amp;#39;

var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML
var data = {
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
var HTMLString = compile(templateString, data)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当&lt;code&gt;compile&lt;/code&gt;函数遇到变量时，就会从&lt;code&gt;data&lt;/code&gt;中去找。&lt;code&gt;data&lt;/code&gt;在这个例子就是context。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插一句，被大家吐槽的&lt;code&gt;eval&lt;/code&gt;函数可以用来做在特定context下求值的事情，这正是这种模板引擎所需要做的。所以你可以用&lt;code&gt;eval&lt;/code&gt;来实现一个简单的模板引擎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为这个花括号中可以是任意合法的JavaScript表达式，所以你也可以这样玩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//其他省略
var data = {
    displayFlag: false,
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;{{ displayFlag ? &#39;display:block&#39;:&#39;display:none&#39;}}&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很神奇，不是吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ricardomartins.com.br/wp-content/uploads/2015/05/Magic_meme.gif&quot; alt=&quot;magic&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;render生命周期方法&quot;&gt;&lt;a href=&quot;#render生命周期方法&quot; class=&quot;headerlink&quot; title=&quot;render生命周期方法&quot;&gt;&lt;/a&gt;&lt;code&gt;render&lt;/code&gt;生命周期方法&lt;/h4&gt;&lt;p&gt;因为现在我们的组件不再使用静态的HTML字符串了，我们需要一个函数来输出HTML字符串。所以我们需要在组件上增加一个叫&lt;code&gt;render&lt;/code&gt;的生命周期函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Banner.prototype.render = function() {
    this.el.innerHTML = compile(this.el.innerHTML, this.data);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的&lt;code&gt;el&lt;/code&gt;是这个组件的一个配置项，代表这个组件的根节点。组件的模板来自根节点的内容。模板编译之后输出的HTML字符串又会替换根节点中的模板，从而渲染这个组件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，模板所在的节点和渲染组件的节点可以不是同一个，这个是和具体的组件框架实现相关的。只要模板可以以字符串的形式被引入，就可以达到目的了。是否放在HTML的DOM节点中并不是问题的关键。我们可以写单独的模板文件并用webpack等打包工具引入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h3&gt;&lt;p&gt;一个组件中，比如模板根节点，组件某个节点的事件和handler的Map，事件的handler，以及组件的&lt;code&gt;data&lt;/code&gt;这样的数据，应该在组件实例化的时候，作为配置被传入构造函数中。&lt;/p&gt;
&lt;p&gt;所以，让我们改造一下Banner构造函数和&lt;code&gt;init&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Banner = function(options) {
    this.data = options.data || {};
    this.el = options.el || document.querySelector(&amp;quot;body&amp;quot;);
    this.events = options.events;
}

Banner.prototype.init = function(options) {
    this.render();//渲染模板
    this.addEvent(this.events);//根据events这个Map来绑定事件
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，如果你这样再初始化一个组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        url1: &amp;quot;/somewhere/1.jpg&amp;quot;,
        url2: &amp;quot;/somewhere/2.jpg&amp;quot;
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑        
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里我们新增了events和methods两个对象，这其实就是将之前写死在组件内部逻辑里的事件绑定和回调函数拿出来，在初始化时传入，由组件内部根据这个配置自动绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并调用&lt;code&gt;init&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;banner.init()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时你的页面上就出现了一个banner！大功告成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/pp.png&quot; alt=&quot;pp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;API设计和抽象&quot;&gt;&lt;a href=&quot;#API设计和抽象&quot; class=&quot;headerlink&quot; title=&quot;API设计和抽象&quot;&gt;&lt;/a&gt;API设计和抽象&lt;/h3&gt;&lt;p&gt;到这里，我们的组件之旅就达到了一个阶段。我们对比一下就可以发现，传统的Backbone和jQuery UI的组件就是类似这种模式的。&lt;/p&gt;
&lt;p&gt;具体的说，首先你的组件是一个构造函数，你通过传入不同的配置来实例化不同的组件。不知道大家有没有发现，我们的组件以及&lt;strong&gt;不仅仅是一个Banner&lt;/strong&gt;了，而是一个&lt;strong&gt;通用&lt;/strong&gt;的组件。你通过传入不同的模板、数据、事件和回调来实例化不同的组件。可以是一个Banner，也可以是一个评论框等等。&lt;/p&gt;
&lt;p&gt;传统前端组件有着相似的生命周期API设计。比如初始化、渲染、销毁等。这个和前端组件的特点有关，就算是React或者Vue这样最新的技术，它的生命周期API也不外乎这几种，再加上一些和自己这个库运行流程相关的特有的API而已。&lt;/p&gt;
&lt;p&gt;模板是一种对DOM的封装。模板把我们从手动操纵DOM中解放出来。我们在传统的HTML基础上加入表达式和分支逻辑，让模板可以根据输入的数据渲染出相应的HTML字符串。这实际上就是将HTML作为底层的细节封装起来。模板作为一种&lt;strong&gt;中间形态&lt;/strong&gt;存在，是&lt;strong&gt;一种抽象&lt;/strong&gt;。抽象，是计算机最&lt;strong&gt;本质&lt;/strong&gt;的一种属性。我们在平时的API设计和编码时应该牢记这一点，培养自己的抽象思维。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zxc0328.github.io/2016/09/30/let-s-build-a-component-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下一篇&lt;/a&gt;会讲到如何将我们的组件改造成数据驱动的模式，并将这个组件和Vue进行对比。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编码》导读</title>
    <link href="http://yoursite.com/2016/09/15/read-code/"/>
    <id>http://yoursite.com/2016/09/15/read-code/</id>
    <published>2016-09-15T10:32:05.000Z</published>
    <updated>2016-10-25T15:19:44.000Z</updated>
    
    <content type="html">&lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;《编码》讲的是什么呢？笼统的说，就是用自底向上的角度一层层的解析计算机的原理。比如第一章到第三章将的是编码的本质——信息和符号的对应。第四章到第六章讲的是电信号可以用来表示一种编码，从而传递信息。第七章到第九章介绍了二进制，也就是计算机系统中最基本的编码形式。第十章：逻辑与开关和第十一章：门，介绍了布尔代数，以及如何使用门电路进行布尔代数的运算。第十二章和第十三章介绍了二进制加法器和减法器，加法器已然是现代CPU中运算单元的雏形了。第十四章介绍的反馈与触发器是实现计算机中储存芯片的基础。第十五章字节与十六进制是为理解后续的存储器数据格式而准备的。第十六章讲了存储器的组织，这便是现代计算机系统中存储系统的原理。第十七章，是全书最难的一章，讲了如何制作一个CPU。CPU本质上就是一个可以编程的运算器。第十八章介绍了从算盘到机械结构到电子管再到晶体管的技术革命，晶体管、超大规模集成电路使得现代CPU的出现成为了可能。第十九章介绍了Intel 8080CPU的指令集。第二十章介绍了字符的存储格式，这可以帮助你理解计算机是如何存储文本的。第二十一章：总线，介绍了计算机系统中CPU、内存和I/O设备如何通信。第二十二章是一个简短的操作系统简史，注意到从这里我们涉及了软件层面的内容。第二十三章定点数和浮点数比较独立，主要讲了计算机是如何存储浮点数的。第二十四章和第二十五章则介绍了编程语言和图形学基础。&lt;/p&gt;
&lt;p&gt;我们可以清晰的看到从硬件到软件，从具体到抽象，从底层到顶层的一个脉络。&lt;/p&gt;
&lt;p&gt;这本书其实包含了我们计算机专业中《数字逻辑》、《计算机组成原理》、《微机系统与接口原理》三门课的主干内容。作者没有试图灌输大量的理论知识，而是试图将这些知识串联起来，包括最后的操作系统和编程语言，其实和计算机硬件是有着不可分割的关系的。在《编码》这本书中你就可以很自然的在章节的推进中体会到这种联系。&lt;/p&gt;
&lt;p&gt;下面我会对一些章节进行详细的解读。主要是解释难点，拓展一些知识，并且写清这一章节的知识对应我们的哪门专业课，而专业课和这本书的要求有何不同等等。&lt;/p&gt;
&lt;p&gt;我希望这本书可以让大家看清计算机的本质，计算机的本质其实就是一个处理信息的机器。你输入数据，计算机输出数据。首先我们需要一套编码系统来表示这些数据，而二进制的编码正好与半导体的性质相吻合，我们可以用布尔代数来对现实问题进行建模，通过门电路来表示这个布尔代数，从而制造出可以进行某种运算的电路。而如果这个电路可编程，再加上输入输出接口，那就是一个CPU了。至于是半导体和二进制之间孰先孰后呢，你可以做进一步的研究（从书中来看，第一台计算机ENIAC是采用十进制的，所以看来应该是半导体在先，二进制在后）（所以今后如果计算机的物理介质有了更新，我们也许就会换一种新的编码方案了）。&lt;/p&gt;
&lt;p&gt;在书中大量讲到的门电路、继电器等等属于实现层面，大家了解一下就好。我们不是电气工程师，我们是软件工程师。当然理解硬件层面细节对于写好代码是很有帮助的。这主要解释的是一个“为什么”的问题。&lt;/p&gt;
&lt;p&gt;你了解了CPU的指令集，和CPU的工作方式，你就理解为什么我们在程序运行时需要“栈”这个数据结构。&lt;/p&gt;
&lt;p&gt;你了解了字符的编码以及浮点数的编码，你就不会奇怪于为什么&lt;code&gt;0.1+0.2&lt;/code&gt;不等于&lt;code&gt;0.3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们要关注的主要是如何用编码来抽象问题。比如用二进制来表示数据，进行运算。比如用指令来对CPU进行编程。比如&lt;/p&gt;
&lt;h3 id=&quot;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot;&gt;&lt;a href=&quot;#第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot; class=&quot;headerlink&quot; title=&quot;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot;&gt;&lt;/a&gt;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&lt;/h3&gt;&lt;p&gt;前几章就举了几个编码的例子，让你知道——编码可以用来传递信息。然后布莱叶盲文是一种二进制的编码，因为和计算机的二进制特点符合，所以被拉出来讲了。接下去几章就是铺垫一些电学基础，让你知道我们可以用开关的开和闭，来表示1和0的编码。这样后面就可以借助这个特性，拿开关和电线来组装计算机了。&lt;/p&gt;
&lt;h3 id=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;a href=&quot;#第四章：手电筒的剖析、第五章：绕过拐角的通信&quot; class=&quot;headerlink&quot; title=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;/a&gt;第四章：手电筒的剖析、第五章：绕过拐角的通信&lt;/h3&gt;&lt;p&gt;第五章里最重要的概念就是接地。大地电阻很大，但大地是导体。电子只要流动就能形成电能，电子是哪里来的？是不是一个环路？这个不重要。接地处电子往大地那里移动，电势就低。电池那边的电子就可以往接地处移动了。&lt;br&gt;有人说，那我一个电路，中间拿掉一个导线，为什么不能接通？因为空气的电阻太大了··· 电子没法移动到空气中。&lt;/p&gt;
&lt;h3 id=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;a href=&quot;#第十章：逻辑与开关与第十一章：门&quot; class=&quot;headerlink&quot; title=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;/a&gt;第十章：逻辑与开关与第十一章：门&lt;/h3&gt;&lt;p&gt;第十章首先介绍的内容是：布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数，其实在我们的《离散数学》课里就接触过。&lt;em&gt;注：如果没学过离散数学，可以买《离散数学及其应用》这本书学习，这里说到的形式逻辑主要指命题逻辑&lt;/em&gt;《离散数学》里一开始讲的逻辑，比如这种形式的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/3ad862b103437f908a58b008703464bea93a1ef2&quot; alt=&quot;命题逻辑&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道一个命题可能是真（T），也可能是假（F）。那如果我们把T和F换成1和0，然后将命题逻辑中的合取，析取，否定等关系换了一种表示形式，这就成了布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数中每个变量都是一个&lt;code&gt;{0,1}&lt;/code&gt;的集合。命题逻辑中的合取在布尔代数中用&lt;code&gt;·&lt;/code&gt;或者AND表示，而析取则用&lt;code&gt;+&lt;/code&gt;或者OR表示。否定则用表示。&lt;/p&gt;
&lt;p&gt;在第十一章中，有一个布尔表达式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(M·N·(W+T)+(F·N·(1-W))+B)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们代入每个变量之中，运用布尔代数运算符的规则，就可以计算出这布尔表达式的值是True或者是False。&lt;/p&gt;
&lt;p&gt;这就是问题的关键了，布尔代数是一个&lt;strong&gt;抽象的计算模型&lt;/strong&gt;。我们可以将现实世界的问题，抽象成布尔表达式（当然这个最终是因为我们可以用命题逻辑来表示现实世界的问题）。&lt;/p&gt;
&lt;p&gt;讲到这里，似乎和计算机没有什么关系。但最精彩的部分就在下面，我们可以&lt;strong&gt;用布尔代数设计电路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个机械开关，有开启和闭合两种状态，可以用来表示0或者1。这个是《编码》前几章大力铺垫的一个事实。既然这样，那我们就可以用两个开关的并联或者串联来表示AND和OR逻辑。更进一步，我们可以用开关和电线表示任何布尔表达式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;用布尔代数可以用某种电路来等价的表示&lt;/strong&gt;这个事实。从在19世纪50年代乔治·布尔发明布尔代数开始，一直到20世纪30年代才被信息论之父香农发现。尽管逻辑电路所需的开关和电线在19世纪都已经存在了。可见这种等价关系的革命性意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，反过来，布尔表达式也可以指导我们设计电路。事实上这个是目前所有逻辑电路设计的理论基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《数字逻辑》这门课讲布尔代数，主要是作为设计电路的一种工具。假如我们要设计电路，解决这个现实问题。这个问题被抽象成几个输入和输出。这些输入和输出是可能是0或者1。我们知道不同变量输入时对应的输出，也就是所谓的真值表。利用真值表，我们可以写出一个布尔表达式。但这个布尔表达式可以化简。我们可以用卡诺图等方式进行化简，化简的目的是简化电路。最终，化简的电路可以转化为门电路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《编码》里只是简单的介绍了布尔代数和门电路，没有深入的介绍电路的设计。这是比较明智的，因为如何设计电路不是我们要关心的话题。《数字逻辑》中在电路设计这块涉及的还有功能表到布尔表达式的转换，布尔表达式的化简等等。有兴趣的同学可以了解一下。&lt;/p&gt;
&lt;p&gt;总结一下，这两章对我们最大的启发就是：逻辑电路设计的理论基础是布尔代数。布尔代数可以用逻辑电路进行等价表示。而逻辑电路则是计算机所有硬件的基础。&lt;/p&gt;
&lt;h3 id=&quot;第十二章：二进制加法器&quot;&gt;&lt;a href=&quot;#第十二章：二进制加法器&quot; class=&quot;headerlink&quot; title=&quot;第十二章：二进制加法器&quot;&gt;&lt;/a&gt;第十二章：二进制加法器&lt;/h3&gt;&lt;p&gt;这章一开始说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们可以造出加法器，同样地，就可以利用加法来实现减法、乘法和除法，计算按揭付款，引导火箭飞到火星、下棋，以及填写我们的话费账单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家可能觉得这是夸张的说法，但其实加法器的确就是CPU中最重要的部分。实现了加法器，再加上存储系统，和控制器，就是一个基本的计算机了。&lt;/p&gt;
&lt;p&gt;所以这章内容可以说是《编码》这本书介绍的如何制造一台计算机中的第一次飞跃（第二次飞跃是第十七章，自动操作）。&lt;/p&gt;
&lt;p&gt;说的很神奇，其实加法器就是由简单的门电路构成的一个电路而已。&lt;/p&gt;
&lt;p&gt;我们已经知道了各种门电路的输入输出，那问题就是，如何来利用门电路，设计一个相对复杂的电路呢？&lt;/p&gt;
&lt;p&gt;这部分的知识对应的是大学中的《数字逻辑》课程。电路的设计有一套成熟的方法，当然我们先不考虑那么多，先来看看《编码》的作者是如何设计这个加法器电路的。&lt;/p&gt;
&lt;p&gt;对于一个电路，我们&lt;strong&gt;首先&lt;/strong&gt;要确定输入和输出，并写出一个真值表。&lt;/p&gt;
&lt;p&gt;我们进行二进制数的相加时，会分别相加两个二进制数的每一位，如果有进位，则将进位加入下一位二进制数的相加中。&lt;/p&gt;
&lt;p&gt;这样，我们就可以将两个二进制数的加法，转化为多次的一位二进制数加法。一位二进制数加法的输入是两个个加数。输出是一位的二进制数，以及一个进位数。比如输入是1加1，输出结果是0，进位位是1。&lt;/p&gt;
&lt;p&gt;现在我们就可以列出两个真值表，一个是加法的真值表，一个是进位的真值表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;+加法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;+进位&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;好了，现在我们可以进入第二步，根据真值表，设计电路。&lt;/p&gt;
&lt;p&gt;我们要设计这样一个电路，输入A和B，都是一位二进制数，输出结果C和进位数D，也是都是一位二进制数。&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;观察真值表的输入和输出&lt;/strong&gt;，发现进位表的真值和与门是一样的。而加法表的真值和异或门是一样的。&lt;/p&gt;
&lt;p&gt;P141页的半加器，就是简单地将一个异或门和一个与门连到相同的输入端。异或门输出的就是加法结果，与门输出的则是进位的结果。&lt;/p&gt;
&lt;p&gt;为什么这个叫半加器呢，因为这个半加器还无法完成真正的加法，因为它的输入中没有考虑进位。真正的一位加法器，输入有两个加数，以及进位位，输出结果和进位位。&lt;/p&gt;
&lt;p&gt;P142页顶部的图就是全加器。它的原理就是级联两个半加器，将第一个半加器的结果和输入的进位位相加，对于两个半加器输出的进位位，则用一个或门来处理。或门在这里其实也是起一个加法器的作用，只不过两个级联的半加器的进位输出不会同时为1&lt;em&gt;（如果前一个半加器产生进位，那结果必然是0，那后一个半加器就不可能产生进位了）&lt;/em&gt;，因此不用考虑输入都为1的情况。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P144页&lt;/em&gt;底部的图，讲8个全加器连接起来，前一个全加器的进位位输出是后一个全加器的进位位输入，第一个全加器的进位输入是0。这样我们就得到了一个8位加法器。&lt;/p&gt;
&lt;p&gt;这个加法器用开关的开和闭表示1或者0的输入，用灯泡的亮和灭表示1或者0的输出。这种方式很原始，但从原理上来说和现代的晶体管电路和LED显示器没有太大的不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种加法器有一个问题，也就是书中P146页讲到的，在时间上必须串行工作，即后一个全机器要等前一个完成运算之后才能进行运算，而不是并行的工作。解决这个问题，可以用前置进位等方法来提高运算的速度。这个会在《数字逻辑》课中讲到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们要知道的一点是，这里的电路是比较naive的。因此作者可以一眼看穿真值表对应的电路。而实际中电子工程师设计的电路是非常复杂的。用专门的方法和设计语言。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《数字逻辑》课程中，有一套非常sophisticated的设计电路的方法。从真值表中得出布尔代数表达式，用卡诺图等工具对这个表达式化简，最后用基本的门电路来实现。我们作为软件工程师，对这套方法有着基本的掌握就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这章的意义重大。我们用19世纪就被发明出来的电子器件，开关，灯泡和继电器，搭建了一个加法器。这可是一个能做&lt;strong&gt;加法&lt;/strong&gt;的机器，这意味着我们可以用机器来做&lt;strong&gt;通用计算&lt;/strong&gt;，而不是之前设计的只能帮你选择猫咪的死板电路（当然我觉得那个电路也很神奇），这在构建可编程计算机的道路上无疑是一个里程碑。&lt;/p&gt;
&lt;p&gt;回首这个过程，最重要的理论上的突破，无疑是布尔代数的发明，以及香农将代数和电路对应起来，用电路实现布尔代数的发现。&lt;/p&gt;
&lt;h3 id=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;a href=&quot;#第十八章：从算盘到芯片&quot; class=&quot;headerlink&quot; title=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;/a&gt;第十八章：从算盘到芯片&lt;/h3&gt;&lt;h3 id=&quot;第二十五章：图形化革命&quot;&gt;&lt;a href=&quot;#第二十五章：图形化革命&quot; class=&quot;headerlink&quot; title=&quot;第二十五章：图形化革命&quot;&gt;&lt;/a&gt;第二十五章：图形化革命&lt;/h3&gt;&lt;p&gt;这章与其说是在讲图形化革命，不如说是PC多媒体方向的发展史。&lt;/p&gt;
&lt;h4 id=&quot;从电传打字机到视频显示器&quot;&gt;&lt;a href=&quot;#从电传打字机到视频显示器&quot; class=&quot;headerlink&quot; title=&quot;从电传打字机到视频显示器&quot;&gt;&lt;/a&gt;从电传打字机到视频显示器&lt;/h4&gt;&lt;p&gt;当然首先提到的还是图形化革命。这里有一个很重要的概念就是人机交互界面（GUI）。在打孔机时代，人机交互的实现主要是，通过纸带或者各种开关进行输入，然后经过计算机批处理之后输出。这个输入-处理-输出的循环，就是一个人机交互的过程。&lt;/p&gt;
&lt;p&gt;20世纪60年代，流行的时分操作系统，输入和输出设备是打字机。这就比较接近于现代计算机的交互了。&lt;/p&gt;
&lt;p&gt;早期的显示器，其实就是“玻璃屏幕电传打字机”。这样的显示设备仅仅只能一行一行的输出字符，和打字机没有太大区别。想要显示图形，那就只能使用ASCII Art了。这种类似打字机的界面，比较接近于我们现在使用的终端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言的标准I/O里的输出函数为什么叫&lt;code&gt;print&lt;/code&gt;呢？这就和当年的输出设备是打字机有关系了。在当时看来，这个函数就是在纸上打印字符，所以叫&lt;code&gt;print&lt;/code&gt;是很贴切的。&lt;br&gt;Linux中的一些命令，也和早期计算机的输入输出有关。比如早期计算机使用磁带作为存储设备。大家有兴趣的可以了解一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下去就是一个关键的分界线了。首先，我们要知道显示设备的原理。光栅显示器的原理就是，用一个像素点矩阵来组成图像。比如分辨率是1920*1080，那就意味着你看到的图像由2073600个像素点组成。&lt;/p&gt;
&lt;p&gt;我们知道红、绿、蓝。三原色可以混合出所有的颜色。那我们就可以通过某种编码来表示显示器像素的颜色。&lt;br&gt;做客户端的同学，会知道代码中有很多表示颜色的方法，比如&lt;code&gt;rgb(255,255,255)&lt;/code&gt;或者&lt;code&gt;#FFFFFF&lt;/code&gt;。这两种其实是一样的。都是用分别用8位二进制数来表示红、绿、蓝三原色的深度。范围是0-255，数值越大，表示这种颜色越深。&lt;/p&gt;
&lt;p&gt;这种编码叫256色，可以表示256的三次方种颜色。这样的显示器已经足够一般人使用了。&lt;/p&gt;
&lt;p&gt;那我们就可以用三个字节来表示一个像素点的颜色。给每个像素点都写入颜色信息，那显示器就可以用这个信息来绘制图像。&lt;/p&gt;
&lt;p&gt;问题就来了，这些信息要放在哪呢（一个1920*1080的矩阵，每个项目占三个字节）。最自然的当然是放在内存中，但内存和显卡直接的通信成本比较高，因此我们可以在显卡上设置一个专用的存储器，也就是我们常说的显存。显存主要的作用就是存放图像渲染的信息。&lt;/p&gt;
&lt;h4 id=&quot;施乐和Mac&quot;&gt;&lt;a href=&quot;#施乐和Mac&quot; class=&quot;headerlink&quot; title=&quot;施乐和Mac&quot;&gt;&lt;/a&gt;施乐和Mac&lt;/h4&gt;&lt;h4 id=&quot;OOP和图形界面&quot;&gt;&lt;a href=&quot;#OOP和图形界面&quot; class=&quot;headerlink&quot; title=&quot;OOP和图形界面&quot;&gt;&lt;/a&gt;OOP和图形界面&lt;/h4&gt;&lt;h4 id=&quot;图像格式与压缩算法&quot;&gt;&lt;a href=&quot;#图像格式与压缩算法&quot; class=&quot;headerlink&quot; title=&quot;图像格式与压缩算法&quot;&gt;&lt;/a&gt;图像格式与压缩算法&lt;/h4&gt;&lt;h4 id=&quot;模拟-数字转换和多媒体&quot;&gt;&lt;a href=&quot;#模拟-数字转换和多媒体&quot; class=&quot;headerlink&quot; title=&quot;模拟/数字转换和多媒体&quot;&gt;&lt;/a&gt;模拟/数字转换和多媒体&lt;/h4&gt;&lt;h4 id=&quot;互联网&quot;&gt;&lt;a href=&quot;#互联网&quot; class=&quot;headerlink&quot; title=&quot;互联网&quot;&gt;&lt;/a&gt;互联网&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 JSConf China见闻</title>
    <link href="http://yoursite.com/2016/09/07/jsconf2016/"/>
    <id>http://yoursite.com/2016/09/07/jsconf2016/</id>
    <published>2016-09-07T03:29:53.000Z</published>
    <updated>2016-09-07T06:48:26.000Z</updated>
    
    <content type="html">&lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;然而最终的结果只能说是差强人意。真正有干货的主要是Ben Lesh的&lt;a href=&quot;&quot;&gt;RxJS&lt;/a&gt;以及James Kyle的&lt;a href=&quot;&quot;&gt;How to build a complier&lt;/a&gt;，然而恰恰因为他们都是比较活跃的工程师，所以他们这两个演讲我都在youtube上看过了。至于Vue，并没有讲很多的干货，主要还是来圈粉的。&lt;/p&gt;
&lt;p&gt;其他的talk里面，PM2作者的分享还是非常solid的，他当场开源了&lt;a href=&quot;&quot;&gt;grid control&lt;/a&gt;这个项目。朴灵的分享尽管主要是打广告，但是还是要我知道了Node性能调优里内存泄露、CPU占用和GC频繁三个方向。&lt;/p&gt;
&lt;p&gt;WebVR和3D这些，说实话只能做到Demo级别的分享。这也是免不了的，外行只能看热闹。主要是给大家演示一下，如果能有启发就再好不过了。&lt;/p&gt;
&lt;p&gt;不过这次大会上我的确看到了很多微博上关注的圈内人，等以后我在圈子里混熟了，水平更好了。那也许可以来参会和大家聊聊。&lt;/p&gt;
&lt;p&gt;其实FEDay的质量明显要更高一些，尽管有翻译英文演讲这种笑话，但是干货明显更多，整体的技术气氛也更好一些。&lt;/p&gt;
&lt;p&gt;总之，对于国内的技术大会，今后还是要慎重的选择。不然还不如在家看youtube上大神的分享呢。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Regular Devtools开发手记</title>
    <link href="http://yoursite.com/2016/07/28/regular-devtools-thought/"/>
    <id>http://yoursite.com/2016/07/28/regular-devtools-thought/</id>
    <published>2016-07-28T07:52:00.000Z</published>
    <updated>2016-08-01T11:00:19.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Chrome-Extension组成&quot;&gt;&lt;a href=&quot;#Chrome-Extension组成&quot; class=&quot;headerlink&quot; title=&quot;Chrome Extension组成&quot;&gt;&lt;/a&gt;Chrome Extension组成&lt;/h3&gt;&lt;p&gt;其实前端开发者们熟悉的Chrome Devtools是用Web技术开发的。验证的方法很简单，如果你把Chrome Devtools设置为单独窗口，然而再按下打开Chrome Devtools的快捷键的话（&lt;code&gt;Control+Shift+I&lt;/code&gt;），你可以开启一个’meta inspecting’，也就是打开第二个开发者工具来检查第一个开发者工具的DOM元素。当然了，如果你熟悉Chrome Devtools团队的一些知名开发者，比如&lt;a href=&quot;https://github.com/addyosmani&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Addy Osmani&lt;/a&gt;和&lt;a href=&quot;https://github.com/paulirish&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paul Irish&lt;/a&gt;的话，你可能对Chrome Devtools是用Web技术开发的这个事实习以为常。正如V8并不是完全的C++实现，有一部分API是JavaScript实现，Chrome的界面也不都是原生的，Hybrid无处不在。&lt;/p&gt;
&lt;p&gt;好了，下面我们来说说Chrome Extension。Chrome Extension其实就是使用Web技术来开发的，只不过和一般的页面不同的是，Chrome Extension的执行环境可以访问到一系列的&lt;code&gt;chrome.*&lt;/code&gt;API。比如用&lt;code&gt;chrome.tabs&lt;/code&gt;API来打开新tab，或者监听和tab有关的一系列事件。完整的API文档在&lt;a href=&quot;https://developer.chrome.com/extensions/api_index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Chrome Extension一般由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI page&lt;/li&gt;
&lt;li&gt;Content Script&lt;/li&gt;
&lt;li&gt;Background Script&lt;/li&gt;
&lt;li&gt;Devtools Panel page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓UI page，就是用户点击导航栏中Extension的图标之后出现的弹出框。这个框是一个HTML页面，包含了Extension的UI逻辑。&lt;/p&gt;
&lt;p&gt;如果你的Extension想要访问当前用户页面的DOM结构，那你必须使用Content Script。Content Script的特点就是，它可以访问当前用户页面的DOM结构，但除此之外，当前用户页面上的&lt;code&gt;window&lt;/code&gt;对象等全局变量以及JavaScript脚本运行后产生的变量都无法访问。Content Script是运行在沙盒中的，它只被允许访问页面的DOM结构。不过Content Script作为Extension的一部分，可以和Background Script通信。&lt;/p&gt;
&lt;p&gt;如果我们把一个Chrome Extension看成一个Web应用，Content Script和UI page可以一起被当做Extension这个应用的View层。&lt;/p&gt;
&lt;p&gt;Background Script，正如名字所示，是Extension运行在后台的一个脚本。这个脚本可以和Content Script通信。&lt;/p&gt;
&lt;p&gt;如果你开发的是一款Chrome Devtools Extension，类似Regular Devtools，那你就需要Devtools Panel page了。这个页面负责在Chrome Devtools里新建tab，并且展示tab中的UI。&lt;/p&gt;
&lt;h3 id=&quot;Regular-Devtools的组成&quot;&gt;&lt;a href=&quot;#Regular-Devtools的组成&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的组成&quot;&gt;&lt;/a&gt;Regular Devtools的组成&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202016-07-29%20at%202.28.44%20PM.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;p&gt;Regular Devtools的组成和普通Extension不同之处在于没有UI page，取而代之的是Devtools Panel page。这其实没有太大的区别。只不过UI部分由Devtools Panel page来展现而不是UI page。&lt;/p&gt;
&lt;p&gt;上图是Regular Devtools的大致结构。其中Content Script和Background Script两部分构成Model层，负责数据的搜集和处理。Devtools Panel page则是UI层，负责展现数据。下面我们来讲讲具体的实现。&lt;/p&gt;
&lt;h3 id=&quot;获取Regular组件实例&quot;&gt;&lt;a href=&quot;#获取Regular组件实例&quot; class=&quot;headerlink&quot; title=&quot;获取Regular组件实例&quot;&gt;&lt;/a&gt;获取Regular组件实例&lt;/h3&gt;&lt;p&gt;首先我们需要获得Regular组件实例。这一步的实现思路大致就是在页面中注入一个Event Emitter（在页面所有脚本运行之前），并挂载在全局的&lt;code&gt;window&lt;/code&gt;对象上。然后每一个Regular组件的初始化、更新、销毁等生命周期事件发生时都会在Event Emitter上emit相应的事件，并传入实例。这样我们就可以获取到页面中所有的Regualr组件实例以及相应的其他信息了。&lt;/p&gt;
&lt;p&gt;这个Event Emitter的实现可以参考&lt;/p&gt;
&lt;h3 id=&quot;inject大法&quot;&gt;&lt;a href=&quot;#inject大法&quot; class=&quot;headerlink&quot; title=&quot;inject大法&quot;&gt;&lt;/a&gt;&lt;code&gt;inject&lt;/code&gt;大法&lt;/h3&gt;&lt;p&gt;说起来很简单，可以刚才讲到Content Script时我们说到过，它无法访问用户页面上的全局变量，因此Content Script无法访问到用户页面的&lt;code&gt;window&lt;/code&gt;对象，那我们要如何获取挂载在&lt;code&gt;window&lt;/code&gt;对象上的Regualr组件实例数组呢？&lt;/p&gt;
&lt;p&gt;解决办法很简单，Content Script可以访问用户页面的DOM结构，那我们插入一个&lt;code&gt;script&lt;/code&gt;标签就可以在用户页面的context下执行脚本了。&lt;/p&gt;
&lt;p&gt;比如我们可以实现这样一个&lt;code&gt;inject&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function inject(content) {
    var script = document.createElement(&amp;#39;script&amp;#39;)
    script.textContent = &amp;#39;;(&amp;#39; + content.toString() + &amp;#39;)(window)&amp;#39;
    document.documentElement.appendChild(script)
    script.parentNode.removeChild(script)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;跨页面通信&quot;&gt;&lt;a href=&quot;#跨页面通信&quot; class=&quot;headerlink&quot; title=&quot;跨页面通信&quot;&gt;&lt;/a&gt;跨页面通信&lt;/h3&gt;&lt;p&gt;好了，现在我们在页面中注入的脚本已经获取了当前页面下的Regular的实例，并且在Regular的组件发生更新和销毁事件时，Event Emitter都会收到消息。&lt;/p&gt;
&lt;p&gt;大家可以再看一下上面的架构图，页面中的消息要通过Background Script，再由background script发送到devtools page，展现给用户。那我们要如何进行跨页面通信呢。&lt;/p&gt;
&lt;p&gt;首先一个问题就是，如何将消息从用户页面传送到Content Script，刚才强调了，Content Script是运行在沙盒中的，无法直接访问用户页面中的变量。&lt;/p&gt;
&lt;p&gt;不过，幸运的是，&lt;code&gt;window.postMessage()&lt;/code&gt;方法可以解决这个问题。如果你将&lt;code&gt;.postMessage&lt;/code&gt;方法的&lt;code&gt;targetOrigin&lt;/code&gt;参数设置为&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;，那Content Script就会收到这个消息！&lt;/p&gt;
&lt;p&gt;Content Script与Background Script之间的通信可以使用Chrome Extension提供的API&lt;code&gt;chrome.runtime.connect&lt;/code&gt;和&lt;code&gt;chrome.runtime.sendMessage&lt;/code&gt;进行。Background Script与Devtools Page的通信同理。&lt;/p&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h3&gt;&lt;p&gt;Devtools Page中呈现的UI使用了Regular来打造，这些组件根据页面中传来的消息（数据）而呈现不同的状态。&lt;/p&gt;
&lt;p&gt;要想改善UI组件的性能，首先要减少操作DOM节点的频率，也就是减少组件渲染的次数。&lt;/p&gt;
&lt;p&gt;为此，在注入页面的脚本中，我加入了一个&lt;code&gt;debounce&lt;/code&gt;函数，相信大家都不陌生。实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// debounce helper
    var debounce = function(func, wait, immediate) {
        var timeout; //Why is this set to nothing?
        return function() {
            var context = this,
                args = arguments;
            clearTimeout(timeout); // If timeout was just set to nothing, what can be cleared? 
            timeout = setTimeout(function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            }, wait);
            if (immediate &amp;amp;&amp;amp; !timeout) func.apply(context, args); //This applies the original function to the context and to these arguments?
        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数的作用就是将一段时间内发生的多个事件转化为最后一个，起一个缓冲的作用。&lt;/p&gt;
&lt;p&gt;在用户操作Regular组件的过程中，会频繁的发生组件的初始化，销毁，状态更新等事件。一次操作往往能同时触发多个事件。如果我们不进行debounce，那么Devtools UI会频繁的收到消息，造成短时间内的反复渲染，造成页面的卡顿。&lt;/p&gt;
&lt;p&gt;其实用户的一次操作之后，我们只要在Devtools中渲染其最后一次组件状态更新后的组件状态就可以了。所以加入debounce可以明显改善UI的性能。&lt;/p&gt;
&lt;p&gt;Regular Devtools比较特殊的一点，在于页面间消息传递的是JSON数据，因此每一次UI的状态都是全量替换的。如果我直接全量替换所有UI组件的状态，所有组件都会被重新创建，那性能可想而知是很不理想的。&lt;/p&gt;
&lt;p&gt;而且Regular Devtools的UI组件中除了从用户页面中传来的状态，还有UI组件的本地状态，如果直接全量替换一部分状态，那所有组件都会被重新创建，UI组件的本地状态就无法保留下来了。&lt;/p&gt;
&lt;p&gt;对此我的做法是，对老状态对象和新状态对象进行diff，如果部分状态没有改变，则保留其引用。如果状态改变了，是原始值，则直接替换，如果是对象，则递归diff。这样的结果就是，只更新新老状态中不一样的部分，保留相同的部分。&lt;/p&gt;
&lt;p&gt;这样一来，Devtools的UI中只更新状态变化部分对应的UI，不变的部分则保留原样（因为组件状态的引用没有变）。页面上组件再多也不卡了。&lt;/p&gt;
&lt;h3 id=&quot;来自Chrome-Devtools的黑魔法&quot;&gt;&lt;a href=&quot;#来自Chrome-Devtools的黑魔法&quot; class=&quot;headerlink&quot; title=&quot;来自Chrome Devtools的黑魔法&quot;&gt;&lt;/a&gt;来自Chrome Devtools的黑魔法&lt;/h3&gt;&lt;p&gt;Regular Devtools有一个功能，即DOM节点和Regular组件的双向查找。这个是通过Chrome Console CLI的一个API&lt;code&gt;inspect()&lt;/code&gt;实现的。&lt;/p&gt;
&lt;p&gt;原理很简单，向&lt;code&gt;inspect()&lt;/code&gt;中传入DOM节点，Chrome就会检查那个节点。&lt;/p&gt;
&lt;p&gt;至于检查DOM节点反查Regular组件，则也是通过Chrome Console CLI的&lt;code&gt;$0&lt;/code&gt;变量实现的。Console中的&lt;code&gt;$0&lt;/code&gt;变量指向的是最近检查过的DOM节点。拿到这个DOM节点之后，查找它属于哪个Regular组件便可以了。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;Devtools可以提高我们的开发效率，实在是一个很酷的工具。Regular Devtools目前还只有基本的功能。如果你有更好的想法，欢迎参与到Regular Devtools的开发中来！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>发布Regular Developer Tools</title>
    <link href="http://yoursite.com/2016/07/26/annoucing-regular-devtools/"/>
    <id>http://yoursite.com/2016/07/26/annoucing-regular-devtools/</id>
    <published>2016-07-26T10:20:33.000Z</published>
    <updated>2016-07-29T03:04:04.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;a href=&quot;#为什么我们需要开发者工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;/a&gt;为什么我们需要开发者工具？&lt;/h3&gt;&lt;p&gt;现在五花八门的开源前端工具里面，有一些致力于解决前端不够工程化的问题，比如Webpack、Gulp、PostCSS。有些则致力于加强编程语言的特性，比如Babel。而有一部分工具则是为了提高开发者的体验，比如React Devtools、React Hotloader和Redux Devtools。提高开发者体验的工具，从某种角度来说，其实和其他直接参与到前端开发工作流中的工具一样，最终都是为了提高生产力。&lt;/p&gt;
&lt;p&gt;React Devtools已经足够惊艳，而Redux Devtools带来的Time-travel Debugging和React Hotloader的热更新则让人直呼这是黑魔法。&lt;/p&gt;
&lt;p&gt;所以，被这些开发者工具惯坏的我们，怎么能接受Regular没有Devtools的现实呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Regular-Devtools初印象&quot;&gt;&lt;a href=&quot;#Regular-Devtools初印象&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools初印象&quot;&gt;&lt;/a&gt;Regular Devtools初印象&lt;/h3&gt;&lt;p&gt;Regular Devtools是一款Chrome拓展。主要的功能是展示组件树，以及查看每个组件的数据。开发者对组件的操作，造成组件树和数据的变化，都会在Devtools中实时展现。&lt;/p&gt;
&lt;p&gt;比如这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/rdt_demo_ss.gif&quot; alt=&quot;rdt_demo&quot;&gt;&lt;/p&gt;
&lt;p&gt;更强大的是，你可以检查当前组件对应的DOM节点，这个节点会在Chrome Devtools中的Element Tab中出现，就像你平时习惯的右键inspect一样。&lt;/p&gt;
&lt;p&gt;反之，如果你正在检查一个DOM元素，此时你可以切换到Regular Tab，Regular DevTools会自动选中那个DOM节点对应的Regular组件（如果那个DOM节点是Regular组件渲染出的）。&lt;/p&gt;
&lt;p&gt;比如这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/rdt_demo_dom_ss.gif&quot; alt=&quot;rdt_demo&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;p&gt;对Regular Devtools有了初步印象之后，下面就详细介绍一下它的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左侧Element View显示当前页面的Regular组件树，右侧State View显示被选中组件的状态。&lt;/li&gt;
&lt;li&gt;Element View和State View都会随着页面上组件和状态的变化实时更新。&lt;/li&gt;
&lt;li&gt;提供DOM节点和Regular组件的双向查找：可以点击State View中的Inspect查找当前Regular组件对应的DOM节点。&lt;/li&gt;
&lt;li&gt;也可以在Element选项卡中选中DOM节点后切换到Regular选项卡，如果被选中的DOM节点由Regular组件渲染，那么这个Regular节点会被自动选中。&lt;/li&gt;
&lt;li&gt;页面刷新时Devtools会自动重新加载，你也可以通过顶栏右侧的按钮手动重载。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;include&lt;/code&gt;方式被引入的组件将会在组件树中注明，并且在组件树种作为视觉父节点&lt;code&gt;this.$outer&lt;/code&gt;子节点展示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;读到这里，想必你一定蠢蠢欲动了，那就快来体验一下Regular DevTools吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 克隆Regular Devtools&lt;a href=&quot;https://regularjs.github.io/regular-devtools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 打开Chorme的&lt;code&gt;chrome://extensions/&lt;/code&gt;页面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 点击&lt;code&gt;Load unpacked extension···&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 4&lt;/strong&gt; 选择你刚刚克隆的仓库文件夹&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 大功告成!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开一个使用了Regular组件的页面，打开Chrome Devtools，选择Regular选项卡，如果一切顺利，你将在左边的Element View看到当前页面的组件树，然后就可以开始愉快的开发了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，你的项目必须使用&lt;a href=&quot;https://regularjs.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular v0.4.5&lt;/a&gt;或更高的版本&lt;br&gt;如果你手头上没有使用最新版Regular的项目，可以先拿这个&lt;a href=&quot;https://regularjs.github.io/regular-devtools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular Todo例子&lt;/a&gt;尝鲜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开发手记&quot;&gt;&lt;a href=&quot;#开发手记&quot; class=&quot;headerlink&quot; title=&quot;开发手记&quot;&gt;&lt;/a&gt;开发手记&lt;/h3&gt;&lt;p&gt;对这款Devtools的技术实现有兴趣的同学可以浏览&lt;a href=&quot;http://zxc0328.github.io/2016/07/28/regular-devtools-thought/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular Devtools开发手记&lt;/a&gt;这篇博客。&lt;/p&gt;
&lt;h3 id=&quot;已知的问题&quot;&gt;&lt;a href=&quot;#已知的问题&quot; class=&quot;headerlink&quot; title=&quot;已知的问题&quot;&gt;&lt;/a&gt;已知的问题&lt;/h3&gt;&lt;p&gt;这些问题主要是由于某些特殊组件&lt;code&gt;$outer&lt;/code&gt;属性的指向和正常组件不同造成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有&lt;code&gt;isolate&lt;/code&gt;属性的组件将不会出现在组件树中，其内嵌组件会正常显示。&lt;/li&gt;
&lt;li&gt;Regular-dnd中的&lt;code&gt;Draggable&lt;/code&gt;和&lt;code&gt;Droppable&lt;/code&gt;组件的内嵌组件会和父组件显示在同一个层级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;关于我&quot;&gt;&lt;a href=&quot;#关于我&quot; class=&quot;headerlink&quot; title=&quot;关于我&quot;&gt;&lt;/a&gt;关于我&lt;/h3&gt;&lt;p&gt;网易有数前端实习生&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;a href=&quot;#为什么我们需要开发者工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;/a&gt;为什么我们需要开发者工具？&lt;/h3&gt;&lt;p&gt;现在五花八门的开源前端工具里面，有一些致力于解决前端不够工程化的问题，比如Webpack、Gulp、PostCSS。有些则致力于加强编程语言的特性，比如Babel。而有一部分工具则是为了提高开发者的体验，比如React Devtools、React Hotloader和Redux Devtools。提高开发者体验的工具，从某种角度来说，其实和其他直接参与到前端开发工作流中的工具一样，最终都是为了提高生产力。&lt;/p&gt;
&lt;p&gt;React Devtools已经足够惊艳，而Redux Devtools带来的Time-travel Debugging和React Hotloader的热更新则让人直呼这是黑魔法。&lt;/p&gt;
&lt;p&gt;所以，被这些开发者工具惯坏的我们，怎么能接受Regular没有Devtools的现实呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ninja:dev server made easy</title>
    <link href="http://yoursite.com/2016/07/05/ninja/"/>
    <id>http://yoursite.com/2016/07/05/ninja/</id>
    <published>2016-07-05T12:32:43.000Z</published>
    <updated>2016-07-14T08:16:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Muxi-Studio/ninja&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ninja&lt;/a&gt;是一款用于前后端分离开发的本地开发服务器，也被称为是前端容器。它有以下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML、CSS的热重载&lt;/li&gt;
&lt;li&gt;根据配置文件自动生成路由&lt;/li&gt;
&lt;li&gt;根据配置文件自动读取在线/本地的虚拟数据&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Jinja2&lt;/code&gt;语法（以及其他Nodejs模板）&lt;/li&gt;
&lt;li&gt;支持路由代理&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;webpack&lt;/code&gt;（通过&lt;code&gt;webpack-dev-middleware&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Ninja的前世今生&quot;&gt;&lt;a href=&quot;#Ninja的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Ninja的前世今生&quot;&gt;&lt;/a&gt;Ninja的前世今生&lt;/h3&gt;&lt;p&gt;在木犀，之前我们的前后端分离开发方案是这样的：在本地运行一个简单的&lt;code&gt;Flask&lt;/code&gt;应用，只包含路由，在路由中读取虚拟数据并渲染&lt;code&gt;Jinja2&lt;/code&gt;模板，然后运行这个应用，进行开发。前端模板开发完成后和后端直接对接调试。&lt;/p&gt;
&lt;p&gt;这种方案有一些明显的问题，首先是这个&lt;code&gt;Flask&lt;/code&gt;应用没法规范化为一个命令或是一个包，这就需要我们每次在构建前端仓库时都手动写路由等逻辑，这显然是不现实的。还有一个问题就是，&lt;code&gt;Flask&lt;/code&gt;的Python环境与目前前端工具生态的主流Nodejs格格不入，想要接入&lt;code&gt;webpack&lt;/code&gt;等前端工具，我们必须使用Nodejs来构建我们的dev server。&lt;/p&gt;
&lt;p&gt;于是我们需要一款能支持&lt;code&gt;Jinja2&lt;/code&gt;语法，同时又能满足前端开发各种需要的dev server。Ninja就在这个节点上横空出世了！&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;Ninja的上手非常简单，首先安装Ninja&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g ninja_cli
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面以Ninja和Webpack一起使用为例，这个例子的源代码在Ninja仓库的&lt;a href=&quot;https://github.com/Muxi-Studio/ninja/tree/master/example/ninja_webpack_example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;example文件夹&lt;/code&gt;&lt;/a&gt;下可以找到。&lt;/p&gt;
&lt;p&gt;首先我们需要一个&lt;code&gt;ninja.conf.js&lt;/code&gt;配置文件，当然你也可以选择用命令行参数配置。在这个文件里我们要配置一些必要的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    template: &amp;quot;swig&amp;quot;, // 模板引擎名
    mock: &amp;quot;/mock/mock.json&amp;quot;, // 虚拟数据位置
    webpack: true, // 启用webpack支持
    templateDir: &amp;quot;/template&amp;quot;, // 模板文件目录
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在webpack的配置里要注意&lt;code&gt;entry&lt;/code&gt;和&lt;code&gt;output&lt;/code&gt;的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  entry: [
    path.resolve(__dirname, &amp;#39;./index.js&amp;#39;)
  ],
  output: {
    path: &amp;#39;/&amp;#39;,
    publicPath: &amp;#39;http://localhost:3000/&amp;#39;,
    filename: &amp;#39;bundle.js&amp;#39;
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;webpack的中间件提供静态文件，我们可以在Ninja的3000端口访问到，所以在模板中的静态文件路径可以写&lt;code&gt;/&lt;/code&gt;+文件名。如&lt;code&gt;&amp;lt;script src=&amp;quot;/bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置好Webpack之后，我们写两个简单的模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// base.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Ninja Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;I&amp;#39;m the head&amp;lt;/h2&amp;gt;
    {% block content %}{% endblock %}
	&lt;a href=&quot;/&quot;&gt;index page&lt;/a&gt;
	&lt;a href=&quot;/second&quot;&gt;second page&lt;/a&gt;
	&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;



// second.html
{% extends &#39;base.html&#39; %}
{% block content %}
	&lt;p&gt;{{ title }}&lt;/p&gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后写一个mock文件&lt;code&gt;/mock/mock.json&lt;/code&gt;，配置路由和虚拟数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;routes&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/&amp;quot;,
            &amp;quot;template&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;async&amp;quot;: false // 同步路由
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;second&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/second&amp;quot;,
            &amp;quot;template&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;async&amp;quot;: false
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;api.courses&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/api/v1.0/courses&amp;quot;,
            &amp;quot;async&amp;quot;: true // 异步路由（API）
        }
    ],
    &amp;quot;data&amp;quot;:{
        &amp;quot;home&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;hello&amp;quot;
        },
        &amp;quot;second&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;second&amp;quot;
        },
        &amp;quot;api.courses&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;second&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后启动Ninja&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ninja
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后Ninja会自动用Chrome打开&lt;code&gt;http://localhost:3000/&lt;/code&gt;。并显示我们首页模板。大功告成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqk8r.com1.z0.glb.clouddn.com/ninja_start.gif&quot; alt=&quot;ninja_start&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发手记&quot;&gt;&lt;a href=&quot;#开发手记&quot; class=&quot;headerlink&quot; title=&quot;开发手记&quot;&gt;&lt;/a&gt;开发手记&lt;/h3&gt;&lt;p&gt;Ninja的主体就是一个Express server，读取配置文件然后生成路由，填入虚拟数据和模板。Livereload使用了&lt;code&gt;connect-inject&lt;/code&gt;做模板的JS注入。用&lt;code&gt;socket.io&lt;/code&gt;做浏览器与Ninja的实时通信。至于Webpack的集成，直接使用官方的&lt;code&gt;webpack-dev-middleware&lt;/code&gt;和&lt;code&gt;webpack-hot-middleware&lt;/code&gt;就可以轻松达成。&lt;/p&gt;
&lt;p&gt;总体来说没有遇到太大的困难，当然也可能是因为使用了大量的三方库。&lt;code&gt;@朱承浩&lt;/code&gt;同学建议Ninja的Web server部分可以自己实现，没必要使用&lt;code&gt;Express&lt;/code&gt;。我认为JS注入应该也可以自己实现。所以后期可以将这些部分替换为自己的实现。&lt;/p&gt;
&lt;p&gt;Ninja是我第一次尝试些CLI应用，也是第一次尝试写前端工具。在功能上借鉴了&lt;a href=&quot;https://github.com/leeluolee/puer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;puer&lt;/code&gt;&lt;/a&gt;（但是没看代码，看不懂Coffee Script），在前后端分离的理念上借鉴了&lt;a href=&quot;https://github.com/NEYouFan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NEI&lt;/code&gt;&lt;/a&gt;。在这个过程中我最大的发现是Node生态圈的繁荣，基本上想要的功能都有相应的NPM包封装好了。这次用了&lt;a href=&quot;https://github.com/tj/commander&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;commander&lt;/code&gt;&lt;/a&gt;做命令行参数的文档生成，&lt;a href=&quot;https://github.com/chalk/chalk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;chalk&lt;/code&gt;&lt;/a&gt;给&lt;code&gt;console.log&lt;/code&gt;加颜色，&lt;a href=&quot;https://github.com/tj/consolidate.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;consolidate&lt;/code&gt;&lt;/a&gt;来统一Node模板调用，&lt;a href=&quot;https://github.com/sindresorhus/opn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;opn&lt;/code&gt;&lt;/a&gt;用来打开浏览器。随着我Node水平的提升，在今后的开发中，会尽量少用不必要的三方库。&lt;/p&gt;
&lt;h3 id=&quot;展望&quot;&gt;&lt;a href=&quot;#展望&quot; class=&quot;headerlink&quot; title=&quot;展望&quot;&gt;&lt;/a&gt;展望&lt;/h3&gt;&lt;p&gt;Ninja目前的版本号是&lt;code&gt;0.1&lt;/code&gt;，等稳定之后会放出&lt;code&gt;1.0&lt;/code&gt;版。后续版本会加入subcommand，加入脚手架功能，一键搭建前端目录建构和配置文件。云端Mock数据平台也要做相应的跟进。&lt;/p&gt;
&lt;p&gt;总之，Ninja是木犀前后端分离开发实践一个进步。这仅仅只是一个开始，希望大家一起努力，提高开发的效率和开发者的体验。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Muxi-Studio/ninja&quot;&gt;Ninja&lt;/a&gt;是一款用于前后端分离开发的本地开发服务器，也被称为是前端容器。它有以下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML、CSS的热重载&lt;/li&gt;
&lt;li&gt;根据配置文件自动生成路由&lt;/li&gt;
&lt;li&gt;根据配置文件自动读取在线/本地的虚拟数据&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Jinja2&lt;/code&gt;语法（以及其他Nodejs模板）&lt;/li&gt;
&lt;li&gt;支持路由代理&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;webpack&lt;/code&gt;（通过&lt;code&gt;webpack-dev-middleware&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 FEDay见闻录</title>
    <link href="http://yoursite.com/2016/03/19/2016-feday/"/>
    <id>http://yoursite.com/2016/03/19/2016-feday/</id>
    <published>2016-03-19T14:27:24.000Z</published>
    <updated>2016-03-21T08:15:41.000Z</updated>
    
    <content type="html">&lt;p&gt;这次FEDay是我第一次参加开发者大会，也是第一次去广州。当初主要是冲着两个Facebook的工程师去的，因为我对React好感度很高。总的来说这次的收获还是很多的，也算是值回票价了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Universal-Applications-by-Stephan&quot;&gt;&lt;a href=&quot;#Universal-Applications-by-Stephan&quot; class=&quot;headerlink&quot; title=&quot;Universal Applications by Stephan&quot;&gt;&lt;/a&gt;Universal Applications by Stephan&lt;/h3&gt;&lt;p&gt;首先是FB的&lt;a href=&quot;https://twitter.com/stopachka&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stephan&lt;/a&gt;分享Universal Applications。Stephan会说中文，应该是他在台湾待过一段时间的原因。这里有个小插曲就是会场安排了一名翻译，Stephan说一句翻译就翻译一下，这样真的非常的多余。本来是想来听一下原汁原味的国外工程师分享的，结果还是打了折扣。&lt;/p&gt;
&lt;p&gt;Stephan说的Universal Applications我之前在开发Readme的时候使用过一部分。就是在服务器端用react-dom的&lt;code&gt;renderToString&lt;/code&gt;方法生成字符串。同时也运行了Redux的代码，根据客户端传来的state生成了相应的UI。&lt;/p&gt;
&lt;p&gt;不过Universal Applications并没有这么简单。这种开发模式总的来说就是写一套代码，在客户端和服务端同时可用。服务端UI的渲染我们已经通过&lt;code&gt;renderToString&lt;/code&gt;解决了。服务端的路由可以通过react-router的&lt;code&gt;match&lt;/code&gt;函数来运行相应的UI组件渲染逻辑。而数据获取API的差异可以通过&lt;code&gt;isomorphic-fetch&lt;/code&gt;这个库来抹平。&lt;/p&gt;
&lt;h3 id=&quot;微信WebApp最佳实践-by-江剑锋&quot;&gt;&lt;a href=&quot;#微信WebApp最佳实践-by-江剑锋&quot; class=&quot;headerlink&quot; title=&quot;微信WebApp最佳实践 by 江剑锋&quot;&gt;&lt;/a&gt;微信WebApp最佳实践 by 江剑锋&lt;/h3&gt;&lt;p&gt;说实话我之前对微信前端的工作不是很了解。看了这个分享之后我清楚多了，微信的前端做的也就是普通前端的事情，并没有涉及前端之外的部分。这个工作有点类似于淘宝无线。不过淘宝这个App的混合程度更高一些，而微信里面的Web和原生的内容之间的分离比较明显，这和微信的特点有关系。&lt;/p&gt;
&lt;p&gt;微信主要是为Web内容搭建了一个平台，也就是微信公众号。和原生的交互主要通过JS-SDK来实现。说实话这种开发模式是在世界上很少有的，算是微信的独创。目前Web内容一般来说会以原生的App为平台，而对于众多的普通开发者来说，微信是最好的开放平台。WebApp借微信这个超级App得以迅速的传播。打造了一个生态圈。所以微信Web开发现在已经成为了小公司前端的一个日常开发内容，现场有大量做过微信Web开发的前端同学，这个平台的体量可见一斑。&lt;/p&gt;
&lt;p&gt;首先我们看了微信的一些用户数据，前十位的机型里面除了三星之外就是小米。安卓系统版本有不少。因此微信内嵌的X5内核的目的就是抹平这些系统里自带的WebView的差异。&lt;/p&gt;
&lt;p&gt;我们在开发微信WebApp的过程中会遇到一些问题，这些多数和微信内嵌的X5内核有关。比如强制缓存，不仅会缓存CSS等资源，还会缓存HTML。要避免这个问题我们可以在URL后加参数。&lt;/p&gt;
&lt;p&gt;另外还讲了一些普遍的问题，比如动画卡顿，flex部分支持。Video的&lt;code&gt;autoplay&lt;/code&gt;无效和&lt;code&gt;control&lt;/code&gt;条无法隐藏，&lt;code&gt;autoplay&lt;/code&gt;无法使用是因为产品策略，让用户有选择权。如果一定要使用则可以监听&lt;code&gt;WXJSBridgeReady&lt;/code&gt;事件。Cookie和localStorage偶尔失效这个问题我还没有遇到过，江剑锋表示客户端存储本来就是不可靠的存储，所以我们要做相应的准备。&lt;/p&gt;
&lt;p&gt;接着介绍了WeUI，以及相应的jQuery,react,vue的binding。还有微信的一些调试工具。&lt;/p&gt;
&lt;p&gt;最后放了一个消息出来，那就是微信的内核将改用Blink。这样上述的问题都将得到解决，除了&lt;code&gt;autoplay&lt;/code&gt;依然是按照原来的策略。&lt;/p&gt;
&lt;h3 id=&quot;React-Tips-by-黄士旗&quot;&gt;&lt;a href=&quot;#React-Tips-by-黄士旗&quot; class=&quot;headerlink&quot; title=&quot;React Tips by 黄士旗&quot;&gt;&lt;/a&gt;React Tips by 黄士旗&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/huang47&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;黄士旗&lt;/a&gt;是台湾人，目前在Facebook工作。他的React Tips的内容主要包括了Container Component和UI Component，HOC高阶函数，Array的函数式API等。&lt;/p&gt;
&lt;p&gt;第一次了解Container Component和UI Component这个概念是在一些React boilerplate里以及Dan Abramov的Redux教程里。Dan的&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.kv5gzrgje&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;讲了这个问题。于是我在自己的Redux项目里也把组件分为UI组件和Container组件。简单的说，UI组件是Stateless function，只负责根据传入的数据返回UI组件，具有很高的可复用性。而Container组件则是负责处理数据，具有一些业务逻辑，基本是不可复用的（也不用考虑去复用）。&lt;/p&gt;
&lt;p&gt;UI组件的类型很多，如何达到进一步的复用呢？这里黄士旗引入了HOC的概念。我们用HOC作为一个装饰器，传入的UI组件被附加一些UI元素后返回，从而实现了更好程度的复用。我们可以用一个Base UI组件加上各色装饰器来渲染不同类型的UI组件。一个装饰器大概就是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function makeEditale(baseCompoennt){
    return &amp;lt;div&amp;gt;
                &amp;lt;input /&amp;gt;
                &amp;lt;baseCompoennt /&amp;gt;
            &amp;lt;/div&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前我接触过ES7的装饰器，那就是一个class的语法糖，原理和这个是一样的。总之这里我们的原则就是Composition Over Inheritance。&lt;/p&gt;
&lt;p&gt;最后黄士旗介绍了Array的&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;API的使用。这些函数式特性的API和React就是天作之合。在各种场合都很好用。&lt;/p&gt;
&lt;h3 id=&quot;下一代Web技术运用-by-陈子舜&quot;&gt;&lt;a href=&quot;#下一代Web技术运用-by-陈子舜&quot; class=&quot;headerlink&quot; title=&quot;下一代Web技术运用 by 陈子舜&quot;&gt;&lt;/a&gt;下一代Web技术运用 by 陈子舜&lt;/h3&gt;&lt;p&gt;陈子舜是腾讯云的技术总监，他分享的内容主要是提前运用下一代Web技术来提升Web性能。&lt;/p&gt;
&lt;p&gt;在过往，前端面试中提到Web性能，我们总会提到雅虎的35条前端性能优化定律这些。而这些规则在移动端Web开发占主流和新技术出现的情况下是否还适用呢？&lt;/p&gt;
&lt;p&gt;前端性能的要求就是我们的首屏必须在1s内渲染，这点我们可以通过Offline Caching来助力。&lt;/p&gt;
&lt;p&gt;子舜举了QQ红包的例子。红包相关的代码是用Web技术写的，但是这些代码不能在需要时拉取，而是应该提前拉取并缓存在本地。这一点和Google在推的Progressive App异曲同工。Google IO的IOWA是可以离线使用的。&lt;/p&gt;
&lt;p&gt;我们看到现在的离线存储技术有很多种，比如Application Cache和Service Worker。QQ红包中的离线存储是通过Native代码实现的。这些以后可以通过Service Worker来在Web端实现。Service Worker在目前还没有被主流浏览器实现，但这会是未来的方向。&lt;/p&gt;
&lt;h3 id=&quot;前端能力的培养-by-Winter&quot;&gt;&lt;a href=&quot;#前端能力的培养-by-Winter&quot; class=&quot;headerlink&quot; title=&quot;前端能力的培养 by Winter&quot;&gt;&lt;/a&gt;前端能力的培养 by Winter&lt;/h3&gt;&lt;p&gt;Winter的那套理论我之前在看他画“前端校招重点“的时候就看到过。主要就是20%的知识加上80%的能力。&lt;/p&gt;
&lt;p&gt;在说20%的知识的时候，Winter说他看Python语法的文档来学语法。然后通过查论文来了解闭包的概念。总之就是，学知识需要看最权威的东西，追根溯源，搞清问题的本质。&lt;/p&gt;
&lt;p&gt;80%的能力分为工程能力，架构能力，编程能力。这些就是靠大量的练习来达到的。一万小时理论看起来有些恐怖，那就从每周20小时开始努力吧。就算是这样，也可以达到一个很不错的水平。&lt;/p&gt;
&lt;h3 id=&quot;HTTP-2时代的Web性能-by-Holger-Bartel&quot;&gt;&lt;a href=&quot;#HTTP-2时代的Web性能-by-Holger-Bartel&quot; class=&quot;headerlink&quot; title=&quot;HTTP/2时代的Web性能 by Holger Bartel&quot;&gt;&lt;/a&gt;HTTP/2时代的Web性能 by Holger Bartel&lt;/h3&gt;&lt;p&gt;Holger的分享还是很给力的，主要讲了HTTP/2和HTTP/1.1之间的区别，以及我们应该如何在HTTP/2中进行性能优化。以及如何在今天就开始使用HTTP/2。&lt;/p&gt;
&lt;p&gt;其中性能优化方面，在HTTP/2时代，我们不需要合并文件了，也不需要inline CSS/image以及分离资源的域名。至于雪碧图，压缩这些工序，还是需要的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次FEDay是我第一次参加开发者大会，也是第一次去广州。当初主要是冲着两个Facebook的工程师去的，因为我对React好感度很高。总的来说这次的收获还是很多的，也算是值回票价了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FEDay" scheme="http://yoursite.com/tags/FEDay/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s build a jQuery!-Part 1(early release)</title>
    <link href="http://yoursite.com/2016/03/11/let-s-build-a-jQuery/"/>
    <id>http://yoursite.com/2016/03/11/let-s-build-a-jQuery/</id>
    <published>2016-03-11T09:24:00.000Z</published>
    <updated>2016-06-15T10:56:00.000Z</updated>
    
    <content type="html">&lt;p&gt;这个系列博客的灵感来源于&lt;a href=&quot;https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;和一次失败的&lt;a href=&quot;https://github.com/zxc0328/litejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;造轮子&lt;/a&gt;经历。出于对jQuery进行源码分析和让旧日作品发挥余热的目的，我开始写这一系列博客。主要内容就是从头开始打造一个jQuery-like的基础库，并且配上相应的源码，也就是我们的Litejs。&lt;/p&gt;
&lt;p&gt;我们要做的工作有以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器和元素封装&lt;/li&gt;
&lt;li&gt;DOM操作&lt;/li&gt;
&lt;li&gt;Ajax请求&lt;/li&gt;
&lt;li&gt;事件系统&lt;/li&gt;
&lt;li&gt;触摸事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应这系列文章的四个部分。&lt;/p&gt;
&lt;p&gt;好，让我们开启这段神奇的重复造轮子之旅吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;开发环境的搭建&quot;&gt;&lt;a href=&quot;#开发环境的搭建&quot; class=&quot;headerlink&quot; title=&quot;开发环境的搭建&quot;&gt;&lt;/a&gt;开发环境的搭建&lt;/h3&gt;&lt;p&gt;我们使用ES6的模块语法编写模块，并使用&lt;a href=&quot;http://rollupjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rollup.js&lt;/a&gt;打包，rollup是基于ES6模块的JS打包工具。我对于rollup的思考可以参考。除此之外我们还是用Babel和Flow。Flow是Facebook出品的JavaScript静态类型检查工具，我们用Babel来去除Flow的类型标记，以及编译其他的ES6特性代码。&lt;/p&gt;
&lt;p&gt;// todo 测试环境搭建&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout 1-1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;jQuery的组织架构&quot;&gt;&lt;a href=&quot;#jQuery的组织架构&quot; class=&quot;headerlink&quot; title=&quot;jQuery的组织架构&quot;&gt;&lt;/a&gt;jQuery的组织架构&lt;/h3&gt;&lt;p&gt;简单的说，jQueryAPI由&lt;code&gt;jQuery&lt;/code&gt;构造函数以及&lt;code&gt;jQuery&lt;/code&gt;函数上的一系列静态API组成。&lt;code&gt;jQuery&lt;/code&gt;构造函数就是我们平常使用的&lt;code&gt;$&lt;/code&gt;函数，这个函数接收选择器字符串作为参数，返回jQuery对象实例。jQuery对象封装了原生的DOM对象，为其添加了一系列的属性和方法，以及链式调用的能力。&lt;/p&gt;
&lt;p&gt;与此同时，因为JavaScript的函数也是对象，因此我们可以在函数上添加属性和方法。函数是对象，因此也可以访问对象原型的方法。&lt;code&gt;jQuery&lt;/code&gt;函数上的静态方法，包括了回调、AJAX、事件、动画、工具函数等jQuery API。另一些API，比如DOM相关的API，则是绑定在&lt;code&gt;jQuery&lt;/code&gt;构造函数实例化出来的对象上。&lt;/p&gt;
&lt;h4 id=&quot;lite构造函数&quot;&gt;&lt;a href=&quot;#lite构造函数&quot; class=&quot;headerlink&quot; title=&quot;lite构造函数&quot;&gt;&lt;/a&gt;&lt;code&gt;lite&lt;/code&gt;构造函数&lt;/h4&gt;&lt;p&gt;下面就让我们开始编写我们的自制&lt;code&gt;jQuery&lt;/code&gt;—&lt;code&gt;litejs&lt;/code&gt;。让我们来编写我们的第一个函数，&lt;code&gt;lite&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// The lite constructor function
var lite = function( selector, context ) {
  return new lite.prototype.init( selector, context );
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数很简单，调用了&lt;code&gt;lite.fn.init&lt;/code&gt;函数，传入了选择器和上下文，并返回实例化的对象。让我们来看看真正干活的&lt;code&gt;lite.prototype.init&lt;/code&gt;函数。&lt;/p&gt;
&lt;h4 id=&quot;lite-prototype-init&quot;&gt;&lt;a href=&quot;#lite-prototype-init&quot; class=&quot;headerlink&quot; title=&quot;lite.prototype.init&quot;&gt;&lt;/a&gt;&lt;code&gt;lite.prototype.init&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;我们之前说过，&lt;code&gt;lite&lt;/code&gt;构造函数也是个对象，我们把一些静态方法都放在这个对象的原型上。其中就有&lt;code&gt;init&lt;/code&gt;方法。我们先不急着看这个方法做了什么，我们在这里要做一个特殊的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lite.prototype.init.prototype = lite.prototype;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很简单，因为&lt;code&gt;lite.prototype.init&lt;/code&gt;方法返回的实例无法访问到&lt;code&gt;lite&lt;/code&gt;函数的原型链，所以我们设置这个对象构造函数的原型是&lt;code&gt;lite.prototype&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;lite-extend&quot;&gt;&lt;a href=&quot;#lite-extend&quot; class=&quot;headerlink&quot; title=&quot;lite.extend()&quot;&gt;&lt;/a&gt;&lt;code&gt;lite.extend()&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;lite.extend()&lt;/code&gt;其实就是我们常说的&lt;code&gt;mixin&lt;/code&gt;函数&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列博客的灵感来源于&lt;a href=&quot;https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html&quot;&gt;这篇博客&lt;/a&gt;和一次失败的&lt;a href=&quot;https://github.com/zxc0328/litejs&quot;&gt;造轮子&lt;/a&gt;经历。出于对jQuery进行源码分析和让旧日作品发挥余热的目的，我开始写这一系列博客。主要内容就是从头开始打造一个jQuery-like的基础库，并且配上相应的源码，也就是我们的Litejs。&lt;/p&gt;
&lt;p&gt;我们要做的工作有以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器和元素封装&lt;/li&gt;
&lt;li&gt;DOM操作&lt;/li&gt;
&lt;li&gt;Ajax请求&lt;/li&gt;
&lt;li&gt;事件系统&lt;/li&gt;
&lt;li&gt;触摸事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应这系列文章的四个部分。&lt;/p&gt;
&lt;p&gt;好，让我们开启这段神奇的重复造轮子之旅吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="jQuery JavaScript" scheme="http://yoursite.com/tags/jQuery-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题总结（持续更新）</title>
    <link href="http://yoursite.com/2016/03/11/front-end-interview/"/>
    <id>http://yoursite.com/2016/03/11/front-end-interview/</id>
    <published>2016-03-11T08:51:36.000Z</published>
    <updated>2016-04-04T08:27:39.000Z</updated>
    
    <content type="html">&lt;p&gt;接下来要参与大大小小的暑期实习笔试和面试。在这篇博客里我将总结一些常见的面试题。其中有一部分是我去年暑假找实习的时候总结的。现在看来，不免有些幼稚。慢慢完善吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;JS中的闭包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：闭包从本身在函数式编程中的概念来说，说的是在定义函数时的两部分-函数体和函数的&lt;code&gt;context&lt;/code&gt;，也就是函数定义时的上下文。里面保存着作用域中的变量，函数的定义和赋值。&lt;/p&gt;
&lt;p&gt;而我们平时说的闭包，其实是创建对于这个上下文的引用，从而在外部作用域中通过这个引用来访问这个上下文。&lt;/p&gt;
&lt;p&gt;所以从概念上来说，你声明了一个函数，就声明了一个闭包。&lt;/p&gt;
&lt;p&gt;然后从实际的使用来说，当你通过某种代码对在外部作用域中保存了对当前闭包的引用时，我们说你就“创建”了一个闭包，其实是“创建”了一个&lt;strong&gt;闭包的引用&lt;/strong&gt;。我们通常用IIFE来达到这一效果，以至于有人认为IIFE就是“闭包”，这其实是不正确的认识。&lt;/p&gt;
&lt;p&gt;这就是闭包的实质，至于如何去使用闭包，那就五花八门了。你可以用来保存被外部作用域访问的临时变量，也可以用来封装函数，也可以用来做访问权限控制（类似Java中的私有变量）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要JS模块化&lt;/li&gt;
&lt;li&gt;JS模块化的发展过程（从function，IIFE到Commonjs）&lt;/li&gt;
&lt;li&gt;JS模块化的几种方案介绍（Commonjs，AMD，ES6 Module）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS中使用new关键字构造对象实例的过程&lt;/strong&gt;&lt;br&gt;A：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject.construct = function() {
    var o = {}, Constructor = MyObject;
    o.__proto__ = Constructor.prototype;
    // FF 支持用户引用内部属性 [[Prototype]]

    Constructor.apply(o, arguments);
    return o;
};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS性能优化&lt;/strong&gt;&lt;br&gt;A： to be done&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;CSS position的不同取值以及差异？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：取值：static（默认），relative，absolute，fixed。差异，relative：相对于其自身进行定位，不脱离文档流。absolute：相对于父元素链上的第一个已定位元素，如果不存在则相对于body。脱离文档流。fixed，相对于浏览器窗口进行定位，脱离文档流。static：正常的文档流定位。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS 盒模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;W3C 默认&lt;code&gt;content-box&lt;/code&gt;，ie5-、ie6 Quirks mode &lt;code&gt;border-box&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-box&lt;/code&gt;：csswidth = content width&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-box&lt;/code&gt;: csswidth = content width + padding +border&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：元素，类，id，属性，伪类，伪元素。···&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS hack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：选择器hack（-webkit-,-moz-）,属性hack，IE条件注释&lt;/p&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;web语义化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;br&gt;html5新标签：&lt;code&gt;&amp;lt;header&amp;gt;&amp;lt;footer&amp;gt;&amp;lt;nav&amp;gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;br&gt;Microformat：标准化的css类名，方便搜索引擎对页面内容进行索引。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;Doctype&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染。html中为&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h2&gt;&lt;h2 id=&quot;前端性能&quot;&gt;&lt;a href=&quot;#前端性能&quot; class=&quot;headerlink&quot; title=&quot;前端性能&quot;&gt;&lt;/a&gt;前端性能&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;页面加载速度优化？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从http请求上来说，减少http请求数（合并css，js，sprite图，或者使用阿里的一个请求多个文件技术），但是合并请求不利于浏览器缓存。适当的请求数可以充分利用并发连接（瀑布图）并利用好缓存。减小文件的大小（压缩css，js，图片）。CDN加速等。&lt;/li&gt;
&lt;li&gt;从浏览器渲染的角度来说，把js放在&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;之前，在DOM加载完成后加载js。CSS动画用&lt;code&gt;transform&lt;/code&gt;而不是js和绝对定位。&lt;/li&gt;
&lt;li&gt;服务器端，充分利用缓存。使用hash更新文件。Gzip压缩。&lt;/li&gt;
&lt;li&gt;性能检测工具。WebPagetest。Chrome DevTools。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;HTTP GET POST的不同？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET是把参数加到URL中，在URL中可以看到。POST将表单内容放置在HTTP request body中。&lt;/li&gt;
&lt;li&gt;在RESTful的api设计中，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;HTTP状态码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：200 ok，304 not modified，404 not found，403 forbidden，500 internal server error， 503 Service Unavailable等。&lt;/p&gt;
&lt;h2 id=&quot;安全&quot;&gt;&lt;a href=&quot;#安全&quot; class=&quot;headerlink&quot; title=&quot;安全&quot;&gt;&lt;/a&gt;安全&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;Web安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：XSS，CSRF，SQL注入等。具体可以看一些前端安全相关的书，初步了解。有实战最佳。&lt;/p&gt;
&lt;h2 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; class=&quot;headerlink&quot; title=&quot;浏览器&quot;&gt;&lt;/a&gt;浏览器&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;描述在浏览器中输入url到网页加载完成的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器查看缓存，如果有为过期的资源则直接返回该资源。&lt;/li&gt;
&lt;li&gt;若缓存没有所需的资源，浏览器解析url，组装一个http请求。&lt;/li&gt;
&lt;li&gt;浏览器获取主机ip地址，查询链从浏览器缓存，本机缓存，路由器缓存，到dns服务器缓存，进入dns查询链&lt;/li&gt;
&lt;li&gt;获得主机的ip地址后，与目标ip建立tcp连接，发送http请求&lt;/li&gt;
&lt;li&gt;tcp/ip 7层模型&lt;/li&gt;
&lt;li&gt;服务器端处理，web服务器，web端处理程序，返回http response&lt;/li&gt;
&lt;li&gt;浏览器接收http reponse 并根据状态码不同做出不同的处理&lt;/li&gt;
&lt;li&gt;根据资源类型决定处理方式，如果是html文档，则构建DOM树，下载资源，构造CSS om树，执行js脚本。&lt;/li&gt;
&lt;li&gt;DOM树：&lt;br&gt;Tokenizing：根据HTML规范将字符流解析为标记&lt;br&gt;Lexing：词法分析将标记转换为对象并定义属性和规则&lt;br&gt;DOM construction：根据HTML标记关系将对象组成DOM树&lt;/li&gt;
&lt;li&gt;CSS OM（object model）树：&lt;br&gt;Tokenizing：字符流转换为标记流&lt;br&gt;Node：根据标记创建节点&lt;br&gt;CSSOM：节点创建CSSOM树&lt;/li&gt;
&lt;li&gt;根据DOM树和CSS om树构建渲染树 render object&lt;br&gt;从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。&lt;br&gt;2)被css隐藏的节点，如display: none&lt;br&gt;对每一个可见节点，找到恰当的CSSOM规则并应用&lt;br&gt;发布可视节点的内容和计算样式&lt;/li&gt;
&lt;li&gt;js解析&lt;br&gt;浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading&lt;br&gt;此时HTML解析器遇到同步script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。&lt;br&gt;浏览器在Document对象上触发DOMContentLoaded事件&lt;br&gt;此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件&lt;/li&gt;
&lt;li&gt;页面显示&lt;br&gt;（关于这个问题的浏览器渲染方面，看webkit技术内幕比较好，我觉得这本书也算是高阶前端必看的一本）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;p&gt;Q：平时如何学习前端？&lt;/p&gt;
&lt;p&gt;A：&lt;br&gt;答案因人而异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术书籍。英文为主，中文为辅。&lt;/li&gt;
&lt;li&gt;信息流-微博，推特等上面的技术博客和文章。&lt;/li&gt;
&lt;li&gt;学框架使用-看官方文档。&lt;/li&gt;
&lt;li&gt;学框架原理-看源码，仿照轮子。&lt;/li&gt;
&lt;li&gt;专题分析，写博客总结或者写demo总结。&lt;/li&gt;
&lt;li&gt;技术会议。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：Web无障碍？&lt;br&gt;A：to be done&lt;/p&gt;
&lt;h2 id=&quot;智力题&quot;&gt;&lt;a href=&quot;#智力题&quot; class=&quot;headerlink&quot; title=&quot;智力题&quot;&gt;&lt;/a&gt;智力题&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;你让工人为你工作7天，给工人的回报是一根金条。金条平分成相连的7段&lt;br&gt;，你必须在每天结束时给他们一段金条，如果只许你两次把金条弄断，你如何给你&lt;br&gt;的工人付费？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：把金条切成4份,2份和1份&lt;br&gt;    第一天给工人一份金条&lt;br&gt;    第二天给他两份的金条，把第一天的一份金条收回&lt;br&gt;    第三天又把一份的金条给他&lt;br&gt;    第四天把四份的金条给他，把一份和两份的金条收回&lt;br&gt;    第五天又把一份的金条给他&lt;br&gt;    第六天又给他两份的金条，收回一份的金条&lt;br&gt;    第七天最后把一份的金条给他  &lt;/p&gt;
&lt;p&gt;Q：&lt;strong&gt;一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少&lt;br&gt;有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看&lt;br&gt;看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自&lt;br&gt;己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦&lt;br&gt;雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑&lt;br&gt;帽子？&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;或者这种变体： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个村子里，有50户人家，每家都养了一条狗。现在，发现村子里面出现了n只疯狗，村里规定，谁要是发现了自己的狗是疯狗，就要将自己的狗枪毙。&lt;br&gt;但问题是，村子里面的人只能看出别人家的狗是不是疯狗，而不能看出自己的狗是不是疯的，如果看出别人家的狗是疯狗，也不能告诉别人。&lt;br&gt;于是大家开始观察，第一天晚上，没有枪声，第二天晚上，没有枪声，第三天晚上，枪声响起（具体几枪不清楚），问村子里有几只疯狗？&lt;br&gt;(1)必须确定是疯狗才能杀&lt;br&gt;(2)杀狗用猎枪,开枪杀狗人人都听的见,没聋子&lt;br&gt;(3)只能观察其他人家的狗是否得了疯狗病,不能观察自己的狗是否有疯狗病&lt;br&gt;(4)只能杀自己家的狗,别人家的狗你就是知道有疯狗病也不能杀&lt;br&gt;(5)任何观察到了其他人家的狗有疯狗病都不能告诉任何人&lt;br&gt;(6)每人每天去观察一遍其他人家的狗是否疯狗&lt;br&gt;现在现象是:第一天没有枪声,第二天没有枪声,第三天响起一片枪声&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：假如只有一个人戴黑帽子，那他看到所有人都戴白帽，在第一次关灯时就&lt;br&gt;应自打耳光，所以应该不止一个人戴黑帽子；如果有两顶黑帽子，第一次两人都只&lt;br&gt;看到对方头上的黑帽子，不敢确定自己的颜色，但到第二次关灯，这两人应该明白&lt;br&gt;，如果自己戴着白帽，那对方早在上一次就应打耳光了，因此自己戴的也是黑帽子&lt;br&gt;，于是也会有耳光声响起；可事实是第三次才响起了耳光声，说明全场不止两顶黑&lt;br&gt;帽，依此类推，应该是关了几次灯，有几顶黑帽。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;接下来要参与大大小小的暑期实习笔试和面试。在这篇博客里我将总结一些常见的面试题。其中有一部分是我去年暑假找实习的时候总结的。现在看来，不免有些幼稚。慢慢完善吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Interview Front-end" scheme="http://yoursite.com/tags/Interview-Front-end/"/>
    
  </entry>
  
  <entry>
    <title>DOM API详解（二）</title>
    <link href="http://yoursite.com/2016/01/26/learning-dom-part2/"/>
    <id>http://yoursite.com/2016/01/26/learning-dom-part2/</id>
    <published>2016-01-26T07:58:34.000Z</published>
    <updated>2016-04-21T03:05:12.000Z</updated>
    
    <content type="html">&lt;p&gt;###四、API详解-DOM CORE&lt;/p&gt;
&lt;h4 id=&quot;DOM标准的层级&quot;&gt;&lt;a href=&quot;#DOM标准的层级&quot; class=&quot;headerlink&quot; title=&quot;DOM标准的层级&quot;&gt;&lt;/a&gt;DOM标准的层级&lt;/h4&gt;&lt;p&gt;DOM标准实际由很多的子模块组成，包括Core module，XML module，Events module，User interface Events module，Mouse Events module，Text Events module，Keyboard Events module，Mutation Events module，Mutation name Events module，HTML Events module，Load and Save module，Asynchronous load module，Validation module，和XPath module。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;具体的层级结构如下图所示：&lt;br&gt;&lt;img src=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/images/dom-architecture.png&quot; alt=&quot;dom-architecture&quot;&gt;&lt;br&gt;&lt;em&gt;image credit: w3.org&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;DOM-Core-导语&quot;&gt;&lt;a href=&quot;#DOM-Core-导语&quot; class=&quot;headerlink&quot; title=&quot;DOM Core-导语&quot;&gt;&lt;/a&gt;DOM Core-导语&lt;/h4&gt;&lt;p&gt;在我们把目光转向DOM Core模块之前，我想先讲讲如何阅读DOM的W3C Specification。首先我们可以阅读官方的导语-&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is the Document Object Model?&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这一节中介绍了DOM的相关概念。比如关于DOM的结构，我们通常认为是一颗树，但实际上用森林来形容更为贴切，因为虽然以&lt;code&gt;Document&lt;/code&gt;为根节点的文档树最多只能有一颗，但我们还有一颗可选的&lt;code&gt;doctype&lt;/code&gt;节点树，以及&lt;code&gt;comments&lt;/code&gt;节点等等。&lt;/p&gt;
&lt;p&gt;更重要的是，导语中还介绍了接下来文档中的一些惯例。比如因为DOM是独立于编程语言的，所以在文档中使用了IDL（Interactive Data Language）来描述接口。然后我们需要注意的一点就是，DOM可以用于HTML和XML，因此在前端同学看来，DOM中会有一些不太熟悉的概念，比如&lt;code&gt;Namespace&lt;/code&gt;和&lt;code&gt;DOM URIs&lt;/code&gt;，这些正是为了兼容XML而加入到DOM中的特性。不用过分在意。&lt;/p&gt;
&lt;p&gt;下面是一个简化的IDL示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Element : Node {
  readonly attribute DOMString       tagName;
  void               removeAttribute(in DOMString name)
                                        raises(DOMException);
  Attr               getAttributeNode(in DOMString name);
  NodeList           getElementsByTagName(in DOMString name);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;IDL中主要描述了一个接口的继承关系，以及接口的方法和属性，及相应的参数和返回值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面我们首先来看DOM Core模块。从“Core”这个名词就可以看出这个模块在整个DOM标准中处于中心地位。DOM Core模块主要定义了DOM最关键的一组接口和对象。其中最顶层的一个接口就是&lt;code&gt;Node&lt;/code&gt;。直接继承&lt;code&gt;Node&lt;/code&gt;的接口有&lt;code&gt;Element&lt;/code&gt;、&lt;code&gt;DocumentType&lt;/code&gt;、&lt;br&gt;&lt;code&gt;Attr&lt;/code&gt;、&lt;code&gt;ProcessingInstruction&lt;/code&gt;、&lt;code&gt;Comment&lt;/code&gt;、&lt;br&gt;&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;CDATASection&lt;/code&gt;和&lt;code&gt;Notation&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Node接口&quot;&gt;&lt;a href=&quot;#Node接口&quot; class=&quot;headerlink&quot; title=&quot;Node接口&quot;&gt;&lt;/a&gt;Node接口&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;接口是整个DOM中最顶层的接口，DOM中的每一个节点都是一个&lt;code&gt;Node&lt;/code&gt;。从&lt;code&gt;Node&lt;/code&gt;接口分化出其他的更具体的接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;接口的属性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;属性名&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nodeName&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DOMString&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nodeValue&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DOMString&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nodeType&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;unsigned short&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parentNode&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;childNodes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;NodeList&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;firstChild&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastChild&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;previousSibling&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nextSibling&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;attributes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;NamedNodeMap&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ownerDocument&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Document&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;值得注意的是，虽然这些属性都定义在Node接口上，但是不是所有的底层接口实现都有对应的值。如&lt;code&gt;Text&lt;/code&gt;和&lt;code&gt;Comment&lt;/code&gt;节点都没有子元素，因此它们的&lt;code&gt;childNodes&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;。同理，&lt;code&gt;Element&lt;/code&gt;接口的&lt;code&gt;nodeValue&lt;/code&gt;值就为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nodeType&lt;/code&gt;属性的值被定义为一组常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// NodeType
  const unsigned short      ELEMENT_NODE                   = 1;
  const unsigned short      ATTRIBUTE_NODE                 = 2;
  const unsigned short      TEXT_NODE                      = 3;
  const unsigned short      CDATA_SECTION_NODE             = 4;
  const unsigned short      ENTITY_REFERENCE_NODE          = 5;
  const unsigned short      ENTITY_NODE                    = 6;
  const unsigned short      PROCESSING_INSTRUCTION_NODE    = 7;
  const unsigned short      COMMENT_NODE                   = 8;
  const unsigned short      DOCUMENT_NODE                  = 9;
  const unsigned short      DOCUMENT_TYPE_NODE             = 10;
  const unsigned short      DOCUMENT_FRAGMENT_NODE         = 11;
  const unsigned short      NOTATION_NODE                  = 12;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是我们平时用来检测节点类型时使用的数值了。&lt;/p&gt;
&lt;p&gt;下面从&lt;code&gt;Node&lt;/code&gt;接口的方法中选几个主流的API进行简单的介绍，对于W3C中为标准但在WHATWG中被废弃的，这里不进行介绍（在主流的浏览器中也没有相应的实现）。对于一些在继承Node的接口中有更具体实现的API，这里也不进行介绍（如&lt;code&gt;hasAttributes&lt;/code&gt;在Element接口中有更具体的实现）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;compareDocumentPosition&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是DOM3中引入的一个很有意思的API。这个API将两个Node的位置进行比较，然后返回&lt;code&gt;DocumentPosition&lt;/code&gt;这组常量中的一种。这组常量是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 节点被另一个节点包含。被包含的节点是父节点的后继
DOCUMENT_POSITION_CONTAINED_BY
// 节点包含另一个节点。父节点是子节点的前驱
  DOCUMENT_POSITION_CONTAINS
DOCUMENT_POSITION_DISCONNECTED
// 后继关系
DOCUMENT_POSITION_FOLLOWING
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
// 前驱关系
DOCUMENT_POSITION_PRECEDING
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;appendChild&lt;/code&gt;&amp;amp;&amp;amp;&lt;code&gt;removeChild&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;这两个API是比较常用的，&lt;code&gt;appendChild&lt;/code&gt;在DOM子元素列表的最后插入元素，如果这个元素已经存在DOM树中，就先移除这个元素再插入。&lt;code&gt;removeChild&lt;/code&gt;则从DOM子元素列表中移除元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;insertBefore&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;这个API有两个参数，一个是&lt;code&gt;newChild&lt;/code&gt;，一个是&lt;code&gt;refChild&lt;/code&gt;。&lt;code&gt;newChild&lt;/code&gt;既是要插入的节点，而&lt;code&gt;refChild&lt;/code&gt;则是一个已经在&lt;code&gt;Node&lt;/code&gt;所在DOM树中的参考子节点。&lt;code&gt;newChild&lt;/code&gt;会插入到&lt;code&gt;refChild&lt;/code&gt;之前，如果&lt;code&gt;refChild&lt;/code&gt;是&lt;code&gt;null&lt;/code&gt;，那么&lt;code&gt;newChild&lt;/code&gt;会插入到&lt;code&gt;Node&lt;/code&gt;子节点列表的末尾。&lt;/p&gt;
&lt;p&gt;这个API的记忆很简单，命名是&lt;code&gt;insertBefore&lt;/code&gt;，必然是有一个参考节点的，不然插到谁的前面去呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;isEqualNode&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个API的作用是判断两个DOM是否相等。这里的相等并不是指指向同一个对象，而是指属性和值方面是否相同。&lt;/p&gt;
&lt;p&gt;对于两个节点来说比较的算法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个节点是否是相同的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodeName, localName, namespaceURI, prefix, nodeValue&lt;/code&gt;这些属性是否相同&lt;/li&gt;
&lt;li&gt;节点的属性集合（在DOM中的数据类型是&lt;code&gt;NamedNodeMaps&lt;/code&gt;）是否相同，这里集合中属性的顺序可以是随意的&lt;/li&gt;
&lt;li&gt;子节点集合（&lt;code&gt;NodeLists&lt;/code&gt;类型）是否相同，这里会考虑节点的index，如果不一样则不相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Element接口&quot;&gt;&lt;a href=&quot;#Element接口&quot; class=&quot;headerlink&quot; title=&quot;Element接口&quot;&gt;&lt;/a&gt;Element接口&lt;/h4&gt;&lt;h4 id=&quot;Document接口&quot;&gt;&lt;a href=&quot;#Document接口&quot; class=&quot;headerlink&quot; title=&quot;Document接口&quot;&gt;&lt;/a&gt;Document接口&lt;/h4&gt;&lt;h4 id=&quot;Attr接口&quot;&gt;&lt;a href=&quot;#Attr接口&quot; class=&quot;headerlink&quot; title=&quot;Attr接口&quot;&gt;&lt;/a&gt;Attr接口&lt;/h4&gt;&lt;h4 id=&quot;Text，Comment和CharacterData接口&quot;&gt;&lt;a href=&quot;#Text，Comment和CharacterData接口&quot; class=&quot;headerlink&quot; title=&quot;Text，Comment和CharacterData接口&quot;&gt;&lt;/a&gt;Text，Comment和CharacterData接口&lt;/h4&gt;&lt;h4 id=&quot;DOM中的基础数据类型&quot;&gt;&lt;a href=&quot;#DOM中的基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;DOM中的基础数据类型&quot;&gt;&lt;/a&gt;DOM中的基础数据类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DOMString&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMTimeStamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMUserData&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMObject&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###四、API详解-DOM CORE&lt;/p&gt;
&lt;h4 id=&quot;DOM标准的层级&quot;&gt;&lt;a href=&quot;#DOM标准的层级&quot; class=&quot;headerlink&quot; title=&quot;DOM标准的层级&quot;&gt;&lt;/a&gt;DOM标准的层级&lt;/h4&gt;&lt;p&gt;DOM标准实际由很多的子模块组成，包括Core module，XML module，Events module，User interface Events module，Mouse Events module，Text Events module，Keyboard Events module，Mutation Events module，Mutation name Events module，HTML Events module，Load and Save module，Asynchronous load module，Validation module，和XPath module。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
</feed>
