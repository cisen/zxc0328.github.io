<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zindex&#39;s blog</title>
  <subtitle>zindex of muxistudio</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-29T15:09:58.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zindex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个组件的诞生</title>
    <link href="http://yoursite.com/2016/09/29/let-s-make-a-component/"/>
    <id>http://yoursite.com/2016/09/29/let-s-make-a-component/</id>
    <published>2016-09-29T02:24:27.000Z</published>
    <updated>2016-09-29T15:09:58.000Z</updated>
    
    <content type="html">&lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var banner = {
    init: function() {
        this.addEvent();
    },
    addEvent: function() {
        var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
        var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
        buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(1)
        })
        buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(-1)
        })

    },
    switchClassName: function(direction) {
        // 切换Class类名
    }
}

banner.init();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;1.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;2.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;3.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/monocle-guy/jolly-god-old-chap-thumb.jpg&quot; alt=&quot;old chap&quot;&gt;&lt;/p&gt;
&lt;p&gt;正当你觉得自己可以刷知乎的时候，主管把你叫到一边，告诉你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你这个页面上需要有两个banner，怎么办呢？复制粘贴吗?&lt;/li&gt;
&lt;li&gt;如果在需要在某个时间点从页面上移除banner，怎么办呢？手动remove节点吗，销毁对象吗？&lt;/li&gt;
&lt;li&gt;如果banner中图片的URL是从服务端API请求到的动态的数据，难道要用一个个用修改图片的src的方法来显示这些数据吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;听到这里，你的内心是崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/y-u-no/css-floats-y-u-no-clear-yourself-thumb.jpg&quot; alt=&quot;y no &quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;面向对象大法&quot;&gt;&lt;a href=&quot;#面向对象大法&quot; class=&quot;headerlink&quot; title=&quot;面向对象大法&quot;&gt;&lt;/a&gt;面向对象大法&lt;/h3&gt;&lt;p&gt;这时，你想起了大学时学过的面向对象。你把你的组件改成了这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Banner = function(options) {
    this._init(options);
}

Banner.prototype.init = function() {
    this.addEvent();
}

Banner.prototype.addEvent = function() {
    var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
    var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
    buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(1);
    })
    buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(-1);
    })
}

Banner.prototype.switchClassName = function(direction) {
    // 切换Class类名
}

Banner.prototype.destroy = function() {
    //todo:解绑事件
}

//初始化
var banner1 = new Banner();
var banner2 = new Banner();

//销毁
banner1.destroy();
banner2.destroy();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;棒，这样就可以轻松的使用多个banner，并通过调用&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;等生命周期方法来初始化和销毁组件了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生命周期&lt;br&gt;这是组件开发中的一个术语。如果把组件比作一个生物，我们设计的API，比如&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;就相当于这个生物的出生和死亡。一个组件从&lt;code&gt;init&lt;/code&gt;被调用时被初始化，渲染到页面上，然后和用户发生交互，这时调用的方法也属于生命周期的一部分。用户界面随着用户的交互而发生变化，所以组件也不是一成不变的。生命周期方法其实就是在组件的某个阶段会被调用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模板和渲染&quot;&gt;&lt;a href=&quot;#模板和渲染&quot; class=&quot;headerlink&quot; title=&quot;模板和渲染&quot;&gt;&lt;/a&gt;模板和渲染&lt;/h3&gt;&lt;p&gt;还有一个问题没有解决，那就是如何轻松的将数据填充到DOM节点中呢？&lt;/p&gt;
&lt;h4 id=&quot;字符串拼接大法&quot;&gt;&lt;a href=&quot;#字符串拼接大法&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接大法&quot;&gt;&lt;/a&gt;字符串拼接大法&lt;/h4&gt;&lt;p&gt;你首先想出了一个比较笨的办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var url = &amp;quot;/images/1.png&amp;quot;
var template = funtion(url) {
    return &amp;quot;&amp;lt;img src=&amp;#39;&amp;quot; + url + &amp;quot;&amp;#39;/&amp;gt;&amp;quot;;
}

template(url); // &amp;quot;&amp;lt;img src=&amp;#39;/images/1.png&amp;#39;/&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是传说中的字符串拼接大法。一种非常原始的“模板”。简单的说就是把HTML中不变的部分原样写成字符串，中间的变化的部分，我们叫模板的变量，会被作为参数输入到模板函数中。然后这些变量和字符串拼接起来，就生成了目标HTML字符串。&lt;/p&gt;
&lt;p&gt;上例中的&lt;code&gt;template&lt;/code&gt;函数做的事情，我们叫做“编译”模板。当然这个函数非常简单，只是拼接了一下字符串。一个成熟的模板引擎的编译函数做的事情，要更接近于传统意义上的“编译”。&lt;/p&gt;
&lt;h4 id=&quot;DOM-based模板&quot;&gt;&lt;a href=&quot;#DOM-based模板&quot; class=&quot;headerlink&quot; title=&quot;DOM based模板&quot;&gt;&lt;/a&gt;DOM based模板&lt;/h4&gt;&lt;p&gt;字符串拼接大法的问题，相信大家都看到了，就是写起来非常的麻烦，各种单引号和双引号。如果要换行还必须用&lt;code&gt;+&lt;/code&gt;号拼接。&lt;/p&gt;
&lt;p&gt;于是我们就想到了，如果我们把模板作为普通的HTML，那就会方便很多。我们只要像写HTML那样把模板写在HTML文件中，比如:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{ url1 }&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{ url2 }&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要向获取模板的内容，只需要这样：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的就是这个模板的字符串了。&lt;/p&gt;
&lt;p&gt;假设我们写了一个模板引擎，它的作用就是将&lt;code&gt;{ }&lt;/code&gt;花括号内的表达式，在模板的context下面解析，并返回值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context，就是指一个特定的作用域。里面有当前作用域下面的变量（标识符）和对应的值之间的映射。模板的context就是指一个有模板中相关变量的作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个模板引擎是这样使用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#39;complie&amp;#39; from &amp;#39;templateEngine&amp;#39;

var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML
var data = {
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
var HTMLString = compile(templateString, data)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当&lt;code&gt;compile&lt;/code&gt;函数遇到变量时，就会从&lt;code&gt;data&lt;/code&gt;中去找。&lt;code&gt;data&lt;/code&gt;在这个例子就是context。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插一句，被大家吐槽的&lt;code&gt;eval&lt;/code&gt;函数可以用来做在特定context下求值的事情，这正是这种模板引擎所需要做的。所以你可以用&lt;code&gt;eval&lt;/code&gt;来实现一个简单的模板引擎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{ url1 }&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{ url2 }&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为这个花括号中可以是任意合法的JavaScript表达式，所以你也可以这样玩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//其他省略
var data = {
    displayFlag: false,
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;{{ displayFlag ? &#39;display:block&#39;:&#39;display:none&#39;}}&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{ url1 }&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{ url2 }&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很神奇，不是吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ricardomartins.com.br/wp-content/uploads/2015/05/Magic_meme.gif&quot; alt=&quot;magic&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;render生命周期方法&quot;&gt;&lt;a href=&quot;#render生命周期方法&quot; class=&quot;headerlink&quot; title=&quot;render生命周期方法&quot;&gt;&lt;/a&gt;&lt;code&gt;render&lt;/code&gt;生命周期方法&lt;/h4&gt;&lt;p&gt;因为现在我们的组件不再使用静态的HTML字符串了，我们需要一个函数来输出HTML字符串。所以我们需要在组件上增加一个叫&lt;code&gt;render&lt;/code&gt;的生命周期函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Banner.prototype.render = function() {
    this.el.innerHTML = compile(this.el.innerHTML, this.data);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的&lt;code&gt;el&lt;/code&gt;是这个组件的一个配置项，代表这个组件的根节点。组件的模板来自根节点的内容。模板编译之后输出的HTML字符串又会替换根节点中的模板，从而渲染这个组件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，模板所在的节点和渲染组件的节点可以不是同一个，这个是和具体的组件框架实现相关的。只要模板可以以字符串的形式被引入，就可以达到目的了。是否放在HTML的DOM节点中并不是问题的关键。我们可以写单独的模板文件并用webpack等打包工具引入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h3&gt;&lt;p&gt;一个组件中，比如模板根节点、以及组件的&lt;code&gt;data&lt;/code&gt;这样的数据，应该在组件实例化的时候，作为配置被传入构造函数中。&lt;/p&gt;
&lt;p&gt;所以，让我们改造一下初始化函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Banner.prototype.init = function(options) {
    this.data = options.data || {};
    this.el = options.el || document.querySelector(&amp;quot;body&amp;quot;);
    this.render();
    this.addEvent();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，如果你这样再初始化一个组件，并调用&lt;code&gt;init&lt;/code&gt;方法，你的页面上就出现了一个banner！大功告成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/pp.png&quot; alt=&quot;pp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;h3 id=&quot;Vue-and-Beyond&quot;&gt;&lt;a href=&quot;#Vue-and-Beyond&quot; class=&quot;headerlink&quot; title=&quot;Vue and Beyond&quot;&gt;&lt;/a&gt;Vue and Beyond&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编码》导读</title>
    <link href="http://yoursite.com/2016/09/15/read-code/"/>
    <id>http://yoursite.com/2016/09/15/read-code/</id>
    <published>2016-09-15T10:32:05.000Z</published>
    <updated>2016-09-16T13:41:39.000Z</updated>
    
    <content type="html">&lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
&lt;p&gt;《编码》讲的是什么呢？笼统的说，就是用自底向上的角度一层层的解析计算机的原理。比如第一章到第三章将的是编码的本质——信息和符号的对应。第四章到第六章讲的是电信号可以用来表示一种编码，从而传递信息。第七章到第九章介绍了二进制，也就是计算机系统中最基本的编码形式。第十章：逻辑与开关和第十一章：门，介绍了布尔代数，以及如何使用门电路进行布尔代数的运算。第十二章和第十三章介绍了二进制加法器和减法器，加法器已然是现代CPU中运算单元的雏形了。第十四章介绍的反馈与触发器是实现计算机中储存芯片的基础。第十五章字节与十六进制是为理解后续的存储器数据格式而准备的。第十六章讲了存储器的组织，这便是现代计算机系统中存储系统的原理。第十七章，是全书最难的一章，讲了如何制作一个CPU。CPU本质上就是一个可以编程的运算器。第十八章介绍了从算盘到机械结构到电子管再到晶体管的技术革命，晶体管、超大规模集成电路使得现代CPU的出现成为了可能。第十九章介绍了Intel 8080CPU的指令集。第二十章介绍了字符的存储格式，这可以帮助你理解计算机是如何存储文本的。第二十一章：总线，介绍了计算机系统中CPU、内存和I/O设备如何通信。第二十二章是一个简短的操作系统简史，注意到从这里我们涉及了软件层面的内容。第二十三章定点数和浮点数比较独立，主要讲了计算机是如何存储浮点数的。第二十四章和第二十五章则介绍了编程语言和图形学基础。&lt;/p&gt;
&lt;p&gt;我们可以清晰的看到从硬件到软件，从具体到抽象，从底层到顶层的一个脉络。&lt;/p&gt;
&lt;p&gt;这本书其实包含了我们计算机专业中《数字逻辑》、《计算机组成原理》、《微机系统与接口原理》三门课的主干内容。作者没有试图灌输大量的理论知识，而是试图将这些知识串联起来，包括最后的操作系统和编程语言，其实和计算机硬件是有着不可分割的关系的。在《编码》这本书中你就可以很自然的在章节的推进中体会到这种联系。&lt;/p&gt;
&lt;p&gt;下面我会对一些章节进行详细的解读。主要是解释难点，拓展一些知识，并且写清这一章节的知识对应我们的哪门专业课，而专业课和这本书的要求有何不同等等。&lt;/p&gt;
&lt;p&gt;我希望这本书可以让大家看清计算机的本质，计算机的本质其实就是一个处理信息的机器。你输入数据，计算机输出数据。首先我们需要一套编码系统来表示这些数据，而二进制的编码正好与半导体的性质相吻合，我们可以用布尔代数来对现实问题进行建模，通过门电路来表示这个布尔代数，从而制造出可以进行某种运算的电路。而如果这个电路可编程，再加上输入输出接口，那就是一个CPU了。至于是半导体和二进制之间孰先孰后呢，你可以做进一步的研究（从书中来看，第一台计算机ENIAC是采用十进制的，所以看来应该是半导体在先，二进制在后）（所以今后如果计算机的物理介质有了更新，我们也许就会换一种新的编码方案了）。&lt;/p&gt;
&lt;p&gt;在书中大量讲到的门电路、继电器等等属于实现层面，大家了解一下就好。我们不是电气工程师，我们是软件工程师。当然理解硬件层面细节对于写好代码是很有帮助的。这主要解释的是一个“为什么”的问题。&lt;/p&gt;
&lt;p&gt;你了解了CPU的指令集，和CPU的工作方式，你就理解为什么我们在程序运行时需要“栈”这个数据结构。&lt;/p&gt;
&lt;p&gt;你了解了字符的编码以及浮点数的编码，你就不会奇怪于为什么&lt;code&gt;0.1+0.2&lt;/code&gt;不等于&lt;code&gt;0.3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们要关注的主要是如何用编码来抽象问题。比如用二进制来表示数据，进行运算。比如用指令来对CPU进行编程。比如&lt;/p&gt;
&lt;h3 id=&quot;第一章：至亲密友、第二章：编码与组合与第三章：布莱叶盲文与二进制码&quot;&gt;&lt;a href=&quot;#第一章：至亲密友、第二章：编码与组合与第三章：布莱叶盲文与二进制码&quot; class=&quot;headerlink&quot; title=&quot;第一章：至亲密友、第二章：编码与组合与第三章：布莱叶盲文与二进制码&quot;&gt;&lt;/a&gt;第一章：至亲密友、第二章：编码与组合与&lt;code&gt;第三章：布莱叶盲文与二进制码&lt;/code&gt;&lt;/h3&gt;&lt;h3 id=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;a href=&quot;#第四章：手电筒的剖析、第五章：绕过拐角的通信&quot; class=&quot;headerlink&quot; title=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;/a&gt;第四章：手电筒的剖析、第五章：绕过拐角的通信&lt;/h3&gt;&lt;h3 id=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;a href=&quot;#第十章：逻辑与开关与第十一章：门&quot; class=&quot;headerlink&quot; title=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;/a&gt;第十章：逻辑与开关与第十一章：门&lt;/h3&gt;&lt;p&gt;第十章首先介绍的内容是：布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数，其实在我们的《离散数学》课里就接触过。&lt;em&gt;注：如果没学过离散数学，可以买《离散数学及其应用》这本书学习，这里说到的形式逻辑主要指命题逻辑&lt;/em&gt;《离散数学》里一开始讲的逻辑，比如这种形式的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/3ad862b103437f908a58b008703464bea93a1ef2&quot; alt=&quot;命题逻辑&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道一个命题可能是真（T），也可能是假（F）。那如果我们把T和F换成1和0，然后将命题逻辑中的合取，析取，否定等关系换了一种表示形式，这就成了布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数中每个变量都是一个&lt;code&gt;{0,1}&lt;/code&gt;的集合。命题逻辑中的合取在布尔代数中用&lt;code&gt;·&lt;/code&gt;或者AND表示，而析取则用&lt;code&gt;+&lt;/code&gt;或者OR表示。否定则用表示。&lt;/p&gt;
&lt;p&gt;在第十一章中，有一个布尔表达式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(M·N·(W+T)+(F·N·(1-W))+B)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们代入每个变量之中，运用布尔代数运算符的规则，就可以计算出这布尔表达式的值是True或者是False。&lt;/p&gt;
&lt;p&gt;这就是问题的关键了，布尔代数是一个&lt;strong&gt;抽象的计算模型&lt;/strong&gt;。我们可以将现实世界的问题，抽象成布尔表达式（当然这个最终是因为我们可以用命题逻辑来表示现实世界的问题）。&lt;/p&gt;
&lt;p&gt;讲到这里，似乎和计算机没有什么关系。但最精彩的部分就在下面，我们可以&lt;strong&gt;用布尔代数设计电路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个机械开关，有开启和闭合两种状态，可以用来表示0或者1。这个是《编码》前几章大力铺垫的一个事实。既然这样，那我们就可以用两个开关的并联或者串联来表示AND和OR逻辑。更进一步，我们可以用开关和电线表示任何布尔表达式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;用布尔代数可以用某种电路来等价的表示&lt;/strong&gt;这个事实。从在19世纪50年代乔治·布尔发明布尔代数开始，一直到20世纪30年代才被信息论之父香农发现。尽管逻辑电路所需的开关和电线在19世纪都已经存在了。可见这种等价关系的革命性意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，反过来，布尔表达式也可以指导我们设计电路。事实上这个是目前所有逻辑电路设计的理论基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《数字逻辑》这门课讲布尔代数，主要是作为设计电路的一种工具。假如我们要设计电路，解决这个现实问题。这个问题被抽象成几个输入和输出。这些输入和输出是可能是0或者1。我们知道不同变量输入时对应的输出，也就是所谓的真值表。利用真值表，我们可以写出一个布尔表达式。但这个布尔表达式可以化简。我们可以用卡诺图等方式进行化简，化简的目的是简化电路。最终，化简的电路可以转化为门电路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《编码》里只是简单的介绍了布尔代数和门电路，没有深入的介绍电路的设计。这是比较明智的，因为如何设计电路不是我们要关心的话题。《数字逻辑》中在电路设计这块涉及的还有功能表到布尔表达式的转换，布尔表达式的化简等等。有兴趣的同学可以了解一下。&lt;/p&gt;
&lt;p&gt;总结一下，这两章对我们最大的启发就是：逻辑电路设计的理论基础是布尔代数。布尔代数可以用逻辑电路进行等价表示。而逻辑电路则是计算机所有硬件的基础。&lt;/p&gt;
&lt;h3 id=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;a href=&quot;#第十八章：从算盘到芯片&quot; class=&quot;headerlink&quot; title=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;/a&gt;第十八章：从算盘到芯片&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
&lt;p&gt;《编码》讲的是什么呢？笼统的说，就是用自底向上的角度一层层的解析计
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 JSConf China见闻</title>
    <link href="http://yoursite.com/2016/09/07/jsconf2016/"/>
    <id>http://yoursite.com/2016/09/07/jsconf2016/</id>
    <published>2016-09-07T03:29:53.000Z</published>
    <updated>2016-09-07T06:48:26.000Z</updated>
    
    <content type="html">&lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;然而最终的结果只能说是差强人意。真正有干货的主要是Ben Lesh的&lt;a href=&quot;&quot;&gt;RxJS&lt;/a&gt;以及James Kyle的&lt;a href=&quot;&quot;&gt;How to build a complier&lt;/a&gt;，然而恰恰因为他们都是比较活跃的工程师，所以他们这两个演讲我都在youtube上看过了。至于Vue，并没有讲很多的干货，主要还是来圈粉的。&lt;/p&gt;
&lt;p&gt;其他的talk里面，PM2作者的分享还是非常solid的，他当场开源了&lt;a href=&quot;&quot;&gt;grid control&lt;/a&gt;这个项目。朴灵的分享尽管主要是打广告，但是还是要我知道了Node性能调优里内存泄露、CPU占用和GC频繁三个方向。&lt;/p&gt;
&lt;p&gt;WebVR和3D这些，说实话只能做到Demo级别的分享。这也是免不了的，外行只能看热闹。主要是给大家演示一下，如果能有启发就再好不过了。&lt;/p&gt;
&lt;p&gt;不过这次大会上我的确看到了很多微博上关注的圈内人，等以后我在圈子里混熟了，水平更好了。那也许可以来参会和大家聊聊。&lt;/p&gt;
&lt;p&gt;其实FEDay的质量明显要更高一些，尽管有翻译英文演讲这种笑话，但是干货明显更多，整体的技术气氛也更好一些。&lt;/p&gt;
&lt;p&gt;总之，对于国内的技术大会，今后还是要慎重的选择。不然还不如在家看youtube上大神的分享呢。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Regular Devtools开发手记</title>
    <link href="http://yoursite.com/2016/07/28/regular-devtools-thought/"/>
    <id>http://yoursite.com/2016/07/28/regular-devtools-thought/</id>
    <published>2016-07-28T07:52:00.000Z</published>
    <updated>2016-08-01T11:00:19.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Chrome-Extension组成&quot;&gt;&lt;a href=&quot;#Chrome-Extension组成&quot; class=&quot;headerlink&quot; title=&quot;Chrome Extension组成&quot;&gt;&lt;/a&gt;Chrome Extension组成&lt;/h3&gt;&lt;p&gt;其实前端开发者们熟悉的Chrome Devtools是用Web技术开发的。验证的方法很简单，如果你把Chrome Devtools设置为单独窗口，然而再按下打开Chrome Devtools的快捷键的话（&lt;code&gt;Control+Shift+I&lt;/code&gt;），你可以开启一个’meta inspecting’，也就是打开第二个开发者工具来检查第一个开发者工具的DOM元素。当然了，如果你熟悉Chrome Devtools团队的一些知名开发者，比如&lt;a href=&quot;https://github.com/addyosmani&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Addy Osmani&lt;/a&gt;和&lt;a href=&quot;https://github.com/paulirish&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paul Irish&lt;/a&gt;的话，你可能对Chrome Devtools是用Web技术开发的这个事实习以为常。正如V8并不是完全的C++实现，有一部分API是JavaScript实现，Chrome的界面也不都是原生的，Hybrid无处不在。&lt;/p&gt;
&lt;p&gt;好了，下面我们来说说Chrome Extension。Chrome Extension其实就是使用Web技术来开发的，只不过和一般的页面不同的是，Chrome Extension的执行环境可以访问到一系列的&lt;code&gt;chrome.*&lt;/code&gt;API。比如用&lt;code&gt;chrome.tabs&lt;/code&gt;API来打开新tab，或者监听和tab有关的一系列事件。完整的API文档在&lt;a href=&quot;https://developer.chrome.com/extensions/api_index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Chrome Extension一般由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI page&lt;/li&gt;
&lt;li&gt;Content Script&lt;/li&gt;
&lt;li&gt;Background Script&lt;/li&gt;
&lt;li&gt;Devtools Panel page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓UI page，就是用户点击导航栏中Extension的图标之后出现的弹出框。这个框是一个HTML页面，包含了Extension的UI逻辑。&lt;/p&gt;
&lt;p&gt;如果你的Extension想要访问当前用户页面的DOM结构，那你必须使用Content Script。Content Script的特点就是，它可以访问当前用户页面的DOM结构，但除此之外，当前用户页面上的&lt;code&gt;window&lt;/code&gt;对象等全局变量以及JavaScript脚本运行后产生的变量都无法访问。Content Script是运行在沙盒中的，它只被允许访问页面的DOM结构。不过Content Script作为Extension的一部分，可以和Background Script通信。&lt;/p&gt;
&lt;p&gt;如果我们把一个Chrome Extension看成一个Web应用，Content Script和UI page可以一起被当做Extension这个应用的View层。&lt;/p&gt;
&lt;p&gt;Background Script，正如名字所示，是Extension运行在后台的一个脚本。这个脚本可以和Content Script通信。&lt;/p&gt;
&lt;p&gt;如果你开发的是一款Chrome Devtools Extension，类似Regular Devtools，那你就需要Devtools Panel page了。这个页面负责在Chrome Devtools里新建tab，并且展示tab中的UI。&lt;/p&gt;
&lt;h3 id=&quot;Regular-Devtools的组成&quot;&gt;&lt;a href=&quot;#Regular-Devtools的组成&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的组成&quot;&gt;&lt;/a&gt;Regular Devtools的组成&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202016-07-29%20at%202.28.44%20PM.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;p&gt;Regular Devtools的组成和普通Extension不同之处在于没有UI page，取而代之的是Devtools Panel page。这其实没有太大的区别。只不过UI部分由Devtools Panel page来展现而不是UI page。&lt;/p&gt;
&lt;p&gt;上图是Regular Devtools的大致结构。其中Content Script和Background Script两部分构成Model层，负责数据的搜集和处理。Devtools Panel page则是UI层，负责展现数据。下面我们来讲讲具体的实现。&lt;/p&gt;
&lt;h3 id=&quot;获取Regular组件实例&quot;&gt;&lt;a href=&quot;#获取Regular组件实例&quot; class=&quot;headerlink&quot; title=&quot;获取Regular组件实例&quot;&gt;&lt;/a&gt;获取Regular组件实例&lt;/h3&gt;&lt;p&gt;首先我们需要获得Regular组件实例。这一步的实现思路大致就是在页面中注入一个Event Emitter（在页面所有脚本运行之前），并挂载在全局的&lt;code&gt;window&lt;/code&gt;对象上。然后每一个Regular组件的初始化、更新、销毁等生命周期事件发生时都会在Event Emitter上emit相应的事件，并传入实例。这样我们就可以获取到页面中所有的Regualr组件实例以及相应的其他信息了。&lt;/p&gt;
&lt;p&gt;这个Event Emitter的实现可以参考&lt;/p&gt;
&lt;h3 id=&quot;inject大法&quot;&gt;&lt;a href=&quot;#inject大法&quot; class=&quot;headerlink&quot; title=&quot;inject大法&quot;&gt;&lt;/a&gt;&lt;code&gt;inject&lt;/code&gt;大法&lt;/h3&gt;&lt;p&gt;说起来很简单，可以刚才讲到Content Script时我们说到过，它无法访问用户页面上的全局变量，因此Content Script无法访问到用户页面的&lt;code&gt;window&lt;/code&gt;对象，那我们要如何获取挂载在&lt;code&gt;window&lt;/code&gt;对象上的Regualr组件实例数组呢？&lt;/p&gt;
&lt;p&gt;解决办法很简单，Content Script可以访问用户页面的DOM结构，那我们插入一个&lt;code&gt;script&lt;/code&gt;标签就可以在用户页面的context下执行脚本了。&lt;/p&gt;
&lt;p&gt;比如我们可以实现这样一个&lt;code&gt;inject&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function inject(content) {
    var script = document.createElement(&amp;#39;script&amp;#39;)
    script.textContent = &amp;#39;;(&amp;#39; + content.toString() + &amp;#39;)(window)&amp;#39;
    document.documentElement.appendChild(script)
    script.parentNode.removeChild(script)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;跨页面通信&quot;&gt;&lt;a href=&quot;#跨页面通信&quot; class=&quot;headerlink&quot; title=&quot;跨页面通信&quot;&gt;&lt;/a&gt;跨页面通信&lt;/h3&gt;&lt;p&gt;好了，现在我们在页面中注入的脚本已经获取了当前页面下的Regular的实例，并且在Regular的组件发生更新和销毁事件时，Event Emitter都会收到消息。&lt;/p&gt;
&lt;p&gt;大家可以再看一下上面的架构图，页面中的消息要通过Background Script，再由background script发送到devtools page，展现给用户。那我们要如何进行跨页面通信呢。&lt;/p&gt;
&lt;p&gt;首先一个问题就是，如何将消息从用户页面传送到Content Script，刚才强调了，Content Script是运行在沙盒中的，无法直接访问用户页面中的变量。&lt;/p&gt;
&lt;p&gt;不过，幸运的是，&lt;code&gt;window.postMessage()&lt;/code&gt;方法可以解决这个问题。如果你将&lt;code&gt;.postMessage&lt;/code&gt;方法的&lt;code&gt;targetOrigin&lt;/code&gt;参数设置为&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;，那Content Script就会收到这个消息！&lt;/p&gt;
&lt;p&gt;Content Script与Background Script之间的通信可以使用Chrome Extension提供的API&lt;code&gt;chrome.runtime.connect&lt;/code&gt;和&lt;code&gt;chrome.runtime.sendMessage&lt;/code&gt;进行。Background Script与Devtools Page的通信同理。&lt;/p&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h3&gt;&lt;p&gt;Devtools Page中呈现的UI使用了Regular来打造，这些组件根据页面中传来的消息（数据）而呈现不同的状态。&lt;/p&gt;
&lt;p&gt;要想改善UI组件的性能，首先要减少操作DOM节点的频率，也就是减少组件渲染的次数。&lt;/p&gt;
&lt;p&gt;为此，在注入页面的脚本中，我加入了一个&lt;code&gt;debounce&lt;/code&gt;函数，相信大家都不陌生。实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// debounce helper
    var debounce = function(func, wait, immediate) {
        var timeout; //Why is this set to nothing?
        return function() {
            var context = this,
                args = arguments;
            clearTimeout(timeout); // If timeout was just set to nothing, what can be cleared? 
            timeout = setTimeout(function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            }, wait);
            if (immediate &amp;amp;&amp;amp; !timeout) func.apply(context, args); //This applies the original function to the context and to these arguments?
        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数的作用就是将一段时间内发生的多个事件转化为最后一个，起一个缓冲的作用。&lt;/p&gt;
&lt;p&gt;在用户操作Regular组件的过程中，会频繁的发生组件的初始化，销毁，状态更新等事件。一次操作往往能同时触发多个事件。如果我们不进行debounce，那么Devtools UI会频繁的收到消息，造成短时间内的反复渲染，造成页面的卡顿。&lt;/p&gt;
&lt;p&gt;其实用户的一次操作之后，我们只要在Devtools中渲染其最后一次组件状态更新后的组件状态就可以了。所以加入debounce可以明显改善UI的性能。&lt;/p&gt;
&lt;p&gt;Regular Devtools比较特殊的一点，在于页面间消息传递的是JSON数据，因此每一次UI的状态都是全量替换的。如果我直接全量替换所有UI组件的状态，所有组件都会被重新创建，那性能可想而知是很不理想的。&lt;/p&gt;
&lt;p&gt;而且Regular Devtools的UI组件中除了从用户页面中传来的状态，还有UI组件的本地状态，如果直接全量替换一部分状态，那所有组件都会被重新创建，UI组件的本地状态就无法保留下来了。&lt;/p&gt;
&lt;p&gt;对此我的做法是，对老状态对象和新状态对象进行diff，如果部分状态没有改变，则保留其引用。如果状态改变了，是原始值，则直接替换，如果是对象，则递归diff。这样的结果就是，只更新新老状态中不一样的部分，保留相同的部分。&lt;/p&gt;
&lt;p&gt;这样一来，Devtools的UI中只更新状态变化部分对应的UI，不变的部分则保留原样（因为组件状态的引用没有变）。页面上组件再多也不卡了。&lt;/p&gt;
&lt;h3 id=&quot;来自Chrome-Devtools的黑魔法&quot;&gt;&lt;a href=&quot;#来自Chrome-Devtools的黑魔法&quot; class=&quot;headerlink&quot; title=&quot;来自Chrome Devtools的黑魔法&quot;&gt;&lt;/a&gt;来自Chrome Devtools的黑魔法&lt;/h3&gt;&lt;p&gt;Regular Devtools有一个功能，即DOM节点和Regular组件的双向查找。这个是通过Chrome Console CLI的一个API&lt;code&gt;inspect()&lt;/code&gt;实现的。&lt;/p&gt;
&lt;p&gt;原理很简单，向&lt;code&gt;inspect()&lt;/code&gt;中传入DOM节点，Chrome就会检查那个节点。&lt;/p&gt;
&lt;p&gt;至于检查DOM节点反查Regular组件，则也是通过Chrome Console CLI的&lt;code&gt;$0&lt;/code&gt;变量实现的。Console中的&lt;code&gt;$0&lt;/code&gt;变量指向的是最近检查过的DOM节点。拿到这个DOM节点之后，查找它属于哪个Regular组件便可以了。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;Devtools可以提高我们的开发效率，实在是一个很酷的工具。Regular Devtools目前还只有基本的功能。如果你有更好的想法，欢迎参与到Regular Devtools的开发中来！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>发布Regular Developer Tools</title>
    <link href="http://yoursite.com/2016/07/26/annoucing-regular-devtools/"/>
    <id>http://yoursite.com/2016/07/26/annoucing-regular-devtools/</id>
    <published>2016-07-26T10:20:33.000Z</published>
    <updated>2016-07-29T03:04:04.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;a href=&quot;#为什么我们需要开发者工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;/a&gt;为什么我们需要开发者工具？&lt;/h3&gt;&lt;p&gt;现在五花八门的开源前端工具里面，有一些致力于解决前端不够工程化的问题，比如Webpack、Gulp、PostCSS。有些则致力于加强编程语言的特性，比如Babel。而有一部分工具则是为了提高开发者的体验，比如React Devtools、React Hotloader和Redux Devtools。提高开发者体验的工具，从某种角度来说，其实和其他直接参与到前端开发工作流中的工具一样，最终都是为了提高生产力。&lt;/p&gt;
&lt;p&gt;React Devtools已经足够惊艳，而Redux Devtools带来的Time-travel Debugging和React Hotloader的热更新则让人直呼这是黑魔法。&lt;/p&gt;
&lt;p&gt;所以，被这些开发者工具惯坏的我们，怎么能接受Regular没有Devtools的现实呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Regular-Devtools初印象&quot;&gt;&lt;a href=&quot;#Regular-Devtools初印象&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools初印象&quot;&gt;&lt;/a&gt;Regular Devtools初印象&lt;/h3&gt;&lt;p&gt;Regular Devtools是一款Chrome拓展。主要的功能是展示组件树，以及查看每个组件的数据。开发者对组件的操作，造成组件树和数据的变化，都会在Devtools中实时展现。&lt;/p&gt;
&lt;p&gt;比如这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/rdt_demo_ss.gif&quot; alt=&quot;rdt_demo&quot;&gt;&lt;/p&gt;
&lt;p&gt;更强大的是，你可以检查当前组件对应的DOM节点，这个节点会在Chrome Devtools中的Element Tab中出现，就像你平时习惯的右键inspect一样。&lt;/p&gt;
&lt;p&gt;反之，如果你正在检查一个DOM元素，此时你可以切换到Regular Tab，Regular DevTools会自动选中那个DOM节点对应的Regular组件（如果那个DOM节点是Regular组件渲染出的）。&lt;/p&gt;
&lt;p&gt;比如这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/rdt_demo_dom_ss.gif&quot; alt=&quot;rdt_demo&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;p&gt;对Regular Devtools有了初步印象之后，下面就详细介绍一下它的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左侧Element View显示当前页面的Regular组件树，右侧State View显示被选中组件的状态。&lt;/li&gt;
&lt;li&gt;Element View和State View都会随着页面上组件和状态的变化实时更新。&lt;/li&gt;
&lt;li&gt;提供DOM节点和Regular组件的双向查找：可以点击State View中的Inspect查找当前Regular组件对应的DOM节点。&lt;/li&gt;
&lt;li&gt;也可以在Element选项卡中选中DOM节点后切换到Regular选项卡，如果被选中的DOM节点由Regular组件渲染，那么这个Regular节点会被自动选中。&lt;/li&gt;
&lt;li&gt;页面刷新时Devtools会自动重新加载，你也可以通过顶栏右侧的按钮手动重载。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;include&lt;/code&gt;方式被引入的组件将会在组件树中注明，并且在组件树种作为视觉父节点&lt;code&gt;this.$outer&lt;/code&gt;子节点展示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;读到这里，想必你一定蠢蠢欲动了，那就快来体验一下Regular DevTools吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 克隆Regular Devtools&lt;a href=&quot;https://regularjs.github.io/regular-devtools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 打开Chorme的&lt;code&gt;chrome://extensions/&lt;/code&gt;页面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 点击&lt;code&gt;Load unpacked extension···&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 4&lt;/strong&gt; 选择你刚刚克隆的仓库文件夹&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 大功告成!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开一个使用了Regular组件的页面，打开Chrome Devtools，选择Regular选项卡，如果一切顺利，你将在左边的Element View看到当前页面的组件树，然后就可以开始愉快的开发了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，你的项目必须使用&lt;a href=&quot;https://regularjs.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular v0.4.5&lt;/a&gt;或更高的版本&lt;br&gt;如果你手头上没有使用最新版Regular的项目，可以先拿这个&lt;a href=&quot;https://regularjs.github.io/regular-devtools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular Todo例子&lt;/a&gt;尝鲜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开发手记&quot;&gt;&lt;a href=&quot;#开发手记&quot; class=&quot;headerlink&quot; title=&quot;开发手记&quot;&gt;&lt;/a&gt;开发手记&lt;/h3&gt;&lt;p&gt;对这款Devtools的技术实现有兴趣的同学可以浏览&lt;a href=&quot;http://zxc0328.github.io/2016/07/28/regular-devtools-thought/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Regular Devtools开发手记&lt;/a&gt;这篇博客。&lt;/p&gt;
&lt;h3 id=&quot;已知的问题&quot;&gt;&lt;a href=&quot;#已知的问题&quot; class=&quot;headerlink&quot; title=&quot;已知的问题&quot;&gt;&lt;/a&gt;已知的问题&lt;/h3&gt;&lt;p&gt;这些问题主要是由于某些特殊组件&lt;code&gt;$outer&lt;/code&gt;属性的指向和正常组件不同造成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有&lt;code&gt;isolate&lt;/code&gt;属性的组件将不会出现在组件树中，其内嵌组件会正常显示。&lt;/li&gt;
&lt;li&gt;Regular-dnd中的&lt;code&gt;Draggable&lt;/code&gt;和&lt;code&gt;Droppable&lt;/code&gt;组件的内嵌组件会和父组件显示在同一个层级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;关于我&quot;&gt;&lt;a href=&quot;#关于我&quot; class=&quot;headerlink&quot; title=&quot;关于我&quot;&gt;&lt;/a&gt;关于我&lt;/h3&gt;&lt;p&gt;网易有数前端实习生&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;a href=&quot;#为什么我们需要开发者工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要开发者工具？&quot;&gt;&lt;/a&gt;为什么我们需要开发者工具？&lt;/h3&gt;&lt;p&gt;现在五花八门的开源前端工具里面，有一些致力于解决前端不够工程化的问题，比如Webpack、Gulp、PostCSS。有些则致力于加强编程语言的特性，比如Babel。而有一部分工具则是为了提高开发者的体验，比如React Devtools、React Hotloader和Redux Devtools。提高开发者体验的工具，从某种角度来说，其实和其他直接参与到前端开发工作流中的工具一样，最终都是为了提高生产力。&lt;/p&gt;
&lt;p&gt;React Devtools已经足够惊艳，而Redux Devtools带来的Time-travel Debugging和React Hotloader的热更新则让人直呼这是黑魔法。&lt;/p&gt;
&lt;p&gt;所以，被这些开发者工具惯坏的我们，怎么能接受Regular没有Devtools的现实呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ninja:dev server made easy</title>
    <link href="http://yoursite.com/2016/07/05/ninja/"/>
    <id>http://yoursite.com/2016/07/05/ninja/</id>
    <published>2016-07-05T12:32:43.000Z</published>
    <updated>2016-07-14T08:16:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Muxi-Studio/ninja&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ninja&lt;/a&gt;是一款用于前后端分离开发的本地开发服务器，也被称为是前端容器。它有以下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML、CSS的热重载&lt;/li&gt;
&lt;li&gt;根据配置文件自动生成路由&lt;/li&gt;
&lt;li&gt;根据配置文件自动读取在线/本地的虚拟数据&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Jinja2&lt;/code&gt;语法（以及其他Nodejs模板）&lt;/li&gt;
&lt;li&gt;支持路由代理&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;webpack&lt;/code&gt;（通过&lt;code&gt;webpack-dev-middleware&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Ninja的前世今生&quot;&gt;&lt;a href=&quot;#Ninja的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Ninja的前世今生&quot;&gt;&lt;/a&gt;Ninja的前世今生&lt;/h3&gt;&lt;p&gt;在木犀，之前我们的前后端分离开发方案是这样的：在本地运行一个简单的&lt;code&gt;Flask&lt;/code&gt;应用，只包含路由，在路由中读取虚拟数据并渲染&lt;code&gt;Jinja2&lt;/code&gt;模板，然后运行这个应用，进行开发。前端模板开发完成后和后端直接对接调试。&lt;/p&gt;
&lt;p&gt;这种方案有一些明显的问题，首先是这个&lt;code&gt;Flask&lt;/code&gt;应用没法规范化为一个命令或是一个包，这就需要我们每次在构建前端仓库时都手动写路由等逻辑，这显然是不现实的。还有一个问题就是，&lt;code&gt;Flask&lt;/code&gt;的Python环境与目前前端工具生态的主流Nodejs格格不入，想要接入&lt;code&gt;webpack&lt;/code&gt;等前端工具，我们必须使用Nodejs来构建我们的dev server。&lt;/p&gt;
&lt;p&gt;于是我们需要一款能支持&lt;code&gt;Jinja2&lt;/code&gt;语法，同时又能满足前端开发各种需要的dev server。Ninja就在这个节点上横空出世了！&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;Ninja的上手非常简单，首先安装Ninja&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g ninja_cli
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面以Ninja和Webpack一起使用为例，这个例子的源代码在Ninja仓库的&lt;a href=&quot;https://github.com/Muxi-Studio/ninja/tree/master/example/ninja_webpack_example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;example文件夹&lt;/code&gt;&lt;/a&gt;下可以找到。&lt;/p&gt;
&lt;p&gt;首先我们需要一个&lt;code&gt;ninja.conf.js&lt;/code&gt;配置文件，当然你也可以选择用命令行参数配置。在这个文件里我们要配置一些必要的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    template: &amp;quot;swig&amp;quot;, // 模板引擎名
    mock: &amp;quot;/mock/mock.json&amp;quot;, // 虚拟数据位置
    webpack: true, // 启用webpack支持
    templateDir: &amp;quot;/template&amp;quot;, // 模板文件目录
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在webpack的配置里要注意&lt;code&gt;entry&lt;/code&gt;和&lt;code&gt;output&lt;/code&gt;的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  entry: [
    path.resolve(__dirname, &amp;#39;./index.js&amp;#39;)
  ],
  output: {
    path: &amp;#39;/&amp;#39;,
    publicPath: &amp;#39;http://localhost:3000/&amp;#39;,
    filename: &amp;#39;bundle.js&amp;#39;
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;webpack的中间件提供静态文件，我们可以在Ninja的3000端口访问到，所以在模板中的静态文件路径可以写&lt;code&gt;/&lt;/code&gt;+文件名。如&lt;code&gt;&amp;lt;script src=&amp;quot;/bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置好Webpack之后，我们写两个简单的模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// base.html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Ninja Test&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;I&amp;#39;m the head&amp;lt;/h2&amp;gt;
    {% block content %}{% endblock %}
	&lt;a href=&quot;/&quot;&gt;index page&lt;/a&gt;
	&lt;a href=&quot;/second&quot;&gt;second page&lt;/a&gt;
	&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;



// second.html
{% extends &#39;base.html&#39; %}
{% block content %}
	&lt;p&gt;{{ title }}&lt;/p&gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后写一个mock文件&lt;code&gt;/mock/mock.json&lt;/code&gt;，配置路由和虚拟数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;routes&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/&amp;quot;,
            &amp;quot;template&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;async&amp;quot;: false // 同步路由
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;second&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/second&amp;quot;,
            &amp;quot;template&amp;quot;: &amp;quot;home&amp;quot;,
            &amp;quot;async&amp;quot;: false
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;api.courses&amp;quot;,
            &amp;quot;endpoint&amp;quot;: &amp;quot;/api/v1.0/courses&amp;quot;,
            &amp;quot;async&amp;quot;: true // 异步路由（API）
        }
    ],
    &amp;quot;data&amp;quot;:{
        &amp;quot;home&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;hello&amp;quot;
        },
        &amp;quot;second&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;second&amp;quot;
        },
        &amp;quot;api.courses&amp;quot;:{
            &amp;quot;title&amp;quot;: &amp;quot;second&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后启动Ninja&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ninja
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后Ninja会自动用Chrome打开&lt;code&gt;http://localhost:3000/&lt;/code&gt;。并显示我们首页模板。大功告成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqk8r.com1.z0.glb.clouddn.com/ninja_start.gif&quot; alt=&quot;ninja_start&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发手记&quot;&gt;&lt;a href=&quot;#开发手记&quot; class=&quot;headerlink&quot; title=&quot;开发手记&quot;&gt;&lt;/a&gt;开发手记&lt;/h3&gt;&lt;p&gt;Ninja的主体就是一个Express server，读取配置文件然后生成路由，填入虚拟数据和模板。Livereload使用了&lt;code&gt;connect-inject&lt;/code&gt;做模板的JS注入。用&lt;code&gt;socket.io&lt;/code&gt;做浏览器与Ninja的实时通信。至于Webpack的集成，直接使用官方的&lt;code&gt;webpack-dev-middleware&lt;/code&gt;和&lt;code&gt;webpack-hot-middleware&lt;/code&gt;就可以轻松达成。&lt;/p&gt;
&lt;p&gt;总体来说没有遇到太大的困难，当然也可能是因为使用了大量的三方库。&lt;code&gt;@朱承浩&lt;/code&gt;同学建议Ninja的Web server部分可以自己实现，没必要使用&lt;code&gt;Express&lt;/code&gt;。我认为JS注入应该也可以自己实现。所以后期可以将这些部分替换为自己的实现。&lt;/p&gt;
&lt;p&gt;Ninja是我第一次尝试些CLI应用，也是第一次尝试写前端工具。在功能上借鉴了&lt;a href=&quot;https://github.com/leeluolee/puer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;puer&lt;/code&gt;&lt;/a&gt;（但是没看代码，看不懂Coffee Script），在前后端分离的理念上借鉴了&lt;a href=&quot;https://github.com/NEYouFan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NEI&lt;/code&gt;&lt;/a&gt;。在这个过程中我最大的发现是Node生态圈的繁荣，基本上想要的功能都有相应的NPM包封装好了。这次用了&lt;a href=&quot;https://github.com/tj/commander&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;commander&lt;/code&gt;&lt;/a&gt;做命令行参数的文档生成，&lt;a href=&quot;https://github.com/chalk/chalk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;chalk&lt;/code&gt;&lt;/a&gt;给&lt;code&gt;console.log&lt;/code&gt;加颜色，&lt;a href=&quot;https://github.com/tj/consolidate.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;consolidate&lt;/code&gt;&lt;/a&gt;来统一Node模板调用，&lt;a href=&quot;https://github.com/sindresorhus/opn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;opn&lt;/code&gt;&lt;/a&gt;用来打开浏览器。随着我Node水平的提升，在今后的开发中，会尽量少用不必要的三方库。&lt;/p&gt;
&lt;h3 id=&quot;展望&quot;&gt;&lt;a href=&quot;#展望&quot; class=&quot;headerlink&quot; title=&quot;展望&quot;&gt;&lt;/a&gt;展望&lt;/h3&gt;&lt;p&gt;Ninja目前的版本号是&lt;code&gt;0.1&lt;/code&gt;，等稳定之后会放出&lt;code&gt;1.0&lt;/code&gt;版。后续版本会加入subcommand，加入脚手架功能，一键搭建前端目录建构和配置文件。云端Mock数据平台也要做相应的跟进。&lt;/p&gt;
&lt;p&gt;总之，Ninja是木犀前后端分离开发实践一个进步。这仅仅只是一个开始，希望大家一起努力，提高开发的效率和开发者的体验。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Muxi-Studio/ninja&quot;&gt;Ninja&lt;/a&gt;是一款用于前后端分离开发的本地开发服务器，也被称为是前端容器。它有以下一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML、CSS的热重载&lt;/li&gt;
&lt;li&gt;根据配置文件自动生成路由&lt;/li&gt;
&lt;li&gt;根据配置文件自动读取在线/本地的虚拟数据&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Jinja2&lt;/code&gt;语法（以及其他Nodejs模板）&lt;/li&gt;
&lt;li&gt;支持路由代理&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;webpack&lt;/code&gt;（通过&lt;code&gt;webpack-dev-middleware&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 FEDay见闻录</title>
    <link href="http://yoursite.com/2016/03/19/2016-feday/"/>
    <id>http://yoursite.com/2016/03/19/2016-feday/</id>
    <published>2016-03-19T14:27:24.000Z</published>
    <updated>2016-03-21T08:15:41.000Z</updated>
    
    <content type="html">&lt;p&gt;这次FEDay是我第一次参加开发者大会，也是第一次去广州。当初主要是冲着两个Facebook的工程师去的，因为我对React好感度很高。总的来说这次的收获还是很多的，也算是值回票价了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Universal-Applications-by-Stephan&quot;&gt;&lt;a href=&quot;#Universal-Applications-by-Stephan&quot; class=&quot;headerlink&quot; title=&quot;Universal Applications by Stephan&quot;&gt;&lt;/a&gt;Universal Applications by Stephan&lt;/h3&gt;&lt;p&gt;首先是FB的&lt;a href=&quot;https://twitter.com/stopachka&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stephan&lt;/a&gt;分享Universal Applications。Stephan会说中文，应该是他在台湾待过一段时间的原因。这里有个小插曲就是会场安排了一名翻译，Stephan说一句翻译就翻译一下，这样真的非常的多余。本来是想来听一下原汁原味的国外工程师分享的，结果还是打了折扣。&lt;/p&gt;
&lt;p&gt;Stephan说的Universal Applications我之前在开发Readme的时候使用过一部分。就是在服务器端用react-dom的&lt;code&gt;renderToString&lt;/code&gt;方法生成字符串。同时也运行了Redux的代码，根据客户端传来的state生成了相应的UI。&lt;/p&gt;
&lt;p&gt;不过Universal Applications并没有这么简单。这种开发模式总的来说就是写一套代码，在客户端和服务端同时可用。服务端UI的渲染我们已经通过&lt;code&gt;renderToString&lt;/code&gt;解决了。服务端的路由可以通过react-router的&lt;code&gt;match&lt;/code&gt;函数来运行相应的UI组件渲染逻辑。而数据获取API的差异可以通过&lt;code&gt;isomorphic-fetch&lt;/code&gt;这个库来抹平。&lt;/p&gt;
&lt;h3 id=&quot;微信WebApp最佳实践-by-江剑锋&quot;&gt;&lt;a href=&quot;#微信WebApp最佳实践-by-江剑锋&quot; class=&quot;headerlink&quot; title=&quot;微信WebApp最佳实践 by 江剑锋&quot;&gt;&lt;/a&gt;微信WebApp最佳实践 by 江剑锋&lt;/h3&gt;&lt;p&gt;说实话我之前对微信前端的工作不是很了解。看了这个分享之后我清楚多了，微信的前端做的也就是普通前端的事情，并没有涉及前端之外的部分。这个工作有点类似于淘宝无线。不过淘宝这个App的混合程度更高一些，而微信里面的Web和原生的内容之间的分离比较明显，这和微信的特点有关系。&lt;/p&gt;
&lt;p&gt;微信主要是为Web内容搭建了一个平台，也就是微信公众号。和原生的交互主要通过JS-SDK来实现。说实话这种开发模式是在世界上很少有的，算是微信的独创。目前Web内容一般来说会以原生的App为平台，而对于众多的普通开发者来说，微信是最好的开放平台。WebApp借微信这个超级App得以迅速的传播。打造了一个生态圈。所以微信Web开发现在已经成为了小公司前端的一个日常开发内容，现场有大量做过微信Web开发的前端同学，这个平台的体量可见一斑。&lt;/p&gt;
&lt;p&gt;首先我们看了微信的一些用户数据，前十位的机型里面除了三星之外就是小米。安卓系统版本有不少。因此微信内嵌的X5内核的目的就是抹平这些系统里自带的WebView的差异。&lt;/p&gt;
&lt;p&gt;我们在开发微信WebApp的过程中会遇到一些问题，这些多数和微信内嵌的X5内核有关。比如强制缓存，不仅会缓存CSS等资源，还会缓存HTML。要避免这个问题我们可以在URL后加参数。&lt;/p&gt;
&lt;p&gt;另外还讲了一些普遍的问题，比如动画卡顿，flex部分支持。Video的&lt;code&gt;autoplay&lt;/code&gt;无效和&lt;code&gt;control&lt;/code&gt;条无法隐藏，&lt;code&gt;autoplay&lt;/code&gt;无法使用是因为产品策略，让用户有选择权。如果一定要使用则可以监听&lt;code&gt;WXJSBridgeReady&lt;/code&gt;事件。Cookie和localStorage偶尔失效这个问题我还没有遇到过，江剑锋表示客户端存储本来就是不可靠的存储，所以我们要做相应的准备。&lt;/p&gt;
&lt;p&gt;接着介绍了WeUI，以及相应的jQuery,react,vue的binding。还有微信的一些调试工具。&lt;/p&gt;
&lt;p&gt;最后放了一个消息出来，那就是微信的内核将改用Blink。这样上述的问题都将得到解决，除了&lt;code&gt;autoplay&lt;/code&gt;依然是按照原来的策略。&lt;/p&gt;
&lt;h3 id=&quot;React-Tips-by-黄士旗&quot;&gt;&lt;a href=&quot;#React-Tips-by-黄士旗&quot; class=&quot;headerlink&quot; title=&quot;React Tips by 黄士旗&quot;&gt;&lt;/a&gt;React Tips by 黄士旗&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/huang47&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;黄士旗&lt;/a&gt;是台湾人，目前在Facebook工作。他的React Tips的内容主要包括了Container Component和UI Component，HOC高阶函数，Array的函数式API等。&lt;/p&gt;
&lt;p&gt;第一次了解Container Component和UI Component这个概念是在一些React boilerplate里以及Dan Abramov的Redux教程里。Dan的&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.kv5gzrgje&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;讲了这个问题。于是我在自己的Redux项目里也把组件分为UI组件和Container组件。简单的说，UI组件是Stateless function，只负责根据传入的数据返回UI组件，具有很高的可复用性。而Container组件则是负责处理数据，具有一些业务逻辑，基本是不可复用的（也不用考虑去复用）。&lt;/p&gt;
&lt;p&gt;UI组件的类型很多，如何达到进一步的复用呢？这里黄士旗引入了HOC的概念。我们用HOC作为一个装饰器，传入的UI组件被附加一些UI元素后返回，从而实现了更好程度的复用。我们可以用一个Base UI组件加上各色装饰器来渲染不同类型的UI组件。一个装饰器大概就是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function makeEditale(baseCompoennt){
    return &amp;lt;div&amp;gt;
                &amp;lt;input /&amp;gt;
                &amp;lt;baseCompoennt /&amp;gt;
            &amp;lt;/div&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前我接触过ES7的装饰器，那就是一个class的语法糖，原理和这个是一样的。总之这里我们的原则就是Composition Over Inheritance。&lt;/p&gt;
&lt;p&gt;最后黄士旗介绍了Array的&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;API的使用。这些函数式特性的API和React就是天作之合。在各种场合都很好用。&lt;/p&gt;
&lt;h3 id=&quot;下一代Web技术运用-by-陈子舜&quot;&gt;&lt;a href=&quot;#下一代Web技术运用-by-陈子舜&quot; class=&quot;headerlink&quot; title=&quot;下一代Web技术运用 by 陈子舜&quot;&gt;&lt;/a&gt;下一代Web技术运用 by 陈子舜&lt;/h3&gt;&lt;p&gt;陈子舜是腾讯云的技术总监，他分享的内容主要是提前运用下一代Web技术来提升Web性能。&lt;/p&gt;
&lt;p&gt;在过往，前端面试中提到Web性能，我们总会提到雅虎的35条前端性能优化定律这些。而这些规则在移动端Web开发占主流和新技术出现的情况下是否还适用呢？&lt;/p&gt;
&lt;p&gt;前端性能的要求就是我们的首屏必须在1s内渲染，这点我们可以通过Offline Caching来助力。&lt;/p&gt;
&lt;p&gt;子舜举了QQ红包的例子。红包相关的代码是用Web技术写的，但是这些代码不能在需要时拉取，而是应该提前拉取并缓存在本地。这一点和Google在推的Progressive App异曲同工。Google IO的IOWA是可以离线使用的。&lt;/p&gt;
&lt;p&gt;我们看到现在的离线存储技术有很多种，比如Application Cache和Service Worker。QQ红包中的离线存储是通过Native代码实现的。这些以后可以通过Service Worker来在Web端实现。Service Worker在目前还没有被主流浏览器实现，但这会是未来的方向。&lt;/p&gt;
&lt;h3 id=&quot;前端能力的培养-by-Winter&quot;&gt;&lt;a href=&quot;#前端能力的培养-by-Winter&quot; class=&quot;headerlink&quot; title=&quot;前端能力的培养 by Winter&quot;&gt;&lt;/a&gt;前端能力的培养 by Winter&lt;/h3&gt;&lt;p&gt;Winter的那套理论我之前在看他画“前端校招重点“的时候就看到过。主要就是20%的知识加上80%的能力。&lt;/p&gt;
&lt;p&gt;在说20%的知识的时候，Winter说他看Python语法的文档来学语法。然后通过查论文来了解闭包的概念。总之就是，学知识需要看最权威的东西，追根溯源，搞清问题的本质。&lt;/p&gt;
&lt;p&gt;80%的能力分为工程能力，架构能力，编程能力。这些就是靠大量的练习来达到的。一万小时理论看起来有些恐怖，那就从每周20小时开始努力吧。就算是这样，也可以达到一个很不错的水平。&lt;/p&gt;
&lt;h3 id=&quot;HTTP-2时代的Web性能-by-Holger-Bartel&quot;&gt;&lt;a href=&quot;#HTTP-2时代的Web性能-by-Holger-Bartel&quot; class=&quot;headerlink&quot; title=&quot;HTTP/2时代的Web性能 by Holger Bartel&quot;&gt;&lt;/a&gt;HTTP/2时代的Web性能 by Holger Bartel&lt;/h3&gt;&lt;p&gt;Holger的分享还是很给力的，主要讲了HTTP/2和HTTP/1.1之间的区别，以及我们应该如何在HTTP/2中进行性能优化。以及如何在今天就开始使用HTTP/2。&lt;/p&gt;
&lt;p&gt;其中性能优化方面，在HTTP/2时代，我们不需要合并文件了，也不需要inline CSS/image以及分离资源的域名。至于雪碧图，压缩这些工序，还是需要的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次FEDay是我第一次参加开发者大会，也是第一次去广州。当初主要是冲着两个Facebook的工程师去的，因为我对React好感度很高。总的来说这次的收获还是很多的，也算是值回票价了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FEDay" scheme="http://yoursite.com/tags/FEDay/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s build a jQuery!-Part 1(early release)</title>
    <link href="http://yoursite.com/2016/03/11/let-s-build-a-jQuery/"/>
    <id>http://yoursite.com/2016/03/11/let-s-build-a-jQuery/</id>
    <published>2016-03-11T09:24:00.000Z</published>
    <updated>2016-06-15T10:56:00.000Z</updated>
    
    <content type="html">&lt;p&gt;这个系列博客的灵感来源于&lt;a href=&quot;https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;和一次失败的&lt;a href=&quot;https://github.com/zxc0328/litejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;造轮子&lt;/a&gt;经历。出于对jQuery进行源码分析和让旧日作品发挥余热的目的，我开始写这一系列博客。主要内容就是从头开始打造一个jQuery-like的基础库，并且配上相应的源码，也就是我们的Litejs。&lt;/p&gt;
&lt;p&gt;我们要做的工作有以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器和元素封装&lt;/li&gt;
&lt;li&gt;DOM操作&lt;/li&gt;
&lt;li&gt;Ajax请求&lt;/li&gt;
&lt;li&gt;事件系统&lt;/li&gt;
&lt;li&gt;触摸事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应这系列文章的四个部分。&lt;/p&gt;
&lt;p&gt;好，让我们开启这段神奇的重复造轮子之旅吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;开发环境的搭建&quot;&gt;&lt;a href=&quot;#开发环境的搭建&quot; class=&quot;headerlink&quot; title=&quot;开发环境的搭建&quot;&gt;&lt;/a&gt;开发环境的搭建&lt;/h3&gt;&lt;p&gt;我们使用ES6的模块语法编写模块，并使用&lt;a href=&quot;http://rollupjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rollup.js&lt;/a&gt;打包，rollup是基于ES6模块的JS打包工具。我对于rollup的思考可以参考。除此之外我们还是用Babel和Flow。Flow是Facebook出品的JavaScript静态类型检查工具，我们用Babel来去除Flow的类型标记，以及编译其他的ES6特性代码。&lt;/p&gt;
&lt;p&gt;// todo 测试环境搭建&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout 1-1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;jQuery的组织架构&quot;&gt;&lt;a href=&quot;#jQuery的组织架构&quot; class=&quot;headerlink&quot; title=&quot;jQuery的组织架构&quot;&gt;&lt;/a&gt;jQuery的组织架构&lt;/h3&gt;&lt;p&gt;简单的说，jQueryAPI由&lt;code&gt;jQuery&lt;/code&gt;构造函数以及&lt;code&gt;jQuery&lt;/code&gt;函数上的一系列静态API组成。&lt;code&gt;jQuery&lt;/code&gt;构造函数就是我们平常使用的&lt;code&gt;$&lt;/code&gt;函数，这个函数接收选择器字符串作为参数，返回jQuery对象实例。jQuery对象封装了原生的DOM对象，为其添加了一系列的属性和方法，以及链式调用的能力。&lt;/p&gt;
&lt;p&gt;与此同时，因为JavaScript的函数也是对象，因此我们可以在函数上添加属性和方法。函数是对象，因此也可以访问对象原型的方法。&lt;code&gt;jQuery&lt;/code&gt;函数上的静态方法，包括了回调、AJAX、事件、动画、工具函数等jQuery API。另一些API，比如DOM相关的API，则是绑定在&lt;code&gt;jQuery&lt;/code&gt;构造函数实例化出来的对象上。&lt;/p&gt;
&lt;h4 id=&quot;lite构造函数&quot;&gt;&lt;a href=&quot;#lite构造函数&quot; class=&quot;headerlink&quot; title=&quot;lite构造函数&quot;&gt;&lt;/a&gt;&lt;code&gt;lite&lt;/code&gt;构造函数&lt;/h4&gt;&lt;p&gt;下面就让我们开始编写我们的自制&lt;code&gt;jQuery&lt;/code&gt;—&lt;code&gt;litejs&lt;/code&gt;。让我们来编写我们的第一个函数，&lt;code&gt;lite&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// The lite constructor function
var lite = function( selector, context ) {
  return new lite.prototype.init( selector, context );
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数很简单，调用了&lt;code&gt;lite.fn.init&lt;/code&gt;函数，传入了选择器和上下文，并返回实例化的对象。让我们来看看真正干活的&lt;code&gt;lite.prototype.init&lt;/code&gt;函数。&lt;/p&gt;
&lt;h4 id=&quot;lite-prototype-init&quot;&gt;&lt;a href=&quot;#lite-prototype-init&quot; class=&quot;headerlink&quot; title=&quot;lite.prototype.init&quot;&gt;&lt;/a&gt;&lt;code&gt;lite.prototype.init&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;我们之前说过，&lt;code&gt;lite&lt;/code&gt;构造函数也是个对象，我们把一些静态方法都放在这个对象的原型上。其中就有&lt;code&gt;init&lt;/code&gt;方法。我们先不急着看这个方法做了什么，我们在这里要做一个特殊的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lite.prototype.init.prototype = lite.prototype;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很简单，因为&lt;code&gt;lite.prototype.init&lt;/code&gt;方法返回的实例无法访问到&lt;code&gt;lite&lt;/code&gt;函数的原型链，所以我们设置这个对象构造函数的原型是&lt;code&gt;lite.prototype&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;lite-extend&quot;&gt;&lt;a href=&quot;#lite-extend&quot; class=&quot;headerlink&quot; title=&quot;lite.extend()&quot;&gt;&lt;/a&gt;&lt;code&gt;lite.extend()&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;lite.extend()&lt;/code&gt;其实就是我们常说的&lt;code&gt;mixin&lt;/code&gt;函数&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列博客的灵感来源于&lt;a href=&quot;https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html&quot;&gt;这篇博客&lt;/a&gt;和一次失败的&lt;a href=&quot;https://github.com/zxc0328/litejs&quot;&gt;造轮子&lt;/a&gt;经历。出于对jQuery进行源码分析和让旧日作品发挥余热的目的，我开始写这一系列博客。主要内容就是从头开始打造一个jQuery-like的基础库，并且配上相应的源码，也就是我们的Litejs。&lt;/p&gt;
&lt;p&gt;我们要做的工作有以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器和元素封装&lt;/li&gt;
&lt;li&gt;DOM操作&lt;/li&gt;
&lt;li&gt;Ajax请求&lt;/li&gt;
&lt;li&gt;事件系统&lt;/li&gt;
&lt;li&gt;触摸事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应这系列文章的四个部分。&lt;/p&gt;
&lt;p&gt;好，让我们开启这段神奇的重复造轮子之旅吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="jQuery JavaScript" scheme="http://yoursite.com/tags/jQuery-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题总结（持续更新）</title>
    <link href="http://yoursite.com/2016/03/11/front-end-interview/"/>
    <id>http://yoursite.com/2016/03/11/front-end-interview/</id>
    <published>2016-03-11T08:51:36.000Z</published>
    <updated>2016-04-04T08:27:39.000Z</updated>
    
    <content type="html">&lt;p&gt;接下来要参与大大小小的暑期实习笔试和面试。在这篇博客里我将总结一些常见的面试题。其中有一部分是我去年暑假找实习的时候总结的。现在看来，不免有些幼稚。慢慢完善吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;JS中的闭包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：闭包从本身在函数式编程中的概念来说，说的是在定义函数时的两部分-函数体和函数的&lt;code&gt;context&lt;/code&gt;，也就是函数定义时的上下文。里面保存着作用域中的变量，函数的定义和赋值。&lt;/p&gt;
&lt;p&gt;而我们平时说的闭包，其实是创建对于这个上下文的引用，从而在外部作用域中通过这个引用来访问这个上下文。&lt;/p&gt;
&lt;p&gt;所以从概念上来说，你声明了一个函数，就声明了一个闭包。&lt;/p&gt;
&lt;p&gt;然后从实际的使用来说，当你通过某种代码对在外部作用域中保存了对当前闭包的引用时，我们说你就“创建”了一个闭包，其实是“创建”了一个&lt;strong&gt;闭包的引用&lt;/strong&gt;。我们通常用IIFE来达到这一效果，以至于有人认为IIFE就是“闭包”，这其实是不正确的认识。&lt;/p&gt;
&lt;p&gt;这就是闭包的实质，至于如何去使用闭包，那就五花八门了。你可以用来保存被外部作用域访问的临时变量，也可以用来封装函数，也可以用来做访问权限控制（类似Java中的私有变量）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么我们需要JS模块化&lt;/li&gt;
&lt;li&gt;JS模块化的发展过程（从function，IIFE到Commonjs）&lt;/li&gt;
&lt;li&gt;JS模块化的几种方案介绍（Commonjs，AMD，ES6 Module）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS中使用new关键字构造对象实例的过程&lt;/strong&gt;&lt;br&gt;A：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject.construct = function() {
    var o = {}, Constructor = MyObject;
    o.__proto__ = Constructor.prototype;
    // FF 支持用户引用内部属性 [[Prototype]]

    Constructor.apply(o, arguments);
    return o;
};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;JS性能优化&lt;/strong&gt;&lt;br&gt;A： to be done&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;CSS position的不同取值以及差异？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：取值：static（默认），relative，absolute，fixed。差异，relative：相对于其自身进行定位，不脱离文档流。absolute：相对于父元素链上的第一个已定位元素，如果不存在则相对于body。脱离文档流。fixed，相对于浏览器窗口进行定位，脱离文档流。static：正常的文档流定位。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS 盒模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;W3C 默认&lt;code&gt;content-box&lt;/code&gt;，ie5-、ie6 Quirks mode &lt;code&gt;border-box&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-box&lt;/code&gt;：csswidth = content width&lt;/li&gt;
&lt;li&gt;&lt;code&gt;border-box&lt;/code&gt;: csswidth = content width + padding +border&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS选择器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：元素，类，id，属性，伪类，伪元素。···&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;CSS hack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：选择器hack（-webkit-,-moz-）,属性hack，IE条件注释&lt;/p&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;web语义化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;br&gt;html5新标签：&lt;code&gt;&amp;lt;header&amp;gt;&amp;lt;footer&amp;gt;&amp;lt;nav&amp;gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;br&gt;Microformat：标准化的css类名，方便搜索引擎对页面内容进行索引。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;Doctype&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染。html中为&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h2&gt;&lt;h2 id=&quot;前端性能&quot;&gt;&lt;a href=&quot;#前端性能&quot; class=&quot;headerlink&quot; title=&quot;前端性能&quot;&gt;&lt;/a&gt;前端性能&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;页面加载速度优化？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从http请求上来说，减少http请求数（合并css，js，sprite图，或者使用阿里的一个请求多个文件技术），但是合并请求不利于浏览器缓存。适当的请求数可以充分利用并发连接（瀑布图）并利用好缓存。减小文件的大小（压缩css，js，图片）。CDN加速等。&lt;/li&gt;
&lt;li&gt;从浏览器渲染的角度来说，把js放在&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;之前，在DOM加载完成后加载js。CSS动画用&lt;code&gt;transform&lt;/code&gt;而不是js和绝对定位。&lt;/li&gt;
&lt;li&gt;服务器端，充分利用缓存。使用hash更新文件。Gzip压缩。&lt;/li&gt;
&lt;li&gt;性能检测工具。WebPagetest。Chrome DevTools。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;HTTP GET POST的不同？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET是把参数加到URL中，在URL中可以看到。POST将表单内容放置在HTTP request body中。&lt;/li&gt;
&lt;li&gt;在RESTful的api设计中，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：&lt;strong&gt;HTTP状态码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：200 ok，304 not modified，404 not found，403 forbidden，500 internal server error， 503 Service Unavailable等。&lt;/p&gt;
&lt;h2 id=&quot;安全&quot;&gt;&lt;a href=&quot;#安全&quot; class=&quot;headerlink&quot; title=&quot;安全&quot;&gt;&lt;/a&gt;安全&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;Web安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：XSS，CSRF，SQL注入等。具体可以看一些前端安全相关的书，初步了解。有实战最佳。&lt;/p&gt;
&lt;h2 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; class=&quot;headerlink&quot; title=&quot;浏览器&quot;&gt;&lt;/a&gt;浏览器&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;描述在浏览器中输入url到网页加载完成的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器查看缓存，如果有为过期的资源则直接返回该资源。&lt;/li&gt;
&lt;li&gt;若缓存没有所需的资源，浏览器解析url，组装一个http请求。&lt;/li&gt;
&lt;li&gt;浏览器获取主机ip地址，查询链从浏览器缓存，本机缓存，路由器缓存，到dns服务器缓存，进入dns查询链&lt;/li&gt;
&lt;li&gt;获得主机的ip地址后，与目标ip建立tcp连接，发送http请求&lt;/li&gt;
&lt;li&gt;tcp/ip 7层模型&lt;/li&gt;
&lt;li&gt;服务器端处理，web服务器，web端处理程序，返回http response&lt;/li&gt;
&lt;li&gt;浏览器接收http reponse 并根据状态码不同做出不同的处理&lt;/li&gt;
&lt;li&gt;根据资源类型决定处理方式，如果是html文档，则构建DOM树，下载资源，构造CSS om树，执行js脚本。&lt;/li&gt;
&lt;li&gt;DOM树：&lt;br&gt;Tokenizing：根据HTML规范将字符流解析为标记&lt;br&gt;Lexing：词法分析将标记转换为对象并定义属性和规则&lt;br&gt;DOM construction：根据HTML标记关系将对象组成DOM树&lt;/li&gt;
&lt;li&gt;CSS OM（object model）树：&lt;br&gt;Tokenizing：字符流转换为标记流&lt;br&gt;Node：根据标记创建节点&lt;br&gt;CSSOM：节点创建CSSOM树&lt;/li&gt;
&lt;li&gt;根据DOM树和CSS om树构建渲染树 render object&lt;br&gt;从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。&lt;br&gt;2)被css隐藏的节点，如display: none&lt;br&gt;对每一个可见节点，找到恰当的CSSOM规则并应用&lt;br&gt;发布可视节点的内容和计算样式&lt;/li&gt;
&lt;li&gt;js解析&lt;br&gt;浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading&lt;br&gt;此时HTML解析器遇到同步script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。&lt;br&gt;浏览器在Document对象上触发DOMContentLoaded事件&lt;br&gt;此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件&lt;/li&gt;
&lt;li&gt;页面显示&lt;br&gt;（关于这个问题的浏览器渲染方面，看webkit技术内幕比较好，我觉得这本书也算是高阶前端必看的一本）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;p&gt;Q：平时如何学习前端？&lt;/p&gt;
&lt;p&gt;A：&lt;br&gt;答案因人而异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术书籍。英文为主，中文为辅。&lt;/li&gt;
&lt;li&gt;信息流-微博，推特等上面的技术博客和文章。&lt;/li&gt;
&lt;li&gt;学框架使用-看官方文档。&lt;/li&gt;
&lt;li&gt;学框架原理-看源码，仿照轮子。&lt;/li&gt;
&lt;li&gt;专题分析，写博客总结或者写demo总结。&lt;/li&gt;
&lt;li&gt;技术会议。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Q：Web无障碍？&lt;br&gt;A：to be done&lt;/p&gt;
&lt;h2 id=&quot;智力题&quot;&gt;&lt;a href=&quot;#智力题&quot; class=&quot;headerlink&quot; title=&quot;智力题&quot;&gt;&lt;/a&gt;智力题&lt;/h2&gt;&lt;p&gt;Q：&lt;strong&gt;你让工人为你工作7天，给工人的回报是一根金条。金条平分成相连的7段&lt;br&gt;，你必须在每天结束时给他们一段金条，如果只许你两次把金条弄断，你如何给你&lt;br&gt;的工人付费？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：把金条切成4份,2份和1份&lt;br&gt;    第一天给工人一份金条&lt;br&gt;    第二天给他两份的金条，把第一天的一份金条收回&lt;br&gt;    第三天又把一份的金条给他&lt;br&gt;    第四天把四份的金条给他，把一份和两份的金条收回&lt;br&gt;    第五天又把一份的金条给他&lt;br&gt;    第六天又给他两份的金条，收回一份的金条&lt;br&gt;    第七天最后把一份的金条给他  &lt;/p&gt;
&lt;p&gt;Q：&lt;strong&gt;一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少&lt;br&gt;有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看&lt;br&gt;看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自&lt;br&gt;己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦&lt;br&gt;雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑&lt;br&gt;帽子？&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;或者这种变体： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个村子里，有50户人家，每家都养了一条狗。现在，发现村子里面出现了n只疯狗，村里规定，谁要是发现了自己的狗是疯狗，就要将自己的狗枪毙。&lt;br&gt;但问题是，村子里面的人只能看出别人家的狗是不是疯狗，而不能看出自己的狗是不是疯的，如果看出别人家的狗是疯狗，也不能告诉别人。&lt;br&gt;于是大家开始观察，第一天晚上，没有枪声，第二天晚上，没有枪声，第三天晚上，枪声响起（具体几枪不清楚），问村子里有几只疯狗？&lt;br&gt;(1)必须确定是疯狗才能杀&lt;br&gt;(2)杀狗用猎枪,开枪杀狗人人都听的见,没聋子&lt;br&gt;(3)只能观察其他人家的狗是否得了疯狗病,不能观察自己的狗是否有疯狗病&lt;br&gt;(4)只能杀自己家的狗,别人家的狗你就是知道有疯狗病也不能杀&lt;br&gt;(5)任何观察到了其他人家的狗有疯狗病都不能告诉任何人&lt;br&gt;(6)每人每天去观察一遍其他人家的狗是否疯狗&lt;br&gt;现在现象是:第一天没有枪声,第二天没有枪声,第三天响起一片枪声&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：假如只有一个人戴黑帽子，那他看到所有人都戴白帽，在第一次关灯时就&lt;br&gt;应自打耳光，所以应该不止一个人戴黑帽子；如果有两顶黑帽子，第一次两人都只&lt;br&gt;看到对方头上的黑帽子，不敢确定自己的颜色，但到第二次关灯，这两人应该明白&lt;br&gt;，如果自己戴着白帽，那对方早在上一次就应打耳光了，因此自己戴的也是黑帽子&lt;br&gt;，于是也会有耳光声响起；可事实是第三次才响起了耳光声，说明全场不止两顶黑&lt;br&gt;帽，依此类推，应该是关了几次灯，有几顶黑帽。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;接下来要参与大大小小的暑期实习笔试和面试。在这篇博客里我将总结一些常见的面试题。其中有一部分是我去年暑假找实习的时候总结的。现在看来，不免有些幼稚。慢慢完善吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Interview Front-end" scheme="http://yoursite.com/tags/Interview-Front-end/"/>
    
  </entry>
  
  <entry>
    <title>DOM API详解（二）</title>
    <link href="http://yoursite.com/2016/01/26/learning-dom-part2/"/>
    <id>http://yoursite.com/2016/01/26/learning-dom-part2/</id>
    <published>2016-01-26T07:58:34.000Z</published>
    <updated>2016-04-21T03:05:12.000Z</updated>
    
    <content type="html">&lt;p&gt;###四、API详解-DOM CORE&lt;/p&gt;
&lt;h4 id=&quot;DOM标准的层级&quot;&gt;&lt;a href=&quot;#DOM标准的层级&quot; class=&quot;headerlink&quot; title=&quot;DOM标准的层级&quot;&gt;&lt;/a&gt;DOM标准的层级&lt;/h4&gt;&lt;p&gt;DOM标准实际由很多的子模块组成，包括Core module，XML module，Events module，User interface Events module，Mouse Events module，Text Events module，Keyboard Events module，Mutation Events module，Mutation name Events module，HTML Events module，Load and Save module，Asynchronous load module，Validation module，和XPath module。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;具体的层级结构如下图所示：&lt;br&gt;&lt;img src=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/images/dom-architecture.png&quot; alt=&quot;dom-architecture&quot;&gt;&lt;br&gt;&lt;em&gt;image credit: w3.org&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;DOM-Core-导语&quot;&gt;&lt;a href=&quot;#DOM-Core-导语&quot; class=&quot;headerlink&quot; title=&quot;DOM Core-导语&quot;&gt;&lt;/a&gt;DOM Core-导语&lt;/h4&gt;&lt;p&gt;在我们把目光转向DOM Core模块之前，我想先讲讲如何阅读DOM的W3C Specification。首先我们可以阅读官方的导语-&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is the Document Object Model?&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这一节中介绍了DOM的相关概念。比如关于DOM的结构，我们通常认为是一颗树，但实际上用森林来形容更为贴切，因为虽然以&lt;code&gt;Document&lt;/code&gt;为根节点的文档树最多只能有一颗，但我们还有一颗可选的&lt;code&gt;doctype&lt;/code&gt;节点树，以及&lt;code&gt;comments&lt;/code&gt;节点等等。&lt;/p&gt;
&lt;p&gt;更重要的是，导语中还介绍了接下来文档中的一些惯例。比如因为DOM是独立于编程语言的，所以在文档中使用了IDL（Interactive Data Language）来描述接口。然后我们需要注意的一点就是，DOM可以用于HTML和XML，因此在前端同学看来，DOM中会有一些不太熟悉的概念，比如&lt;code&gt;Namespace&lt;/code&gt;和&lt;code&gt;DOM URIs&lt;/code&gt;，这些正是为了兼容XML而加入到DOM中的特性。不用过分在意。&lt;/p&gt;
&lt;p&gt;下面是一个简化的IDL示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Element : Node {
  readonly attribute DOMString       tagName;
  void               removeAttribute(in DOMString name)
                                        raises(DOMException);
  Attr               getAttributeNode(in DOMString name);
  NodeList           getElementsByTagName(in DOMString name);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;IDL中主要描述了一个接口的继承关系，以及接口的方法和属性，及相应的参数和返回值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面我们首先来看DOM Core模块。从“Core”这个名词就可以看出这个模块在整个DOM标准中处于中心地位。DOM Core模块主要定义了DOM最关键的一组接口和对象。其中最顶层的一个接口就是&lt;code&gt;Node&lt;/code&gt;。直接继承&lt;code&gt;Node&lt;/code&gt;的接口有&lt;code&gt;Element&lt;/code&gt;、&lt;code&gt;DocumentType&lt;/code&gt;、&lt;br&gt;&lt;code&gt;Attr&lt;/code&gt;、&lt;code&gt;ProcessingInstruction&lt;/code&gt;、&lt;code&gt;Comment&lt;/code&gt;、&lt;br&gt;&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;CDATASection&lt;/code&gt;和&lt;code&gt;Notation&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Node接口&quot;&gt;&lt;a href=&quot;#Node接口&quot; class=&quot;headerlink&quot; title=&quot;Node接口&quot;&gt;&lt;/a&gt;Node接口&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;接口是整个DOM中最顶层的接口，DOM中的每一个节点都是一个&lt;code&gt;Node&lt;/code&gt;。从&lt;code&gt;Node&lt;/code&gt;接口分化出其他的更具体的接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;接口的属性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;属性名&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nodeName&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DOMString&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nodeValue&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DOMString&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nodeType&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;unsigned short&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parentNode&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;childNodes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;NodeList&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;firstChild&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastChild&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;previousSibling&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nextSibling&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;attributes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;NamedNodeMap&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ownerDocument&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Document&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;值得注意的是，虽然这些属性都定义在Node接口上，但是不是所有的底层接口实现都有对应的值。如&lt;code&gt;Text&lt;/code&gt;和&lt;code&gt;Comment&lt;/code&gt;节点都没有子元素，因此它们的&lt;code&gt;childNodes&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;。同理，&lt;code&gt;Element&lt;/code&gt;接口的&lt;code&gt;nodeValue&lt;/code&gt;值就为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nodeType&lt;/code&gt;属性的值被定义为一组常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// NodeType
  const unsigned short      ELEMENT_NODE                   = 1;
  const unsigned short      ATTRIBUTE_NODE                 = 2;
  const unsigned short      TEXT_NODE                      = 3;
  const unsigned short      CDATA_SECTION_NODE             = 4;
  const unsigned short      ENTITY_REFERENCE_NODE          = 5;
  const unsigned short      ENTITY_NODE                    = 6;
  const unsigned short      PROCESSING_INSTRUCTION_NODE    = 7;
  const unsigned short      COMMENT_NODE                   = 8;
  const unsigned short      DOCUMENT_NODE                  = 9;
  const unsigned short      DOCUMENT_TYPE_NODE             = 10;
  const unsigned short      DOCUMENT_FRAGMENT_NODE         = 11;
  const unsigned short      NOTATION_NODE                  = 12;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是我们平时用来检测节点类型时使用的数值了。&lt;/p&gt;
&lt;p&gt;下面从&lt;code&gt;Node&lt;/code&gt;接口的方法中选几个主流的API进行简单的介绍，对于W3C中为标准但在WHATWG中被废弃的，这里不进行介绍（在主流的浏览器中也没有相应的实现）。对于一些在继承Node的接口中有更具体实现的API，这里也不进行介绍（如&lt;code&gt;hasAttributes&lt;/code&gt;在Element接口中有更具体的实现）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;compareDocumentPosition&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是DOM3中引入的一个很有意思的API。这个API将两个Node的位置进行比较，然后返回&lt;code&gt;DocumentPosition&lt;/code&gt;这组常量中的一种。这组常量是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 节点被另一个节点包含。被包含的节点是父节点的后继
DOCUMENT_POSITION_CONTAINED_BY
// 节点包含另一个节点。父节点是子节点的前驱
  DOCUMENT_POSITION_CONTAINS
DOCUMENT_POSITION_DISCONNECTED
// 后继关系
DOCUMENT_POSITION_FOLLOWING
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
// 前驱关系
DOCUMENT_POSITION_PRECEDING
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;appendChild&lt;/code&gt;&amp;amp;&amp;amp;&lt;code&gt;removeChild&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;这两个API是比较常用的，&lt;code&gt;appendChild&lt;/code&gt;在DOM子元素列表的最后插入元素，如果这个元素已经存在DOM树中，就先移除这个元素再插入。&lt;code&gt;removeChild&lt;/code&gt;则从DOM子元素列表中移除元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;insertBefore&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;这个API有两个参数，一个是&lt;code&gt;newChild&lt;/code&gt;，一个是&lt;code&gt;refChild&lt;/code&gt;。&lt;code&gt;newChild&lt;/code&gt;既是要插入的节点，而&lt;code&gt;refChild&lt;/code&gt;则是一个已经在&lt;code&gt;Node&lt;/code&gt;所在DOM树中的参考子节点。&lt;code&gt;newChild&lt;/code&gt;会插入到&lt;code&gt;refChild&lt;/code&gt;之前，如果&lt;code&gt;refChild&lt;/code&gt;是&lt;code&gt;null&lt;/code&gt;，那么&lt;code&gt;newChild&lt;/code&gt;会插入到&lt;code&gt;Node&lt;/code&gt;子节点列表的末尾。&lt;/p&gt;
&lt;p&gt;这个API的记忆很简单，命名是&lt;code&gt;insertBefore&lt;/code&gt;，必然是有一个参考节点的，不然插到谁的前面去呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;isEqualNode&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个API的作用是判断两个DOM是否相等。这里的相等并不是指指向同一个对象，而是指属性和值方面是否相同。&lt;/p&gt;
&lt;p&gt;对于两个节点来说比较的算法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个节点是否是相同的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodeName, localName, namespaceURI, prefix, nodeValue&lt;/code&gt;这些属性是否相同&lt;/li&gt;
&lt;li&gt;节点的属性集合（在DOM中的数据类型是&lt;code&gt;NamedNodeMaps&lt;/code&gt;）是否相同，这里集合中属性的顺序可以是随意的&lt;/li&gt;
&lt;li&gt;子节点集合（&lt;code&gt;NodeLists&lt;/code&gt;类型）是否相同，这里会考虑节点的index，如果不一样则不相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Element接口&quot;&gt;&lt;a href=&quot;#Element接口&quot; class=&quot;headerlink&quot; title=&quot;Element接口&quot;&gt;&lt;/a&gt;Element接口&lt;/h4&gt;&lt;h4 id=&quot;Document接口&quot;&gt;&lt;a href=&quot;#Document接口&quot; class=&quot;headerlink&quot; title=&quot;Document接口&quot;&gt;&lt;/a&gt;Document接口&lt;/h4&gt;&lt;h4 id=&quot;Attr接口&quot;&gt;&lt;a href=&quot;#Attr接口&quot; class=&quot;headerlink&quot; title=&quot;Attr接口&quot;&gt;&lt;/a&gt;Attr接口&lt;/h4&gt;&lt;h4 id=&quot;Text，Comment和CharacterData接口&quot;&gt;&lt;a href=&quot;#Text，Comment和CharacterData接口&quot; class=&quot;headerlink&quot; title=&quot;Text，Comment和CharacterData接口&quot;&gt;&lt;/a&gt;Text，Comment和CharacterData接口&lt;/h4&gt;&lt;h4 id=&quot;DOM中的基础数据类型&quot;&gt;&lt;a href=&quot;#DOM中的基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;DOM中的基础数据类型&quot;&gt;&lt;/a&gt;DOM中的基础数据类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DOMString&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMTimeStamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMUserData&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMObject&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###四、API详解-DOM CORE&lt;/p&gt;
&lt;h4 id=&quot;DOM标准的层级&quot;&gt;&lt;a href=&quot;#DOM标准的层级&quot; class=&quot;headerlink&quot; title=&quot;DOM标准的层级&quot;&gt;&lt;/a&gt;DOM标准的层级&lt;/h4&gt;&lt;p&gt;DOM标准实际由很多的子模块组成，包括Core module，XML module，Events module，User interface Events module，Mouse Events module，Text Events module，Keyboard Events module，Mutation Events module，Mutation name Events module，HTML Events module，Load and Save module，Asynchronous load module，Validation module，和XPath module。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>DOM API详解（一）</title>
    <link href="http://yoursite.com/2016/01/23/learning-dom-part1/"/>
    <id>http://yoursite.com/2016/01/23/learning-dom-part1/</id>
    <published>2016-01-23T12:49:30.000Z</published>
    <updated>2016-03-11T09:25:16.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、什么是DOM&quot;&gt;&lt;a href=&quot;#一、什么是DOM&quot; class=&quot;headerlink&quot; title=&quot;一、什么是DOM&quot;&gt;&lt;/a&gt;一、什么是DOM&lt;/h3&gt;&lt;p&gt;Document Object Model(DOM)是用编程语言对HTML，XML以及SVG文档进行操作的接口。我们经常使用JavaScript来操纵DOM，不过DOM其实的语言无关的。它并不是JavaScript的一部分。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;虽然如此，DOM在前端开发中经常和JS一起讨论，并且对JS造成了极大的负面影响。这个原因就在于早年间各大浏览器厂商（主要是老版本IE），对DOM的实现并没有按W3C的标准来做，而是自己制定了一套接口，由此给前端开发造成了极大的麻烦。我们需要使用jQuery这样的基础库，使用封装好的跨平台兼容API，才能使代码兼容主要浏览器。&lt;/p&gt;
&lt;p&gt;直到今天，jQuery这样的基础库依然是不可或缺的。好消息是，随着时代的进步，DOM API的兼容性在主流浏览器中已经不是问题。在没有低版本IE的移动端web中，我们就可以不用为这个问题劳神了。&lt;/p&gt;
&lt;p&gt;然而相比于CSS和JS所拥有的明确版本迭代和丰富的文档，DOM无论是在版本的碎片化程度还是文档的数量上来说都很难和前两者相比。&lt;/p&gt;
&lt;p&gt;打开MDN的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DOM文档首页&lt;/a&gt;，我们可以看到密密麻麻的API列表，点开其中的一个，可以看到更多的子API。其中除了DOM Core，有CSS DOM，还有HTMl5相关的DOM，更有Worker这样的浏览器相关的接口。可谓是一个大杂烩，CSS，JS，浏览器各种功能的API都在其中。因此本文就是一个DOM API的分类梳理，带大家看清DOM众多API的组成和层级。&lt;/p&gt;
&lt;h3 id=&quot;二、DOM标准&quot;&gt;&lt;a href=&quot;#二、DOM标准&quot; class=&quot;headerlink&quot; title=&quot;二、DOM标准&quot;&gt;&lt;/a&gt;二、DOM标准&lt;/h3&gt;&lt;p&gt;我们从W3C的&lt;a href=&quot;https://www.w3.org/DOM/DOMTR&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DOM Technical Reports&lt;/a&gt;来看，Document Object Model (DOM)目前有Level 1，Level 2，Level 3，以及Level4三个标准。每一个Level的标准下又分为多个模块，其中DOM2 Core Specification的发布时间为2000-11-13，而DOM3 Core Specification的发布时间为2004-04-07，最新的DOM4发布于2015-11-19。&lt;/p&gt;
&lt;p&gt;DOM2由许多个标准组成是，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/DOM2%20modules.png&quot; alt=&quot;DOM2模块&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我们来看看DOM3。DOM3标准构建在DOM2的基础上，因此数量上少于DOM2的模块。DOM3中的XPath Specification等等标准还没有正式成为推荐标准，因此没有加入图表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/DOM3%20modules%20v3.png&quot; alt=&quot;DOM3模块&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、DOM2与DOM3，以及非核心API&quot;&gt;&lt;a href=&quot;#三、DOM2与DOM3，以及非核心API&quot; class=&quot;headerlink&quot; title=&quot;三、DOM2与DOM3，以及非核心API&quot;&gt;&lt;/a&gt;三、DOM2与DOM3，以及非核心API&lt;/h3&gt;&lt;p&gt;和CSS标准一样，DOM标准的版本也是各自独立的。我们所说的DOM2，DOM3其实主要指DOM Core Specification的版本。在DOM Core Specification中会写明这个版本的DOM Core和哪些版本的标准一起组成新一代DOM标准。&lt;/p&gt;
&lt;p&gt;因此我们也就可以解释为什么DOM3的组成标准要大大少于DOM2了。DOM2中的&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Style/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Style Specification&lt;/a&gt;后来发展为了一个新的&lt;a href=&quot;https://drafts.csswg.org/cssom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSSOM Specification&lt;/a&gt;，事实上这个标准已经不属于DOM的范畴，而被划入CSS标准。而&lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Events/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Events Specification&lt;/a&gt;的Level 3最后发展为了新的&lt;a href=&quot;https://www.w3.org/TR/uievents/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI Events Specification&lt;/a&gt;以及&lt;a href=&quot;https://www.w3.org/TR/2013/REC-touch-events-20131010/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Touch Events Specification&lt;/a&gt;等等独立的Event Specification，补充了DOM2 Events Specification中缺失的事件。&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Traversal-Range/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Traversal and Range Specification&lt;/a&gt;中的Traversal部分发展为了新的&lt;a href=&quot;https://www.w3.org/TR/ElementTraversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Element Traversal Specification&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;具体标准之间的关系可以看下表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;DOM2模块&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;新标准&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Style/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Style Specification Level 2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://drafts.csswg.org/cssom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSSOM Specification（Not a part of DOM now）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Traversal-Range/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Traversal and Range Specification Level 2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://www.w3.org/TR/ElementTraversal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Element Traversal Specification（Part of DOM4）&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Events/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Events Specification Level 2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://www.w3.org/TR/uievents/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI Events Specification&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://www.w3.org/TR/2013/REC-touch-events-20131010/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Touch Events Specification&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://www.w3.org/TR/2015/REC-pointerevents-20150224/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pointer Events Specification&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://www.w3.org/TR/2014/REC-progress-events-20140211/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Progress Events Specification&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;然后我们来看看所谓的非核心API。所谓的非核心API就是那些在W3C标准中不属于DOM的API，但是这些API和DOM的核心部分有着或多或少的关系。如CSS相关的&lt;a href=&quot;https://drafts.csswg.org/cssom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSSOM Specification&lt;/a&gt;，&lt;a href=&quot;https://www.w3.org/TR/2013/REC-selectors-api-20130221/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Selectors API&lt;/a&gt;等等。以及与HTML5相关的众多JavaScript API，比如&lt;a href=&quot;https://www.w3.org/TR/2015/PR-webstorage-20151126/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web Storage&lt;/a&gt;，&lt;a href=&quot;https://www.w3.org/TR/2015/WD-workers-20150924/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web Workers&lt;/a&gt;等等&lt;/p&gt;
&lt;p&gt;本文关注的主要是DOM2，DOM3以及部分新模块的API，解读它们的构成，以及在浏览器的兼容情况。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是DOM&quot;&gt;&lt;a href=&quot;#一、什么是DOM&quot; class=&quot;headerlink&quot; title=&quot;一、什么是DOM&quot;&gt;&lt;/a&gt;一、什么是DOM&lt;/h3&gt;&lt;p&gt;Document Object Model(DOM)是用编程语言对HTML，XML以及SVG文档进行操作的接口。我们经常使用JavaScript来操纵DOM，不过DOM其实的语言无关的。它并不是JavaScript的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>2015年末必备前端工具集</title>
    <link href="http://yoursite.com/2015/12/28/2015-javascript-tools/"/>
    <id>http://yoursite.com/2015/12/28/2015-javascript-tools/</id>
    <published>2015-12-28T14:03:42.000Z</published>
    <updated>2015-12-28T15:15:25.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接: &lt;a href=&quot;https://medium.com/javascript-scene/must-see-javascript-dev-tools-that-put-other-dev-tools-to-shame-aca6d3e3d925#.wm0lbpiko&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Must See JavaScript Dev Tools That Put Other Dev Tools to Shame&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&quot;https://medium.com/@_ericelliott&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eric Elliott&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自 : &lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;“Javascript没法胜任大型应用，因为它甚至不能确定一个变量的类型，而且很难重构”~一大堆困惑的人&lt;/p&gt;
&lt;p&gt;当我初识Javascript的时候，只有一种浏览器需要关心：NetScape。它在微软开始捆绑销售IE和操作系统之前完全统治了世界。在那些日子里，Javascript的开发者工具很弱这种观点的确是对的。&lt;/p&gt;
&lt;p&gt;不过这个观点已经被推翻很久了，今天，Javascript已经拥有了在我见过的所有语言中最好的开发工具生态系统。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，我没有说“最好的IDE”。如果你正在寻找一款统一了不同开发工具使用体验的集成式IDE，请试试为C#打造的微软Visual Studio，和Unity一起使用风味更佳。虽然我本人并没有使用过，但是听我信任的人说这很靠谱。&lt;/p&gt;
&lt;p&gt;我用过C++和虚幻引擎。当我第一次试用的时候，我意识到web平台的开发工具仍然有很长的路要走。&lt;/p&gt;
&lt;p&gt;不过我们已经走过了很长一段路，现在我们在JS中使用的工具让IDE神奇的自动补全看起来就像是 小孩的玩具。尤为是JavaScript的运行时工具，在我见过的所有其他语言中都没有对手。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Javascript拥有在我见过的所有语言中最好的开发工具生态系统。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;什么是开发者工具？&quot;&gt;&lt;a href=&quot;#什么是开发者工具？&quot; class=&quot;headerlink&quot; title=&quot;什么是开发者工具？&quot;&gt;&lt;/a&gt;什么是开发者工具？&lt;/h4&gt;&lt;p&gt;开发者工具是一套让开发者更轻松的软件集合。传统上，我们主要将IDE，linter，编译器，调试器，和性能分析器认为是开发者工具。&lt;/p&gt;
&lt;p&gt;不过JavaScript是一种动态语言，伴随它的动态特性而来的是对运行时开发者工具的需求。JavaScript对此的需求程度很高。&lt;/p&gt;
&lt;p&gt;为了实现我写这篇文章的初衷，我将包括对运行时工具的介绍，甚至包括一些能提升运行时开发者工具可视化和调试体验的库。开发工具与库之间的界线将开始模糊。与之而来的将是令人震惊的结果。&lt;/p&gt;
&lt;h4 id=&quot;开发者工具一览表&quot;&gt;&lt;a href=&quot;#开发者工具一览表&quot; class=&quot;headerlink&quot; title=&quot;开发者工具一览表&quot;&gt;&lt;/a&gt;开发者工具一览表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://atom.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Atom&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://atom.io/packages/atom-ternjs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;atom-ternjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.chrome.com/devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chrome Dev Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/speed/pagespeed/insights/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PageSpeed Insights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.mozilla.org/en-US/firefox/developer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FireFox Developer Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.browsersync.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BrowserSync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/traceglMPL/tracegl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TraceGL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://s-a.github.io/iron-node/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ironNode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://eslint.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ESLint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ericelliott/rtype&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rtype&lt;/a&gt; (规范) &amp;amp; &lt;a href=&quot;https://github.com/ericelliott/rfx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rfx&lt;/a&gt; (库) &lt;strong&gt;提示:&lt;/strong&gt; 这些是未完成的开发预览版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://babeljs.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Babel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://greenkeeper.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Greenkeeper.io&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/peerigon/updtr&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;updtr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Webpack&lt;/a&gt; + &lt;a href=&quot;https://github.com/webpack/docs/wiki/list-of-plugins&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hot module replacement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://redux.js.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redux&lt;/a&gt; + &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redux DevTools&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于这些工具&quot;&gt;&lt;a href=&quot;#关于这些工具&quot; class=&quot;headerlink&quot; title=&quot;关于这些工具&quot;&gt;&lt;/a&gt;关于这些工具&lt;/h4&gt;&lt;p&gt;你的开发者生涯将围绕着这两个东西展开：&lt;strong&gt;编辑器&lt;/strong&gt;，和你的&lt;strong&gt;运行环境&lt;/strong&gt;（比如，浏览器，平台，和你代码的目标设备）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑器：&lt;/strong&gt;我是用着像Borland IDE，微软Visual Studio，Eclipse和WebStorm这样的大型，重量级，高度集成的IDE开始我的职业生涯的。我认为这些IDE中最好的是&lt;strong&gt;WebStorm&lt;/strong&gt; 和 &lt;strong&gt;Visual Studio&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是我对这些IDE体积的膨胀感到厌倦，所以在最近几年里，我的代码都是在更精简的编辑器中写成的。主要是Sublime Text，不过我最近切换到了&lt;a href=&quot;https://atom.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;。你一定会需要&lt;a href=&quot;https://atom.io/packages/atom-ternjs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;atom-ternjs&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;来启用JavaScript智能感知特性。你可能也会对Visual Studio Code感兴趣。这是一个简约版Visual Studio，专为喜欢像Sublime Text和Atom这样的小型可拓展编辑器的人打造。&lt;/p&gt;
&lt;p&gt;我也使用vim在终端里进行快速编辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试器：&lt;/strong&gt;在我开始web编程之旅时，我想念那些集成的调试器。不过Chrome和FireFox团队将运行时调试提升到了一个全新的水准。今天似乎每个人都听说过Chrome DevTools，并且知道如何逐步调试代码。不过你知道它有对性能及内存进行记录和审查（profiling and auditing）的高级特性吗？你用过flame charts或者the dominators view吗？&lt;/p&gt;
&lt;p&gt;说到性能审查，你需要了解&lt;a href=&quot;https://developers.google.com/speed/pagespeed/insights/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PageSpeed Insights&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;iframe width=&quot;854&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/bDUDuQy3R7Y?list=PLOU2XLYxmsILKwwASNS0xgfcmakbK_8JZ&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;在这些好东西之上，Chrome DevTools也有一些酷炫的特性，比如像CSS实时编辑，以及可以帮助你编辑动画的超酷特性。去了解Chrome DevTools吧，你不会后悔的。&lt;/p&gt;
&lt;iframe width=&quot;700&quot; height=&quot;393&quot; src=&quot;https://www.youtube.com/embed/hJdqtBeAUNI&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;为了不被超过，FireFox有一个专为开发者打造的浏览器&lt;a href=&quot;https://www.mozilla.org/en-US/firefox/developer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FireFox Developer Edition&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;iframe width=&quot;700&quot; height=&quot;393&quot; src=&quot;https://www.youtube.com/embed/g9k4IrtaPMs?list=PLo3w8EB99pqLRJBWRCoyGTIrkctoUgB9W&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;&lt;strong&gt;BrowserSync:&lt;/strong&gt; &lt;a href=&quot;http://www.browsersync.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BrowserSync&lt;sup&gt;[5]&lt;/sup&gt;&lt;/a&gt;可以一次同时控制几个浏览器，这是检测你的响应式布局的一种好办法。换句话说，你可以使用BrowserSync CLI来在桌面，平板和手机上打开你的app。&lt;/p&gt;
&lt;p&gt;你可以设定文件监视（watch files），然后当文件改动时，几个同步的浏览器会自动刷新。滚动，点击，以及表单互动这些动作都将会被同步到所有设备，所有你可以简单的测试你的app的工作流，确保事情在任何设备上都看起来都对劲。&lt;/p&gt;
&lt;iframe width=&quot;640&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/heNWfzc7ufQ&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;&lt;strong&gt;TraceGL:&lt;/strong&gt; &lt;a href=&quot;https://github.com/traceglMPL/tracegl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TraceGL&lt;sup&gt;[6]&lt;/sup&gt;&lt;/a&gt; 是一个运行时调试工具，它让你可以观察软件中实时发生的所有函数调用，而不是逐步手动调试你的代码，一次一步。这个是一个超级强大和有用的功能。&lt;/p&gt;
&lt;iframe width=&quot;700&quot; height=&quot;393&quot; src=&quot;https://www.youtube.com/embed/TW6uMJtbVrk&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;&lt;strong&gt;ironNode:&lt;/strong&gt; &lt;a href=&quot;http://s-a.github.io/iron-node/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ironNode&lt;sup&gt;[7]&lt;/sup&gt;&lt;/a&gt; 是一个用于调试Node的桌面app。由Electron，一个桌面跨平台运行时驱动。Electron也驱动了Atom编辑器。就像node-inspector，ironNode允许你使用类似Chrome DevTools的特性来追踪你的代码。&lt;/p&gt;
&lt;iframe width=&quot;640&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/pxq6zdfJeNI&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;将ironNode和Babel一起使用，我使用如下的&lt;em&gt;&lt;code&gt;debug.js&lt;/code&gt;&lt;/em&gt; 脚本：&lt;/p&gt;
&lt;pre&gt;require(&#39;babel-core/register&#39;);  
require(&#39;./index&#39;);
&lt;/pre&gt;


&lt;p&gt;加载调试器：&lt;/p&gt;
&lt;pre&gt;iron-node source/debug.js
&lt;/pre&gt;


&lt;p&gt;这就像魔法一样，不是吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linting:&lt;/strong&gt; &lt;a href=&quot;http://eslint.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ESLint&lt;sup&gt;[8]&lt;/sup&gt;&lt;/a&gt; 是目前为止我用过的各种语言的linter中最好的。我喜欢ESLint甚于JSHint，ESLint比JSHint好太多了。如果你不确定使用什么，别担心，使用ESLint。为什么它这么酷呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可配置性高 - 每一个选项都可以被开启或关闭。这些选项甚至可以接收参数。&lt;/li&gt;
&lt;li&gt;创造你自己的规则。你有你想要在你的团队中强制执行的代码规范吗？在linter中可能已经有了这样的规则，不过如果没有，你可以写你自己的规则。&lt;/li&gt;
&lt;li&gt;支持插件 - 使用了某些特殊语法？ES6+或者未来版本JavaScript的实验性特性？没问题。使用了React的JSX语法打造简洁的UI组件？没问题。使用了你自己的实验性JavaScript语法拓展？没问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类型支持：&lt;/strong&gt; JavaScript具有松散的类型，这意味着你不必注解所有的类型。过去数年我在C++和Java这样的语言中注解所有东西。当我开始使用JavaScript之后，我感到如释重负。类型注解在你的源文件中制造了杂音。函数通常在没有类型注解时更易用。&lt;/p&gt;
&lt;p&gt;和大众认知相反，&lt;strong&gt;JavaScript是有类型的&lt;/strong&gt;，但是JavaScript在&lt;strong&gt;值&lt;/strong&gt;层面区别类型而不是变量层面。变量类型可以被类型推断识别并预测出来（这就是Atom TernJS插件的作用）。&lt;/p&gt;
&lt;p&gt;这就是说，类型注解和签名（signature）声明是为了一个目的：它们对于开发者来说是不错的文档。它们也使JavaScript引擎以及编译器作者的一些重要性能优化成为可能。作为一个构建app的JavaScript程序员，你不应该担心性能问题。把这些留给引擎和制定规范的团队吧。&lt;/p&gt;
&lt;p&gt;不过关于类型注解我最喜欢的一点是运行时类型反射。使用类型反射可以开启运行时开发者工具。想知道这样的工具是什么样的，请阅读&lt;a href=&quot;http://www.sitepoint.com/future-programming-webassembly-life-after-javascript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“The Future of Programming: WebAssembly and Life After JavaScript”&lt;sup&gt;[9]&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;数年来，我使用JSDoc来注解类型，编写文档以及类型推断。不过我对其麻烦的限制感到厌倦。这感觉就像你使用一种不同的语言编写代码，之后将它挤压成JavaScript（这是真的）。&lt;/p&gt;
&lt;p&gt;我也对TypeScript的结构化类型方案感到印象深刻。&lt;/p&gt;
&lt;p&gt;不过TypeScript存在一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript不是标准的JavaScript - 选择TypeScript意味着选择TypeScript编译器以及工具生态 - 这通常导致你无法选择为JavaScript标准设计的方案。&lt;/li&gt;
&lt;li&gt;TypeScript很大程度上基于class。这与JavaScript的原型和对象组合特性八字不合。&lt;/li&gt;
&lt;li&gt;目前为止，TypeScript不提供运行时解决方案… - 他们正在使用实验性的新JavaScript &lt;strong&gt;Reflect&lt;/strong&gt; API构建。不过接下来你可能会依靠这些实验性极高的规范特性，这些特性也许会成为最终标准，也许不会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为这些，我启动了（目前还未完成）&lt;a href=&quot;https://github.com/ericelliott/rtype&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rtype&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;和&lt;a href=&quot;https://github.com/ericelliott/rfx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rfx&lt;sup&gt;[11]&lt;/sup&gt;&lt;/a&gt;项目。&lt;strong&gt;rtype&lt;/strong&gt; 是一个函数和接口反射规范，对于了解JavaScript的读者来说，这一规范形成了不言自明的文档。&lt;strong&gt;rfx&lt;/strong&gt; 是一个用于封装已经存在的JS函数及对象然后添加类型元数据的库。同时，它也可以加入自动运行时类型检查。我正在积极的与人们合作以改进rtype和rfx。也欢迎你们的贡献。&lt;/p&gt;
&lt;p&gt;你要记得rtype和rfx还非常年轻，并且在短期之内几乎必定会有革命性的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Babel:&lt;/strong&gt; &lt;a href=&quot;http://babeljs.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Babel&lt;sup&gt;[12]&lt;/sup&gt;&lt;/a&gt; 是一个让你立即在JavaScript代码中使用还不被支持的ES6+, JSX以及其他特性的编译器。它的原理是将你的代码翻译成等价的ES5代码。一旦你开始使用它，我敢说你将很快对新语法上瘾，因为ES6为这门语言提供了一些真正有价值的语法拓展，像解构赋值（destructuring assignment），默认参数值，剩余和展开参数（rest parameters and spread），简洁对象字面量（concise object literals），以及更多… 阅读&lt;a href=&quot;https://medium.com/javascript-scene/how-to-use-es6-for-isomorphic-javascript-apps-2a9c3abe5ea2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“How to Use ES6 for Universal JavaScript Apps”&lt;sup&gt;[13]&lt;/sup&gt;&lt;/a&gt;来了解细节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Greenkeeper.io:&lt;/strong&gt; &lt;a href=&quot;http://greenkeeper.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Greenkeeper&lt;sup&gt;[14]&lt;/sup&gt;&lt;/a&gt; 监控你的项目依赖并且自动向你的项目提交一个pull request。你要确保你已经设定了CI解决方案来自动测试pull requests。如果测试通过，只要点击“merge”，就完工了。如果测试失败，你可以手动跟进并且找出哪里需要修复，或者直接关闭PR。&lt;/p&gt;
&lt;p&gt;如果你偏爱手动的方法，看看&lt;a href=&quot;https://github.com/peerigon/updtr&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;updtr&lt;/strong&gt;&lt;sup&gt;[15]&lt;/sup&gt;&lt;/a&gt;。在你第一次开启Greenkeeper之前，我推荐先在你的项目上运行updtr。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Webpack:&lt;/strong&gt; &lt;a href=&quot;https://webpack.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Webpack&lt;sup&gt;[16]&lt;/sup&gt;&lt;/a&gt; 将模块和依赖打包成浏览器可用的静态资源。它支持大量有趣的特性，比如模块热替换，这让你正在为浏览器编写的代码在文件更改时自动更新，而不用刷新页面。模块热替换是迈向真正持续实时开发反馈循环的第一步。如果你还没有使用webpack，你应该使用它。为了更快入门，看看&lt;a href=&quot;https://github.com/cloverfield-tools/universal-react-boilerplate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Universal React Boilerplate&lt;/strong&gt;&lt;sup&gt;[17]&lt;/sup&gt;&lt;/a&gt;这个项目里的webpack配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React:&lt;/strong&gt; 这一个有一点跑题，因为&lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React&lt;sup&gt;[18]&lt;/sup&gt;&lt;/a&gt; 严格意义上来说不是一个开发者工具。它和一个UI库有着更多的共同点。请把React想象成现代的jQuery：一种更简单的处理DOM的办法。但React比这更强大。事实上，你可以把React对准一大堆DOM之外的平台，包括原生移动UI APIs(iOS &amp;amp; Android)，WebGL, canvas以及更多。Netflix将React的目标平台设为了他们自己的Gibbon TV设备渲染API。&lt;/p&gt;
&lt;p&gt;所以为什么我将React列在开发者工具之中？因为React的抽象层被一些不错的开发者工具使用，来驱动代表未来趋势的惊人工具。特性有热加载（更新你的实时运行代码而不刷新页面），时间旅行（time travel），以及更多… 继续阅读！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redux + Redux DevTools:&lt;/strong&gt; Redux是由React/Flux架构和函数式编程的纯函数概念启发而来的一个应用状态管理库。另一个在开发者工具列表中的库？是的，以下是原因：&lt;/p&gt;
&lt;iframe width=&quot;700&quot; height=&quot;393&quot; src=&quot;https://www.youtube.com/embed/xsSnOQynTHs&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;


&lt;p&gt;Redux以及Redux DevTools使得在你的实时运行代码之上进行真正的下一代调试互动成为可能。这让你可以轻松洞察在你的app中已经发生的行为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*lAp8ZAk5uNFTuxjhx4GTdw.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它甚至允许你使用时间旅行调试这个特性在时间中来回穿梭。这是它在滚动视图中看起来的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*BTRxlHu8WuCF4Iep4R44lA.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h4&gt;&lt;p&gt;JavaScript有着我所见过的所有语言中最丰富的开发者工具集。你可以看到，这更像是一个拼凑的过程而不是一个统一的IDE环境。不过我们处于JavaScript开发的寒武纪大爆炸时期，在未来，我们也许会看到现成的统一集成开发者工具。与此同时，我们将一瞥编程未来走向的究竟。&lt;/p&gt;
&lt;p&gt;随着JavaScript向统一的应用状态（unified application state）和不变性（immutability）（正是这个特性使得Redux DevTools的时间旅行调试成为了可能）的更深处推进，我预测我们将看到更多的实时编程特性上线。&lt;/p&gt;
&lt;p&gt;我也相信我们构建的应用和我们用以构建它的开发环境之间的界线会随着时间消逝而渐渐模糊。举个例子，Unreal游戏引擎将蓝图编辑集成进了引擎自身，这允许开发者和设计师从运行的游戏中构建复杂的行为。我思考了很久，我们将开始看到这些特性出现在web和以及原生移动应用中。&lt;/p&gt;
&lt;p&gt;JavaScript的linting，运行时监视（runtime monitoring）和时间旅行调试特性在我所知道的任何语言中都没有对手。但我们还可以做更多，比如将同等于Unreal 4引擎中的蓝图系统这样的工具带给我们。我迫不及待的想看接下来会发生什么。&lt;/p&gt;
&lt;iframe width=&quot;700&quot; height=&quot;393&quot; src=&quot;https://www.youtube.com/embed/9hwhH7upYFE&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接: &lt;a href=&quot;https://medium.com/javascript-scene/must-see-javascript-dev-tools-that-put-other-dev-tools-to-shame-aca6d3e3d925#.wm0lbpiko&quot;&gt;Must See JavaScript Dev Tools That Put Other Dev Tools to Shame&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&quot;https://medium.com/@_ericelliott&quot;&gt;Eric Elliott&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自 : &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;“Javascript没法胜任大型应用，因为它甚至不能确定一个变量的类型，而且很难重构”~一大堆困惑的人&lt;/p&gt;
&lt;p&gt;当我初识Javascript的时候，只有一种浏览器需要关心：NetScape。它在微软开始捆绑销售IE和操作系统之前完全统治了世界。在那些日子里，Javascript的开发者工具很弱这种观点的确是对的。&lt;/p&gt;
&lt;p&gt;不过这个观点已经被推翻很久了，今天，Javascript已经拥有了在我见过的所有语言中最好的开发工具生态系统。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tooling" scheme="http://yoursite.com/tags/Tooling/"/>
    
  </entry>
  
  <entry>
    <title>Thoughts on Reset.css</title>
    <link href="http://yoursite.com/2015/11/05/reset-css/"/>
    <id>http://yoursite.com/2015/11/05/reset-css/</id>
    <published>2015-11-05T11:53:19.000Z</published>
    <updated>2015-11-08T03:31:42.000Z</updated>
    
    <content type="html">&lt;p&gt;###导语&lt;br&gt;CSS reset的作用主要就是清楚浏览器的默认样式，比如我们在Chrome里看到的&lt;code&gt;User Agent Stylesheet&lt;/code&gt;就是Chrome浏览器的默认样式。不同的浏览器会有不同的默认样式，因此我们需要清除一些默认样式，&lt;strong&gt;以达到在所有浏览器里显示效果的一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过这里面的学问还是很大的。首先我们只需要reset我们在项目中会使用的元素，这就涉及reset的模块化使用。第二我们只需要reset必要的属性。因为reset会加重浏览器渲染的性能开销，因此我们在css reset时必须要慎之又慎，保证最少的代码量和最佳的效果之间的平衡。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###确定需要reset的元素&lt;/p&gt;
&lt;p&gt;需要reset的元素有以下几类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.块级元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;块级元素所需要的重置主要是针对边距、字体的重置。我们常用的元素有&lt;code&gt;body,html,h1,h2,h3,h4,h5,h6,p,ul,li,ol,video&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.表单元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;块级元素所需要的重置除了边距之外，还有边框，&lt;code&gt;outline&lt;/code&gt;等表单元素特有的属性的重置。我们常用的元素有&lt;code&gt;input,button,textarea,fieldset&lt;/code&gt;等。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.带特殊样式的元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带特殊样式的元素包括带&lt;code&gt;list-style&lt;/code&gt;的&lt;code&gt;ul,ol&lt;/code&gt;，带&lt;code&gt;text-decoration&lt;/code&gt;的&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.HTML5元素&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;在不支持HTML5标签的浏览器，如IE8及以下的浏览器中，在使用html5shiv这样的polyfill之后，我们需要手动给这些元素加上&lt;code&gt;display:block;&lt;/code&gt;来设置默认的&lt;code&gt;display&lt;/code&gt;属性。不过目前html5shiv已经包括了默认的样式，所以我们可以不用考虑HTML5元素的&lt;code&gt;display&lt;/code&gt;属性reset。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.images&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;image&lt;/code&gt;标签在IE8以以下版本的浏览器中默认会存在边框，所以我们需要重置&lt;code&gt;border:0;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;###几个流行的reset.css&lt;/p&gt;
&lt;p&gt;1.&lt;a href=&quot;http://cssreset.com/scripts/eric-meyer-reset-css/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eric Meyer’s “Reset CSS” 2.0&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;height:400px;overflow:auto&quot;&gt;
/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
    display: block;
}
body {
    line-height: 1;
}
ol, ul {
    list-style: none;
}
blockquote, q {
    quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
    content: &#39;&#39;;
    content: none;
}
table {
    border-collapse: collapse;
    border-spacing: 0;
}
&lt;/pre&gt;

&lt;p&gt;评价：这是最早流行的&lt;code&gt;reset.css&lt;/code&gt;。本文中的示例也参考了这个著名的&lt;code&gt;reset.css&lt;/code&gt;。关于&lt;code&gt;blockquote&lt;/code&gt;和&lt;code&gt;table&lt;/code&gt;相关的reset可以参考这个文件。&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://cssreset.com/scripts/yahoo-css-reset-yui-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YUI css reset&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;height:400px;overflow:auto&quot;&gt;
/*
YUI 3.18.1 (build f7e7bcb)
Copyright 2014 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/

html {
    color: #000;
    background: #FFF
}

body,
div,
dl,
dt,
dd,
ul,
ol,
li,
h1,
h2,
h3,
h4,
h5,
h6,
pre,
code,
form,
fieldset,
legend,
input,
textarea,
p,
blockquote,
th,
td {
    margin: 0;
    padding: 0
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

fieldset,
img {
    border: 0
}

address,
caption,
cite,
code,
dfn,
em,
strong,
th,
var {
    font-style: normal;
    font-weight: normal
}

ol,
ul {
    list-style: none
}

caption,
th {
    text-align: left
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-size: 100%;
    font-weight: normal
}

q:before,
q:after {
    content: &#39;&#39;
}

abbr,
acronym {
    border: 0;
    font-variant: normal
}

sup {
    vertical-align: text-top
}

sub {
    vertical-align: text-bottom
}

input,
textarea,
select {
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    *font-size: 100%
}

legend {
    color: #000
}
&lt;/pre&gt;

&lt;p&gt;评价：比起Eric Meyer的reset来说要更全面一些。加入了对&lt;code&gt;html&lt;/code&gt;元素颜色的重置。在块级元素的重置上只设置了&lt;code&gt;margin&lt;/code&gt;和&lt;code&gt;padding&lt;/code&gt;。对行高并没有进行重置。&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;https://necolas.github.io/normalize.css/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;normalize.css&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;height:400px;overflow:auto&quot;&gt;
/*! normalize.css v3.0.2 | MIT License | git.io/normalize */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
  margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11
 * and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox &lt; 22.
 */

[hidden],
template {
  display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
  outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
  border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
  font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
  font-style: italic;
}

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari, and Chrome.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
  background: #ff0;
  color: #000;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
  border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
  margin: 1em 40px;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
  overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 */

button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
  overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
  text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type=&quot;button&quot;], /* 1 */
input[type=&quot;reset&quot;],
input[type=&quot;submit&quot;] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
  cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
  line-height: normal;
}

/**
 * It&#39;s recommended that you don&#39;t attempt to style these elements.
 * Firefox&#39;s implementation doesn&#39;t respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type=&quot;checkbox&quot;],
input[type=&quot;radio&quot;] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome&#39;s increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type=&quot;number&quot;]::-webkit-inner-spin-button,
input[type=&quot;number&quot;]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type=&quot;search&quot;] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type=&quot;search&quot;]::-webkit-search-cancel-button,
input[type=&quot;search&quot;]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren&#39;t caught out if they zero out fieldsets.
 */

legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
  overflow: auto;
}

/**
 * Don&#39;t inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
  font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
} 
&lt;/pre&gt;

&lt;p&gt;评价：这是一个全面的reset.css。最大的特点就是模块化。分&lt;code&gt;HTML5 display definitions&lt;/code&gt;,&lt;code&gt;Links&lt;/code&gt;,&lt;code&gt;Text-level semantics&lt;/code&gt;,&lt;code&gt;Embedded content&lt;/code&gt;,&lt;code&gt;Grouping content&lt;/code&gt;,&lt;code&gt;Forms&lt;/code&gt;,&lt;code&gt;Tables&lt;/code&gt;这几个模块来分别设置。都有详细的注释。是一份不错的学习材料。&lt;/p&gt;
&lt;p&gt;###&lt;code&gt;font-famliy&lt;/code&gt;的设置&lt;/p&gt;
&lt;p&gt;在根元素处设置的&lt;code&gt;font-famliy&lt;/code&gt;属性决定了全站所有页面的默认字体。一般我们设置&lt;code&gt;font-famliy&lt;/code&gt;的顺序为，默认英文字体，默认中文字体，fallback中文字体。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
font-famliy:&quot;Arial&quot;,&quot;Helvetica&quot;,&quot;Microsoft YaHei&quot;,&quot;PingFang SC&quot;,&quot;STHeiti&quot;,&quot;sans-serif&quot;;
&lt;/pre&gt;

&lt;p&gt;首先我们设置默认的英文字体。因为中文字体之中是带有一套英文字体的，所有我们会首先设置默认英文字体来防止被覆盖。然后我们设置windows和OS X上的默认中文字体，这里一般用英文来设置，来避免一些兼容性问题。最后我们设置&lt;code&gt;sans-serif&lt;/code&gt;衬线字体来做一个fallback。&lt;/p&gt;
&lt;p&gt;对于字体要求一般的情况下，这样的设置其实就满足我们的要求了。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
font-famliy:&quot;Arial&quot;,&quot;Helvetica&quot;,&quot;sans-serif&quot;;
&lt;/pre&gt;

&lt;p&gt;这种设置下，系统会调用默认的无衬线中文字体。所以如果在某些有很多无衬线中文字体的操作系统，如OS X下没有特定的字体要求的话，可以将第一种设置简化为这种设置。移动端web的字体比较多，所以设置方式与上面的类似。&lt;/p&gt;
&lt;p&gt;###一个基本的reset.css示例&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
/* 全局   
===================================================================== */

/**
 * 重置默认行高
 */
body{
    line-height:1;}
html{
    margin:0;
}


/* 文字语义标签  
===================================================================== */
h1,h2,h3,h4,h5,h6{
    marign:0;
    font-size:100%;
    font-weight: normal;
}
p{
    margin:0;
}

/* 表单
===================================================================== */
fieldset{
    border:0;
}
input,button,textarea{
    border:0;
    outline:0;
    padding:0;
}
/**
 * chrome下button默认的box-sizing属性是border-box
 */
button{
    box-sizing:content-box;
}

/* 链接
===================================================================== */
a{
    color:#fff;
    text-decoration:none;
}

/* 嵌入内容
===================================================================== */
img{
    border:0;
}

/* 列表
===================================================================== */
ol, ul {
    list-style: none;
}

/* 表格
===================================================================== */
table {
    border-collapse: collapse;
    border-spacing: 0
}
&lt;/pre&gt;

&lt;p&gt;###结语&lt;/p&gt;
&lt;p&gt;上面列出的示例，其实如Meyer说的，只是一个开始。我们需要根据我们的具体需求来做微调，来达到最好的“性价比”。&lt;/p&gt;
&lt;p&gt;比如众多的HTML5元素。如果你的项目中不打算使用这些元素，那么你就不用添加对这些元素的reset。之前列的三个流行reset的内容长短不一，很大程度上也是因为大家的目标不一样。所以我们应该以这些优秀的reset.css为模板，来打造自己的reset.css。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###导语&lt;br&gt;CSS reset的作用主要就是清楚浏览器的默认样式，比如我们在Chrome里看到的&lt;code&gt;User Agent Stylesheet&lt;/code&gt;就是Chrome浏览器的默认样式。不同的浏览器会有不同的默认样式，因此我们需要清除一些默认样式，&lt;strong&gt;以达到在所有浏览器里显示效果的一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过这里面的学问还是很大的。首先我们只需要reset我们在项目中会使用的元素，这就涉及reset的模块化使用。第二我们只需要reset必要的属性。因为reset会加重浏览器渲染的性能开销，因此我们在css reset时必须要慎之又慎，保证最少的代码量和最佳的效果之间的平衡。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Http Basic Authorization的使用</title>
    <link href="http://yoursite.com/2015/11/04/http-basic-auth/"/>
    <id>http://yoursite.com/2015/11/04/http-basic-auth/</id>
    <published>2015-11-04T05:03:42.000Z</published>
    <updated>2015-12-20T19:35:23.000Z</updated>
    
    <content type="html">&lt;p&gt;###1.Http Basic Authorization的请求格式&lt;/p&gt;
&lt;p&gt;关于发起请求的http头格式，大家可以搜到很多相关资料。这里我们采用的方式比较特别，我们用mitmproxy这款http代理软件来拦截我们在终端的通过httpie发出的请求，分析其内容，从而得出Http Basic Authorization的请求格式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先我们发送一个http POST请求：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
http --auth neo1218@yeah.net POST http://121.43.230.104:5000/api/v1.0/token
&lt;/pre&gt;

&lt;p&gt;拦截到的http header如下：&lt;br&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/blog-http-header.png&quot; alt=&quot;http-header&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们看到在http请求的header里有一个&lt;code&gt;Authorization&lt;/code&gt;字段，内容有&lt;code&gt;Basic&lt;/code&gt;标识符和一串编码组成。这串编程在经过解析之后，发现是&lt;code&gt;username:password&lt;/code&gt;的base64编码。&lt;/p&gt;
&lt;p&gt;这样就得到了我们Http Basic Authorization的请求格式，在http的请求头中加入字段格式是&lt;code&gt;Authorization : Basic base64(username:password)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###2.Http Basic Authorization客户端使用，以ajax为例&lt;/p&gt;
&lt;p&gt;下面以web端的ajax技术发起请求，来作为Http Basic Authorization客户端使用方法的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var auth = btoa($(&amp;quot;.username&amp;quot;).val()+&amp;quot;:&amp;quot;+$(&amp;quot;.password&amp;quot;).val());
this.options.userModel.fetch({
        headers:{
            &amp;quot;Authorization&amp;quot;:&amp;quot;Basic &amp;quot;+ auth
        }
    })
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是backbone中使用model的fetch api进行ajax请求的例子。在请求之前，我们配置headers字段，设置为base64编码后的auth信息。最后发送请求。&lt;/p&gt;
&lt;p&gt;这个http请求头是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/屏幕快照%202015-12-21%20上午3.29.51.png&quot; alt=&quot;http请求头&quot;&gt;&lt;/p&gt;
&lt;p&gt;ok，到这里我们就成功使用了http basic authorization来向服务器发送请求。&lt;/p&gt;
&lt;p&gt;###3.拓展阅读&lt;/p&gt;
&lt;p&gt;《Http权威指南》中有关验证的章节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###1.Http Basic Authorization的请求格式&lt;/p&gt;
&lt;p&gt;关于发起请求的http头格式，大家可以搜到很多相关资料。这里我们采用的方式比较特别，我们用mitmproxy这款http代理软件来拦截我们在终端的通过httpie发出的请求，分析其内容，从而得出Http Basic Authorization的请求格式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>ES6探秘-Classes</title>
    <link href="http://yoursite.com/2015/10/22/learn-ES6-with-babel/"/>
    <id>http://yoursite.com/2015/10/22/learn-ES6-with-babel/</id>
    <published>2015-10-22T01:23:57.000Z</published>
    <updated>2015-10-22T14:28:44.000Z</updated>
    
    <content type="html">&lt;p&gt;ES6中增加了一些新特性，但从底层的角度来说，只是一些语法糖。&lt;br&gt;但是就我个人来说，如果不了解这些语法糖的本质，是用不安心的。那我们要如何揭开这些语法糖的真实面目呢？&lt;br&gt;Babel to the rescue！ Babel是一款将ES6代码转换为ES5代码的编译器，从而让我们可以无视浏览器的支持，直接享受ES6的新特性。同时，我们也可以通过研究Babel编译出的ES5代码，来揭开ES6的面纱。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###ES6 Classes&lt;br&gt;ES6中的Classes是在Javascript现有的原型继承的基础上引入的一种语法糖。Class语法并没有引入一种新的继承模式。它为对象创建和继承提供了更清晰，易用的语法。  &lt;/p&gt;
&lt;p&gt;我们用class关键字来创建一个类，constructor关键字定义构造函数，用extends关键字来实现继承，super来实现调用父类方法。&lt;/p&gt;
&lt;p&gt;好，下面是一个ES6 class语法的完整例子：  &lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
//定义父类View
class View {
  constructor(options) {
    this.model = options.model;
    this.template = options.template;
  }

  render() {
    return _.template(this.template, this.model.toObject());
  }
}
//实例化父类View
var view = new View({
  template: &#39;Hello, &lt;%= name=&quot;&quot; %=&quot;&quot;&gt;&#39;
});
//定义子类LogView，继承父类View
class LogView extends View {
  render() {
    var compiled = super.render();
    console.log(compiled);
  }
}
&lt;/%=&gt;&lt;/pre&gt;  

&lt;p&gt;这段简短的代码就用到了上述的几个关键词。class语法的确的简洁明确，借鉴了主流OO语言的语法，更易于理解。  &lt;/p&gt;
&lt;p&gt;然而我在用这段代码时，又有些犹豫。这还是我熟悉的js原型继承吗，这真的是同一种继承模式的一个语法糖吗？  &lt;/p&gt;
&lt;p&gt;真相究竟是如何呢？我们就拿babel编译之后的代码作为切入口，来看看ES6 class语法的本质。&lt;/p&gt;
&lt;p&gt;下面是上述ES6代码用babel编译之后的结果：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;height:400px;overflow-y:scroll&quot;&gt;
&#39;use strict&#39;;
var _get = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
        var object = _x,
            property = _x2,
            receiver = _x3;
        desc = parent = getter = undefined;
        _again = false;
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
                return undefined;
            } else {
                _x = parent;
                _x2 = property;
                _x3 = receiver;
                _again = true;
                continue _function;
            }
        } else if (&#39;value&#39; in desc) {
            return desc.value;
        } else {
            var getter = desc.get;
            if (getter === undefined) {
                return undefined;
            }
            return getter.call(receiver);
        }
    }
};

var _createClass = (function() {
    function defineProperties(target, props) {
        for (var i = 0; i &lt; props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if (&#39;value&#39; in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();

function _inherits(subClass, superClass) {
    if (typeof superClass !== &#39;function&#39; &amp;&amp; superClass !== null) {
        throw new TypeError(&#39;Super expression must either be null or a function, not &#39; + typeof superClass);
    }
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError(&#39;Cannot call a class as a function&#39;);
    }
}

var View = (function() {
    function View(options) {
        _classCallCheck(this, View);
            this.model = options.model;
        this.template = options.template;
    }
    _createClass(View, [{
        key: &#39;render&#39;,
        value: function render() {
            return _.template(this.template, this.model.toObject());
        }
    }]);
    return View;
})();

var LogView = (function(_View) {
    _inherits(LogView, _View);
    function LogView() {
        _classCallCheck(this, LogView);
        _get(Object.getPrototypeOf(LogView.prototype), &#39;constructor&#39;, this).apply(this, arguments);
    }
    _createClass(LogView, [{
        key: &#39;render&#39;,
        value: function render() {
            var compiled = _get(Object.getPrototypeOf(LogView.prototype), &#39;render&#39;, this).call(this);
            console.log(compiled);
        }
    }]);
    return LogView;  

})(View);
&lt;/pre&gt;

&lt;p&gt;这段代码很长，我们只关注里面的函数，可以得到它的结构如下:&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;height:400px;overflow-y:scroll&quot;&gt;
//用于得到原型链上属性的方法的函数
var _get = function get(_x, _x2, _x3) {
    //······
}

//用于创建对象的函数
var _createClass = (function() {
     //内部函数，定义对象的属性
    function defineProperties(target, props) {
        //······
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();

//用于实现继承的函数
function _inherits(subClass, superClass) {
        //······
        subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
});

var View = (function() {
    //······
    return View;
})();

var LogView = (function(_View) {
    //······
})(View);
&lt;/pre&gt;


&lt;p&gt;###View类的实现&lt;/p&gt;
&lt;p&gt;我们从一个View类的创建开始分析&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
class View {
  constructor(options) {
    this.model = options.model;
    this.template = options.template;
  }
  render() {
    return _.template(this.template, this.model.toObject());
  }
}

//ES5代码
var View = (function() {
    function View(options) {
        _classCallCheck(this, View);
            this.model = options.model;
        this.template = options.template;
    }
    _createClass(View, [{
        key: &#39;render&#39;,
        value: function render() {
            return _.template(this.template, this.model.toObject());
        }
    }]);
    return View;
})();

&lt;/pre&gt;
我们从编译之后的代码中可以看出，View是一个IIFE，里面是一个同名的函数View，这个函数经过  `_createClass()`函数的处理之后，被返回了。所以我们得出的第一点结论就是，**ES6中的class实际就是函数**。当然这点在各种文档中已经明确了，所以让我们继续分析。 

IIFE中的同名的View实际上就是我们在ES5的原型继承中使用的构造函数，所以ES6中的class是对ES5中的构造函数的一种包装。我们发现，在class中设定的属性被放在ES5的构造函数中，而方法则以键值对的形式传入一个`_createClass()`函数中。那么这个`_createClass()`函数又制造了什么魔法呢？  

&lt;pre class=&quot;prettyprint&quot;&gt;
var _createClass = (function() {
    function defineProperties(target, props) {
        for (var i = 0; i &lt; props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if (&#39;value&#39; in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();
&lt;/pre&gt; 

&lt;p&gt;&lt;code&gt;_createClass&lt;/code&gt;也是一个IIFE，有一个内部的函数&lt;code&gt;defineProperties&lt;/code&gt;，这个函数遍历属性的描述符，进行描述符的默认设置，最后使用&lt;code&gt;Object.defineProperty()&lt;/code&gt;方法来写入对象的属性。IIFE的renturn部分有两个分支，一个是针对一个类的原型链方法，一个是静态方法，我们看到原型链方法被写入构造函数的原型对象里，&lt;strong&gt;而静态方法则被直接写入构造函数里，因此我们不用实例化对象就可以直接调用一个类的静态方法了&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;js中的函数是对象，Function构造函数的prototype指向Object.prototype，因此可以写入属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###类继承的实现&lt;/p&gt;
&lt;p&gt;OK，到目前我们已经搞清了ES6的class关键字是如何工作的，那么ES6中的继承有是如何实现的呢？下面让我们看看&lt;code&gt;_inherits()&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
function _inherits(subClass, superClass) {
    if (typeof superClass !== &#39;function&#39; &amp;&amp; superClass !== null) {
        throw new TypeError(&#39;Super expression must either be null or a function, not &#39; + typeof superClass);
    }
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_inherits()&lt;/code&gt;函数的关键部分便是&lt;code&gt;subClass.prototype = Object.create(···)&lt;/code&gt;。通过&lt;code&gt;Object.create()&lt;/code&gt;方法来指定新创建对象的原型，由此省去了对父类构造函数的处理，达到了简单的原型继承效果。&lt;/p&gt;
&lt;p&gt;然后我们来看看创建&lt;code&gt;LogView&lt;/code&gt;类的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
//ES6
class LogView extends View {
  render() {
    var compiled = super.render();
    console.log(compiled);
  }
}
//ES5
var LogView = (function(_View) {
    _inherits(LogView, _View);
    function LogView() {
        _classCallCheck(this, LogView);
        _get(Object.getPrototypeOf(LogView.prototype), &#39;constructor&#39;, this).apply(this, arguments);
    }
    _createClass(LogView, [{
        key: &#39;render&#39;,
        value: function render() {
            var compiled = _get(Object.getPrototypeOf(LogView.prototype), &#39;render&#39;, this).call(this);
            console.log(compiled);
        }
    }]);
    return LogView;
})(View);
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LogView&lt;/code&gt;类和&lt;code&gt;View&lt;/code&gt;类的最大不同便是增加了一个&lt;code&gt;_get()&lt;/code&gt;函数的调用，我们仔细看这个&lt;code&gt;_get()&lt;/code&gt;函数会发现它接收几个参数，子类的原型，”constructor”标识符，还有&lt;code&gt;this&lt;/code&gt;。再看下面对&lt;code&gt;super.render()&lt;/code&gt;的处理，同样是用&lt;code&gt;_get()&lt;/code&gt;函数来处理的。再看&lt;code&gt;_get()&lt;/code&gt;函数的源码，就可以发现&lt;code&gt;_get()&lt;/code&gt;函数的作用便是遍历对象的原型链，找出传入的标识符对应的属性，把它用&lt;code&gt;apply&lt;/code&gt;绑定在当前上下文上执行。&lt;/p&gt;
&lt;p&gt;大家是不是对这种继承模式似曾相识呢？对了，这就是所谓的“构造函数窃取”。当我们需要继承父类的属性时，在子类的构造函数内部调用父类构造函数，在加上&lt;code&gt;Object.create()&lt;/code&gt;大法，然后就可以继承父类的所有属性和方法了。&lt;/p&gt;
&lt;p&gt;###结语&lt;br&gt;以上就是笔者对ES6中的class做的一些解读，依据是babel的编译结果。今天刚好看到getify大神的一篇&lt;a href=&quot;http://blog.getify.com/arrow-this/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;，将的是ES6中的箭头函数其实并不是一个语法糖，而是一种新的不带this的函数。他还进一步说了，错误的过程得到正确的结果，会导致很多后续的问题。&lt;/p&gt;
&lt;p&gt;而本文的结论是建立在class是一种语法糖的基础之上的，根据MDN的文档，我们应该可以确认这个结论是可靠的。而ES6中的特性，如箭头函数，并不都是语法糖，因此在后续的ES6探秘文章中，我们将用其他的途径，来揭示ES6种种神奇魔法的秘密。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ES6中增加了一些新特性，但从底层的角度来说，只是一些语法糖。&lt;br&gt;但是就我个人来说，如果不了解这些语法糖的本质，是用不安心的。那我们要如何揭开这些语法糖的真实面目呢？&lt;br&gt;Babel to the rescue！ Babel是一款将ES6代码转换为ES5代码的编译器，从而让我们可以无视浏览器的支持，直接享受ES6的新特性。同时，我们也可以通过研究Babel编译出的ES5代码，来揭开ES6的面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>面向前端模块化的web端设计准则</title>
    <link href="http://yoursite.com/2015/09/27/web-desgin-issues-with-fe/"/>
    <id>http://yoursite.com/2015/09/27/web-desgin-issues-with-fe/</id>
    <published>2015-09-27T06:07:40.000Z</published>
    <updated>2015-09-27T09:25:42.000Z</updated>
    
    <content type="html">&lt;p&gt;一个了解前端页面实现的设计师做出的设计可以让前端工程师事半功倍，而一个不了解前端实现基本知识的设计师的作品，在实际的操作中会让前端工程师叫苦不迭。所以我写这篇博客是想讲一下一些前端实现的流程和思想，其中有很大一部分是建立在一个前提之下的，那就是设计师的设计稿考虑到了一些模块化，可复用的思想，并且是按这些标准来进行设计的。&lt;/p&gt;
 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###1. 前端页面实现的流程&lt;br&gt;一般来说，一个web端产品有好几个页面组成，前端工程师会首先分析页面的结构和模块，这属于页面的架构部分。而在页面的样式部分，则需要提取出页面的主要设计元素（色值，字号，margin，padding等等）。&lt;br&gt;你可能会问，为什么要提取呢，直接做页面，到时候去看一下色值和字号是什么不就行了？&lt;br&gt;问的好，按那样做的确是可以，然而现在的产品比较复杂，css虽然不是一种编程语言，但是less，sass等技术给css添加了一些编程语言才有的特性，比如变量，嵌套，mixin等等。这样我们在使用sass之类的异构语言写css时，就可以将css分门别类，每个模块写一个专门的sass文件，将页面上可以复用的css代码段提取出来，在各个模块之中调用，达到提高效率的目的。&lt;br&gt;我这么说可能还是不够具体，拿学而来说，整个产品中有这样几种色值：&lt;br&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202015-09-27%20at%202.54.58%20PM.png&quot; alt=&quot;学而色值&quot;&gt;&lt;br&gt;&lt;em&gt;p.s.这里只列出了最主要的颜色。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用sass代码写就是这样  &lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;br&gt;$mainColorGreen:#92CF67;&lt;br&gt;$mainColorGray:F7F8FA;&lt;br&gt;$fontColorDark:#666;&lt;br&gt;$fontColorLight:#999;&lt;br&gt;&lt;/pre&gt;&lt;br&gt;这样我们就告别了符号化的16进制颜色代码，从而可以用语义化的变量来调用颜色值，每当我们要使用颜色值的时候，只要这样调用就可以了：  &lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;br&gt;.main{&lt;br&gt;    background-color:$mainColorGray;&lt;br&gt;}&lt;br&gt;.title{&lt;br&gt;    color:$fontColorDark;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;从而将颜色值统一管理，大大加强了可复用性。&lt;/p&gt;
&lt;p&gt;对于其他的数值类型的样式比如字号，边距，也是同样的做法，前端工程师在写样式时会首先提取这些通用的元素。&lt;br&gt;因此如果设计师懂得前端的流程，并按相应的准则来设计，那么前端工程师就可以提取到大量的信息。事实上，如果有标注这个流程，那么设计师在标注时便可以总结出自己设计稿中的一些可以复用的元素，相比之下，设计师更了解自己的作品，因此在总结时会更加的轻松自如。标注这一部分将在2.4节中介绍。&lt;br&gt;反之，如果设计师不按约定的准则来设计，那么前端工程师便很难提取出相同的元素（因为设计的时候压根就没考虑这个！），造成前端的样式混乱，开发效率大大下降。&lt;/p&gt;
&lt;p&gt;###2. 一些面向前端模块化的设计准则&lt;/p&gt;
&lt;p&gt;####2.1 样式复用&lt;br&gt;这些元素包括，颜色值，字体的字号，边距等    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;颜色值&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;之前在第一节中便举了颜色复用的例子，这里再拿学而作为例子，比如学而中的课程信息页：&lt;br&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202015-09-27%20at%203.28.16%20PM.png&quot; alt=&quot;课程信息页&quot;&gt;&lt;br&gt; 搜索框和评论框的边框色是一样的，这就方便了前端工程师的代码复用。而从视觉上来说，搜索框和评论框作为两个组件，在UI上的风格是相近的。&lt;br&gt; 所以基本的原则就是控制整个项目中使用的颜色的数量，在相似的组件上复用色值或者其他的数值，在使用一种新的颜色之前，请想一想，是否可以用现有的颜色而不是引入一种新的颜色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字号&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;字号的原则也是在页面中不要引入过多的不同字号。因为我们在前端中使用相对字号，所以一般我们定一种基础的字号，作为主要的正文的字号。而标题等元素的字号大小则定为基础字号的倍数，一般是一位小数倍，比如1.2、1.5、1.8等。比如在学而中存在32px,24px,17px,16px,14px,12px这些字号，我们将12px定为base字号，那么24px便是12px的两倍，用2rem表示，16px则是1.33rem，不是有理数，因此在设计中应该加以避免（在视觉效果满足要求的前提下，16px可以改为15px，这样就是1.25rem）（或者在最初设计之时就加以规划）。&lt;br&gt;然而这些字号还是太散乱了，在一个组件（模块）中使用三级字体是比较合理的选择，而组件之间的字号值可以重合，从而使整个产品的字号系统大大简化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;边距&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;在一个组件中，可能存在很多不同的边距值，这次问题的关键不是不同边距值的数量，而是边距之间的倍数关系。如果边距之间是整数倍的，那么在sass中便可以使用运算符来进行边距的计算，比如:  &lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;br&gt;$marginBase:10px;&lt;br&gt;$paddingBase:20px;&lt;br&gt;.box{&lt;br&gt;    margin:$marginBase $marginBase*2;&lt;br&gt;    padding-top:$paddingBase/2;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;这就要求我们在设计时对边距进行一些计算，从而在保证视觉效果的前提之下，使边距达到一个倍数的关系。 &lt;/p&gt;
&lt;p&gt;一个反面例子：    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202015-09-27%20at%204.06.04%20PM_spec.png&quot; alt=&quot;学而首页热门课程组件&quot;&gt;  &lt;/p&gt;
&lt;p&gt;这是学而首页的热门课程组件，其中纵向的边距每一个的不同，而且之间没有任何倍数关系，这就给边距的计算带来了麻烦。  &lt;/p&gt;
&lt;p&gt;####2.2 页面模块化&lt;br&gt;之前在第一节中讲过，在开发中，前端工程师会对页面进行模块的划分，然后分别开发。因此设计师在设计时，就要注意这种模块化、组件化的思路。  &lt;/p&gt;
&lt;p&gt;这是学而首页的模块划分：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/xueer.png&quot; alt=&quot;学而首页&quot;&gt;  &lt;/p&gt;
&lt;p&gt;为什么要进行模块划分呢？首先，拿学而来说，首页有的导航和页脚两个模块在其他页面中都会用到，所以我们将它们分出来来达到一个复用的效果。对于其他模块，实际上我们在其他页面中并不会复用，但我们还是要用一种模块化的思维来看。   &lt;/p&gt;
&lt;p&gt;什么是模块化的思维呢？其实就将一个模块设计成一个相对独立的个体，它继承了整个产品的基础设计风格，简而言之就是一些通用的样式，比如色值，字体，字号，边距。但它是相对独立的，可以独立的完成一个功能，与其他的模块并没有耦合的关系。也就是说，这个模块是可以拔插的，加入这个模块，便获得了相应的功能，而移除这个模块，整个页面在功能上不会受太大的影响，当然视觉效果上会受影响。所以设计师要考虑的就是如何设计相互独立的模块并且布局（比如两个模块在页面上有部分重叠，就是一个不太好的实践）。 &lt;/p&gt;
&lt;p&gt;学而的首页便是一个高度模块化的页面，我们将一些功能模块，如猜你喜欢移除，换成其他的模块，整个页面在视觉上和功能上都不会受影响，只是没有了猜你喜欢这个特定的模块罢了。  &lt;/p&gt;
&lt;p&gt;模块化的页面设计，对于后续的产品升级和维护，也是很有利的。&lt;/p&gt;
&lt;p&gt;####2.3 UI组件系统化&lt;br&gt;UI组件和上一小节中所说的模块有什么不同呢?&lt;br&gt;相比于带有逻辑、能完成独立功能的模块，UI组件不带有逻辑，是用于完成UI交互功能的某个小组件。所以UI组件相比与模块来说细粒度要更小一些。各个模块可以重复使用站点的UI组件，来达到一种视觉风格的统一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202015-09-27%20at%205.00.34%20PM.png&quot; alt=&quot;UI&quot;&gt;&lt;br&gt;&lt;em&gt;学而的UI组件&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;关于UI组件，我相信就不用我班门弄斧了，设计师们在设计一个产品时所设计的UI组件自然是系统化的。  &lt;/p&gt;
&lt;p&gt;一套系统的UI组件，可以在代码中用独立的文件进行引用，因此这是加强页面组件化的一大利器。对此我的建议就是在做页面的同时维护一张UI组件清单，这样可以直观的组织已有的UI组件，同时在开发时，也可以交给前端进行UI组件的快速整理和开发。  &lt;/p&gt;
&lt;p&gt;####2.4 关于标注&lt;br&gt;关于标注，做的好可以给前端工程师带来巨大的效率提升，但如果不懂得前端开发的一些常识，标注也可以变得毫无用处。&lt;/p&gt;
&lt;p&gt;关于页面色值，字号，边距的标注比较复杂，可以单独写一篇博文来讲，这里就不详述了。 &lt;/p&gt;
&lt;p&gt;而另一个意义重大的标注便是UI组件的清单，比如：&lt;br&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/index_uikit.png&quot; alt=&quot;UI&quot;&gt;  &lt;/p&gt;
&lt;p&gt;这个清单对于设计师整理自己的UI组件和前端工程师快速开发都是很有利的。&lt;/p&gt;
&lt;p&gt;###3. 结语&lt;br&gt;如果设计师能了解了这些前端开发的常识，并且把这些准则在设计中运用起来，那么我相信前端工程师和设计师之前的合作可以更加的流畅。前端工程师是设计稿的最终实践者，所以如果工程师和设计师之间能去除了一些认知障碍，达成共识，开发效率一定可以得到很大程度的提升。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一个了解前端页面实现的设计师做出的设计可以让前端工程师事半功倍，而一个不了解前端实现基本知识的设计师的作品，在实际的操作中会让前端工程师叫苦不迭。所以我写这篇博客是想讲一下一些前端实现的流程和思想，其中有很大一部分是建立在一个前提之下的，那就是设计师的设计稿考虑到了一些模块化，可复用的思想，并且是按这些标准来进行设计的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Angular源码分析:$q</title>
    <link href="http://yoursite.com/2015/08/24/angulr-q-js/"/>
    <id>http://yoursite.com/2015/08/24/angulr-q-js/</id>
    <published>2015-08-24T07:27:51.000Z</published>
    <updated>2015-08-28T09:51:16.000Z</updated>
    
    <content type="html">&lt;p&gt;###概述&lt;br&gt;Augular中的$q服务提供了Promise的实现，这个服务叫做“q”是因为它是&lt;a href=&quot;https://github.com/kriskowal/q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kris Kowal’s Q&lt;/a&gt;的一种植入。  &lt;/p&gt;
&lt;p&gt;从Augular中$q服务的文档中可以了解到，这个服务有两种用法，一种在某种程度上和ES6的Promise规范相似，而另一种则和Q以及jQuery的Deferred接口类似。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;因此在Angular中$q的具体代码实现有两种，一种是将$q作为一个构造函数，并且接收一个&lt;code&gt;resolver()&lt;/code&gt;函数作为唯一参数。这和ES6的原生实现相似：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
// for the purpose of this example let&#39;s assume that variables `$q` and `okToGreet`
// are available in the current lexical scope (they could have been injected or passed in).

function asyncGreet(name) {
  // perform some asynchronous operation, resolve or reject the promise when appropriate.
  return $q(function(resolve, reject) {
    setTimeout(function() {
      if (okToGreet(name)) {
        resolve(&#39;Hello, &#39; + name + &#39;!&#39;);
      } else {
        reject(&#39;Greeting &#39; + name + &#39; is not allowed.&#39;);
      }
    }, 1000);
  });
}

var promise = asyncGreet(&#39;Robin Hood&#39;);
promise.then(function(greeting) {
  alert(&#39;Success: &#39; + greeting);
}, function(reason) {
  alert(&#39;Failed: &#39; + reason);
});
&lt;/pre&gt;

&lt;p&gt;而另一种实现则是更为传统的CommonJS风格的实现，将Promise描述成一个接口，来和一个代表了未来结果的异步请求发生交互。&lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
// for the purpose of this example let&#39;s assume that variables `$q` and `okToGreet`
// are available in the current lexical scope (they could have been injected or passed in).

function asyncGreet(name) {
  var deferred = $q.defer();

  setTimeout(function() {
    deferred.notify(&#39;About to greet &#39; + name + &#39;.&#39;);

    if (okToGreet(name)) {
      deferred.resolve(&#39;Hello, &#39; + name + &#39;!&#39;);
    } else {
      deferred.reject(&#39;Greeting &#39; + name + &#39; is not allowed.&#39;);
    }
  }, 1000);

  return deferred.promise;
}

var promise = asyncGreet(&#39;Robin Hood&#39;);
promise.then(function(greeting) {
  alert(&#39;Success: &#39; + greeting);
}, function(reason) {
  alert(&#39;Failed: &#39; + reason);
}, function(update) {
  alert(&#39;Got notification: &#39; + update);
});

&lt;/pre&gt;


&lt;p&gt;##源码分析：deferred API&lt;br&gt;因为$q服务中的ES6形式实现实际上是在deferred api的基础上的一种封装实现，所以我们先来看看deferred API的源代码。&lt;br&gt;这部分代码的结构看起来是这样的：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
//deferred method: return a instance of Deferred object
var deferred = function() {
    return new Deferred();
};

//construct function of Promise object
function Promise() {
    this.$$state = { status: 0 };
}

//then, catch, and finally method of Promise object
extend(Promise.prototype, {
    then: function(onFulfilled, onRejected, progressBack) {
      //...
    },

    &quot;catch&quot;: function(callback) {
      //...
    },

    &quot;finally&quot;: function(callback, progressBack) {
      //...
    }
});


//construct function of Deferred object, the promise object is a method 
//of Deferred object. And resolve, reject, notify apis are binded here.
function Deferred() {
    this.promise = new Promise();
    //Necessary to support unbound execution :/
    this.resolve = simpleBind(this, this.resolve);
    this.reject = simpleBind(this, this.reject);
    this.notify = simpleBind(this, this.notify);
}



extend(Deferred.prototype, {
    resolve: function(val) {
        //...
    },

    $$resolve: function(val) {
        //...
    },

    reject: function(reason) {
        //...
    },

    $$reject: function(reason) {
        //...
    },

    notify: function(progress) {
           //...
    }
  });

&lt;/pre&gt;


&lt;p&gt;###具体分析：Deferred.promise.then()&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
then: function(onFulfilled, onRejected, progressBack) {
       //check if at least one para was passed in, otherwise return.
      if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {
        return this;
      }
      //instantiate a new Deferred object as result
      var result = new Deferred();

       //instantiate $$state.pending
      this.$$state.pending = this.$$state.pending || [];
      //push paras of this into $$state.pending array
      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
      //if $$state.status changed, add this.$$state to the process 
      queue
      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);

      //return the new Deferred object instance&#39;s promise object
      return result.promise;
}
&lt;/pre&gt;

&lt;p&gt;then()方法接收三个参数，promise条件满足时执行的函数&lt;code&gt;onFulfilled&lt;/code&gt;，被拒绝时的回调函数&lt;code&gt;onRejected&lt;/code&gt;，以及一个通知用回调函数&lt;code&gt;progressBack&lt;/code&gt;。&lt;br&gt;这里的逻辑是&lt;code&gt;then()&lt;/code&gt;方法接收参数之后，实例化一个新&lt;code&gt;Deferred&lt;/code&gt;对象，并将参数推入pending数组中。&lt;br&gt;关于then,有趣的一点在于then的链式调用的实现，在分析这点之前，我们把目光移到这个api的大局上来，看看promise的状态变化以及状态转移是如何实现的。&lt;/p&gt;
&lt;p&gt;###具体分析：Deferred.resolve()&lt;/p&gt;
&lt;p&gt;在promise对象内部，收到请求后具体执行状态转移的便是&lt;code&gt;resolve()&lt;/code&gt;和&lt;code&gt;reject()&lt;/code&gt;函数了，我们还可以向其中传递一个唯一的参数，来作为&lt;code&gt;resolve()&lt;/code&gt;的value或是&lt;code&gt;reject()&lt;/code&gt;的reason。因为这两个方法原理大致类似（在源码中这两个方法的相关代码有较大的不同，应该和这个两种行为不同的结果有关），所以我们就以&lt;code&gt;resolve()&lt;/code&gt;方法为例来说明。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
resolve: function(val) {
        //if $$state not equals 0, which means the state had already 
        changed, return.
      if (this.promise.$$state.status) return;
      //reject if val is this.promise its self.
      if (val === this.promise) {
        this.$$reject($qMinErr(
          &#39;qcycle&#39;,
          &quot;Expected promise to be resolved with value other than itself &#39;{0}&#39;&quot;,
          val));
      } else {
      //resolve val with inner method $$resolve
        this.$$resolve(val);
      }

    },

$$resolve: function(val) {
      var then, fns;
      //warp the functions in order to be called only once
      fns = callOnce(this, this.$$resolve, this.$$reject);
      try {
        if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then;
        if (isFunction(then)) {
          this.promise.$$state.status = -1;
          then.call(val, fns[0], fns[1], this.notify);
        } else {
          this.promise.$$state.value = val;
          this.promise.$$state.status = 1;
          scheduleProcessQueue(this.promise.$$state);
        }
      } catch (e) {
        fns[1](e);
        exceptionHandler(e);
      }
}
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolve()&lt;/code&gt;方法接收一个值val，这个值可能是对象/函数，也有可能是普通的数值或是字符串。&lt;code&gt;resolve()&lt;/code&gt;方法首先判断&lt;code&gt;Deferred.promise.$$state.status&lt;/code&gt;的值是否不为0，如果不为0则说明状态已经转移了，那么就不再继续执行。如果一切正常，在执行&lt;code&gt;resolve()&lt;/code&gt;方法时，&lt;code&gt;Deferred.promise.$$state.status&lt;/code&gt;的值为初始的0，然后val被传入一个内部函数&lt;code&gt;$$resolve()&lt;/code&gt;,来进行真正的处理。&lt;code&gt;$$resolve()&lt;/code&gt;函数首先调用&lt;code&gt;callOnce()&lt;/code&gt;函数来确保自己只被调用一次，然后判断val的数据类型，如果是对象或者是函数，则将val赋值给then，其中&lt;code&gt;then = val &amp;amp;&amp;amp; val.then;&lt;/code&gt;这个语句用来将&lt;code&gt;resolve()&lt;/code&gt;中可能传入的promise对象的&lt;code&gt;then()&lt;/code&gt;方法赋值给then。下一步，如果then是函数，也就是说传入的val是一个promise对象的话，则将&lt;code&gt;Deferred.promise.$$state.status&lt;/code&gt;的值设为-1，之后&lt;code&gt;then.call(val, fns[0], fns[1], this.notify);&lt;/code&gt;这是将fns[0], fns[1], this.notify三个函数作为参数传入了这个promise对象的then方法中，其中前两者便是经过了&lt;code&gt;callOnce()&lt;/code&gt;函数处理的&lt;code&gt;this.$$resolve&lt;/code&gt;和&lt;code&gt;this.$$reject&lt;/code&gt;函数，这一步设置了被传入的promise对象的pending list。&lt;br&gt;如果val不是函数，那么接下去的逻辑便很容易理解了，&lt;code&gt;this.promise.$$state.value&lt;/code&gt;被赋值为val的值，&lt;code&gt;this.promise.$$state.status&lt;/code&gt;的值被设置为1，1这个状态码便代表了promise对象目前处于&lt;strong&gt;fulfilled&lt;/strong&gt;状态。&lt;br&gt;接下去调用&lt;code&gt;scheduleProcessQueue()&lt;/code&gt;函数，并传入&lt;code&gt;this.promise.$$state&lt;/code&gt;对象。这个函数实际是调用了&lt;code&gt;ProcessQueue()&lt;/code&gt;函数，不过加入了一些angular内部的检查机制，来保证函数调用和angular内部运行的同步。而&lt;code&gt;ProcessQueue()&lt;/code&gt;函数则真正执行&lt;code&gt;then()&lt;/code&gt;方法推入到pending list中的回调函数。  &lt;/p&gt;
&lt;p&gt;下面我们简单的来看看ProcessQueue函数:&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
function processQueue(state) {
    var fn, deferred, pending;

    pending = state.pending;
    state.processScheduled = false;
    state.pending = undefined;
    for (var i = 0, ii = pending.length; i &lt; ii; ++i) {
      deferred = pending[i][0];
      fn = pending[i][state.status];
      try {
        if (isFunction(fn)) {
          deferred.resolve(fn(state.value));
        } else if (state.status === 1) {
          deferred.resolve(state.value);
        } else {
          deferred.reject(state.value);
        }
      } catch (e) {
        deferred.reject(e);
        exceptionHandler(e);
      }
    }
  }
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;processQueue()&lt;/code&gt;函数简单地将当前promise对象的pending list按传入的状态码进行处理。&lt;code&gt;fn = pending[i][state.status];&lt;/code&gt;中，status为1，那么就调用pending list的第二项，也就是onFulfilled情况下的回调函数。之后&lt;br&gt;&lt;code&gt;deferred.resolve(fn(state.value));&lt;/code&gt;中，实际上执行了一次&lt;code&gt;eval(fn(state.value))&lt;/code&gt;,回调函数就是在这里被执行的，之后&lt;code&gt;deferred.resolve(val)&lt;/code&gt;便将回调函数处理之后的值传给了新创建的deferred对象。&lt;/p&gt;
&lt;p&gt;###实例分析：Deferred.promise.then()的链式调用机制&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
          var Deferred = $q.defer();
          var promise1 = Deferred.promise;
          var promise2 = promise1.then(function (data) {
                 return data  + 1;
          });
          promise2.then(function (val) {
               console.log(val);
          }); 
          Deferred.resolve(10);
&lt;/pre&gt;

&lt;p&gt;这段代码的预期结果是promise2的回调函数会输出11。让我们来看看这是怎样实现的。&lt;/p&gt;
&lt;p&gt;首先，promise1的&lt;code&gt;then()&lt;/code&gt;方法被执行,回调函数被推入pending list中，一个新的&lt;code&gt;deferred&lt;/code&gt;对象被创建,&lt;code&gt;deferred.promise&lt;/code&gt;对象被返回，我们将这个新创建的promise对象赋值给promise2。同样的，promise2的&lt;code&gt;then()&lt;/code&gt;方法也被执行。所以我们把promise1的pending list称谓list1，promise2的pending list称为list2。&lt;/p&gt;
&lt;p&gt;之后，&lt;code&gt;Deferred.resolve(10);&lt;/code&gt;被执行，在这里这是同步的，但一般来说这是异步执行的。此时执行resolve()方法，后数据被传入内部的&lt;code&gt;$$resolve()&lt;/code&gt;方法，因为val是数值，因此&lt;code&gt;$$state&lt;/code&gt;对象的value被设置为10，而状态码也被设置为相应的1，代表解析成功。  &lt;/p&gt;
&lt;p&gt;之后的任务交给了&lt;code&gt;processQueue()&lt;/code&gt;函数，因为list1中的第二个参数是我们通过&lt;code&gt;then()&lt;/code&gt;方法传入的回调函数，这个函数执行&lt;code&gt;deferred.resolve(fn(state.value));&lt;/code&gt;，回调函数执行，并返回值11，这里的deferred对象便是promise1的&lt;code&gt;then()&lt;/code&gt;方法创建的新deferred对象，也就是list1中的deferred对象，是promise2的宿主对象。  &lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;deferred.resolve(fn(state.value));&lt;/code&gt;的执行，执行了又一次&lt;code&gt;resolve()&lt;/code&gt;函数，只是这次的上下文换成了promise2所在的上下文，那么接下去的流程便和promise1发生的一致了。最后list2中的回调执行，输出值11。&lt;/p&gt;
&lt;p&gt;让我们总结一下，&lt;code&gt;then()&lt;/code&gt;方法实际上是负责在运行时挂载回调函数列表，而&lt;code&gt;resolve()&lt;/code&gt;函数则负责异步触发函数执行。链式调用是通过返回新promise对象，并配合&lt;code&gt;then()&lt;/code&gt;方法的同步加载回调以便获取新上下文来实现的。&lt;/p&gt;
&lt;p&gt;tbc···&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://olim7t.github.io/2013/08/19/angular-promise-implementation.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考-A look at Angular’s promise implementation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###概述&lt;br&gt;Augular中的$q服务提供了Promise的实现，这个服务叫做“q”是因为它是&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal’s Q&lt;/a&gt;的一种植入。  &lt;/p&gt;
&lt;p&gt;从Augular中$q服务的文档中可以了解到，这个服务有两种用法，一种在某种程度上和ES6的Promise规范相似，而另一种则和Q以及jQuery的Deferred接口类似。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular" scheme="http://yoursite.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://yoursite.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>实战之IE兼容常见问题</title>
    <link href="http://yoursite.com/2015/07/25/ie-fix/"/>
    <id>http://yoursite.com/2015/07/25/ie-fix/</id>
    <published>2015-07-25T03:40:10.000Z</published>
    <updated>2015-07-25T12:12:55.000Z</updated>
    
    <content type="html">&lt;p&gt;最近因为在实习，所以做的东西要测试，做了IE8的兼容，对IE8的常见CSS兼容问题有了一点认识，在这里总结一下。&lt;/p&gt;
&lt;p&gt;###Html5标签问题&lt;/p&gt;
&lt;p&gt;IE8不支持Html5的语义化新标签，&lt;code&gt;&amp;lt;header&amp;gt;,&amp;lt;nav&amp;gt;,&amp;lt;footer&amp;gt;&lt;/code&gt;之类。对此Google出了一个html5shiv.js，来实现这些标签。&lt;/p&gt;
&lt;p&gt; 这个html5shiv.js的原理就是使用document.createElement()这个dom方法来动态创建一个html元素对象。html5shiv.js中处理了IE在这个方法上的一些问题（某些元素动态加入的属性不管用），还提供了api，以及基础的CSS，使得元素在默认的display属性为block。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###RGBA支持问题&lt;/p&gt;
&lt;p&gt;IE8不支持rgba这种颜色的表示方式，但我们如果在背景色使用rgba的话，还是有替代方案的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//IE8下
filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19fff
 fff,endColorstr=#19ffffff);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这句代码其实是用来实现渐变的，不过我们把startColor和endColor设成一样的便可以用来设置纯色背景了。&lt;/p&gt;
&lt;p&gt;startColor的后六位便是正常的十六进制颜色代码，而前两位是alpha通道，对应关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;透明度&lt;/th&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;td&gt;4C&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.5&lt;/td&gt;
&lt;td&gt;7F&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;99&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;td&gt;B2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.8&lt;/td&gt;
&lt;td&gt;C8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.9&lt;/td&gt;
&lt;td&gt;E5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;###CSS3支持&lt;/p&gt;
&lt;p&gt;这部分是硬伤，media query有成熟的方案支持，但是像border-radius这种虽也有办法可以实现，但是太过于麻烦。我们毕竟得move on，不能太过拘泥，有些时候平稳退化，优雅降级就可以了。&lt;/p&gt;
&lt;h3 id=&quot;To-Be-Contiued···&quot;&gt;&lt;a href=&quot;#To-Be-Contiued···&quot; class=&quot;headerlink&quot; title=&quot;To Be Contiued···&quot;&gt;&lt;/a&gt;To Be Contiued···&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为在实习，所以做的东西要测试，做了IE8的兼容，对IE8的常见CSS兼容问题有了一点认识，在这里总结一下。&lt;/p&gt;
&lt;p&gt;###Html5标签问题&lt;/p&gt;
&lt;p&gt;IE8不支持Html5的语义化新标签，&lt;code&gt;&amp;lt;header&amp;gt;,&amp;lt;nav&amp;gt;,&amp;lt;footer&amp;gt;&lt;/code&gt;之类。对此Google出了一个html5shiv.js，来实现这些标签。&lt;/p&gt;
&lt;p&gt; 这个html5shiv.js的原理就是使用document.createElement()这个dom方法来动态创建一个html元素对象。html5shiv.js中处理了IE在这个方法上的一些问题（某些元素动态加入的属性不管用），还提供了api，以及基础的CSS，使得元素在默认的display属性为block。&lt;/p&gt;
    
    </summary>
    
      <category term="兼容 实战" scheme="http://yoursite.com/categories/%E5%85%BC%E5%AE%B9-%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="兼容 实战" scheme="http://yoursite.com/tags/%E5%85%BC%E5%AE%B9-%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>最佳实践之多个高度不定水平实体垂直居中</title>
    <link href="http://yoursite.com/2015/07/23/vertical-align-middle/"/>
    <id>http://yoursite.com/2015/07/23/vertical-align-middle/</id>
    <published>2015-07-23T14:35:05.000Z</published>
    <updated>2015-07-25T10:09:25.000Z</updated>
    
    <content type="html">&lt;p&gt;如何快速并且健壮地实现高度不一定的实体的居中呢？  &lt;/p&gt;
&lt;p&gt;vertical-align显然是一种办法。这个元素从语义上来看就是用来实现垂直对齐的。要理解vertical-align，首先我们得了解几个概念，inline boxes, line box, 以及baseline。  &lt;/p&gt;
&lt;p&gt;inline boxes是行内元素构成的行内box，而line box则是由一行内所有的inline boxes构成的box，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;我是inline box&amp;lt;/span&amp;gt;
    我是匿名inline box
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了display为inline或者inline-block的标签会形成inline box，行内文本也会形成匿名的inline box。&lt;/p&gt;
&lt;p&gt;一行所有的inline boxes构成匿名的line box，其中inline box中高度最高的那个的高度便是line box的高度，由此撑起了整行的高度。（这涉及到line-height方面的知识）&lt;/p&gt;
&lt;p&gt;而关于baseline，则是文字在排版时顶部与底部中间的基线，如果是行内文本，具体位置随字体不同而不同，一般都在中线以下的位置。具体的需要参考西文字体学（Typography）(Jobs在大学旁听的课程之一，你值得拥有)  &lt;/p&gt;
&lt;p&gt;而line—height其实就是两条基线之间的距离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/blog_7_24_1.png&quot; alt=&quot;baseline&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于inline-block级元素来说，基线的定义是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The baseline of an &amp;#39;inline-block&amp;#39; is the baseline of its last line
box in the normal flow, unless it has either no in-flow line boxes
or if its &amp;#39;overflow&amp;#39; property has a computed value other than
&amp;#39;visible&amp;#39;, in which case the baseline is the bottom margin edge.
（CSS2.1 W3C）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 一般是正常文档流中的最后一个line box的基线。&lt;/p&gt;
&lt;p&gt;我们面对的场景是这样的，一个高度固定的div，中间有数个高度不固定的div需要被垂直居中。让我们来看看vertical-align:middle的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Align the vertical midpoint of the box with the baseline of the
parent box plus half the x-height of the parent.（CSS2.1 W3C）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; （元素）的垂直中点与父元素的基线加上x轴高度的一半对齐。&lt;/p&gt;
&lt;p&gt; 听起来有点奇怪，什么是x-height呢，x-height其实就是上图中小写字母x占据的高度，西文字体中小写字母x占据了mean line和baseline直接的这段空间，也就是所谓的字面所在。&lt;/p&gt;
&lt;p&gt; x这个字母恰好是镜面对称的，所以我们可以清楚的看到，vertical-align:middle就是将元素的中点对准x字母的中线，所以就形成了垂直居中的效果。&lt;/p&gt;
&lt;p&gt; 好，现在我们来看实际的情况，我们有一个高度固定的div，然后内部有两个inline-block级的div，需要水平居中，这两个div的高度随机。&lt;/p&gt;
&lt;p&gt; 代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;height:300px;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block&amp;quot;&amp;gt;我是一号div，啊啊啊啊啊啊啊啊啊啊&amp;lt;br&amp;gt;啊啊啊啊啊啊啊啊&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block&amp;quot;&amp;gt;我是二号div&amp;lt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;height:100px;background-color:blue&quot;&gt;&lt;div style=&quot;display:inline-block;background-color:red&quot;&gt;我是一号div，啊啊啊啊啊啊啊啊啊啊&lt;br&gt;啊啊啊啊啊啊啊啊&lt;/div&gt;&lt;div style=&quot;display:inline-block;background-color:white&quot;&gt;我是二号div&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是默认情况，两个div的vertical-align被设置为baseline,可以看出两个div的baseline在一条线上。第一个div的baseline是最后一个line box的baseline。&lt;/p&gt;
&lt;p&gt;那么父级元素div，一个块级元素，是否存在baseline呢？答案是否定的，在inline-block元素处于块极元素内部的情况下，vertical-align更多与同级inline-block元素的相互对齐有关，而和父级元素无关。&lt;/p&gt;
&lt;p&gt;可以实验一下，我们把父级div设为inline-block，看看会发生什么事情。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;display:inline-block;line-height:100px;background-
color:blue&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block;background-color:red&amp;quot;&amp;gt;
    我是一号div，啊啊啊啊啊啊啊啊啊啊&amp;lt;br&amp;gt;啊啊啊啊啊啊啊啊
    &amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block;background-color:white&amp;quot;&amp;gt;
    我是二号div
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;display:inline-block;line-height:100px;background-color:blue;font-size:150px&quot;&gt;&lt;div style=&quot;display:inline-block;background-color:red;font-size:15px&quot;&gt;我是一号div，啊啊啊啊啊啊啊啊啊啊&lt;br&gt;啊啊啊啊啊啊啊啊&lt;/div&gt;&lt;div style=&quot;display:inline-block;background-color:white;font-size:15px&quot;&gt;我是二号div&lt;/div&gt;X&lt;/div&gt;

&lt;p&gt;这里我将父级div设为inline-block并且把line-height设为100px，因此其子元素的基线就和父元素的基线对齐了。我特意放了一个特大号的字，X的底部便是baseline了。&lt;/p&gt;
&lt;p&gt;了解到这一点之后，我们便清楚了，父元素是块级元素的情况下，vertical-align只和同级元素有关。vertical-align:middle便是同级元素的中线相互对齐。&lt;/p&gt;
&lt;p&gt;我们只需要一个空的div，它只起占位的作用，高度是100%，宽度是0，于是，其他高度小于父元素的子元素便会与这个占位元素的中线对齐，也就达到了垂直对齐。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;height:100px;background-color:blue;font-size:0&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;height:100%;width:0;display:inline-block;vertical-
    align:middle&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block;background-color:red;font-size:
    15px;vertical-align:middle&amp;quot;&amp;gt;我是一号div，啊啊啊啊啊啊啊啊啊啊&amp;lt;br&amp;gt;啊啊
    啊啊啊啊啊啊&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:inline-block;background-color:white;font-
    size:15px;vertical-align:middle&amp;quot;&amp;gt;我是二号div&amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;div style=&quot;height:100px;background-color:blue;font-size:0&quot;&gt;&lt;div style=&quot;height:100%;width:0;display:inline-block;vertical-align:middle&quot;&gt;&lt;/div&gt;&lt;div style=&quot;display:inline-block;background-color:red;font-size:15px;vertical-align:middle&quot;&gt;我是一号div，啊啊啊啊啊啊啊啊啊啊&lt;br&gt;啊啊啊啊啊啊啊啊&lt;/div&gt;&lt;div style=&quot;display:inline-block;background-color:white;font-size:15px;vertical-align:middle&quot;&gt;我是二号div&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;垂直居中的效果就达成了！&lt;/p&gt;
&lt;p&gt;ok，用:before伪元素来实现也是一个很不错的做法，相比空div要更简洁一些。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如何快速并且健壮地实现高度不一定的实体的居中呢？  &lt;/p&gt;
&lt;p&gt;vertical-align显然是一种办法。这个元素从语义上来看就是用来实现垂直对齐的。要理解vertical-align，首先我们得了解几个概念，inline boxes, line box, 以及baseline。  &lt;/p&gt;
&lt;p&gt;inline boxes是行内元素构成的行内box，而line box则是由一行内所有的inline boxes构成的box，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;我是inline box&amp;lt;/span&amp;gt;
    我是匿名inline box
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了display为inline或者inline-block的标签会形成inline box，行内文本也会形成匿名的inline box。&lt;/p&gt;
&lt;p&gt;一行所有的inline boxes构成匿名的line box，其中inline box中高度最高的那个的高度便是line box的高度，由此撑起了整行的高度。（这涉及到line-height方面的知识）&lt;/p&gt;
&lt;p&gt;而关于baseline，则是文字在排版时顶部与底部中间的基线，如果是行内文本，具体位置随字体不同而不同，一般都在中线以下的位置。具体的需要参考西文字体学（Typography）(Jobs在大学旁听的课程之一，你值得拥有)  &lt;/p&gt;
&lt;p&gt;而line—height其实就是两条基线之间的距离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/blog_7_24_1.png&quot; alt=&quot;baseline&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Web Animation Using Javascript part one</title>
    <link href="http://yoursite.com/2015/05/23/Web-Animation-Using-Javascript-part-one/"/>
    <id>http://yoursite.com/2015/05/23/Web-Animation-Using-Javascript-part-one/</id>
    <published>2015-05-23T14:47:00.000Z</published>
    <updated>2015-06-12T11:52:53.000Z</updated>
    
    <content type="html">&lt;p&gt;##第二章：Velocity.js动画##&lt;br&gt;在这一章，你将学到由Velocity.js提供的特性，指令，和选项。如果你熟悉基于jQuery的动画，那么你已经知道如何使用Velocity.js了；它的功能几乎和jQuery的$.animate()函数一模一样。&lt;/p&gt;
&lt;p&gt;不过抛开你现有的知识，本章中对特性的井井有条的分类将会向你介绍动画引擎行为的细微差别。掌握这些细微差别将会帮助你从新手成为专业人士。即使你已经对jQuery动画和Velocity.js相当熟悉了，也给自己一个机会，快速浏览本章。&lt;strong&gt;你必定会发现一些你没意识到的可行之事。&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###JavaScript动画库类型###&lt;/p&gt;
&lt;p&gt;JavaScript动画库有很多类型。有些在浏览器中重现物理接触效果。有些使WebGL和Canvas动画更容易维护。有些专注于SVG动画。有些改善了UI动画————最后这种类型正是本书的重点。&lt;/p&gt;
&lt;p&gt;两种广受欢迎的UI动画库是GSAP和Velocity。你将在本书中使用Velocity，因为它在MIT许可下是免费的，外加它拥有极其强大的功能以供编写整洁且富有表现力的动画代码。Velocity被很多知名站点使用，包括Tumblr，Gap，还有Scribd。&lt;/p&gt;
&lt;p&gt;噢，而且它是由本书的作者创造的！&lt;/p&gt;
&lt;p&gt;###安装jQuery和Velocity###&lt;/p&gt;
&lt;p&gt;你可以从jQuery.com下载jQuery，从VelosityJS.org下载Velosity。在你的页面上使用它们——和任何JavaScript库一样——简单地把指向相应库文件的&lt;code&gt;&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt;&lt;/code&gt;标签放在你页面的&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;标签之前。如果你想链接预部署版本的库文件（而不是你电脑上的本地拷贝），你的代码看起来可能是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
      &amp;lt;head&amp;gt;My Page&amp;lt;/head&amp;gt;
   &amp;lt;body&amp;gt;
         My content.
         &amp;lt;script src=”//code.jquery.com/jquery-2.1.1.min.js”&amp;gt;
       &amp;lt;/script&amp;gt;
       &amp;lt;script src=”//cdn.jsdelivr.net/velocity/1.1.0/
       velocity.min.js”&amp;gt;
       &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当一起使用jQuery和Velocity时，在Velocity前引入jQuery。&lt;br&gt;这就对了！现在你已经准备好了。&lt;/p&gt;
&lt;p&gt;##使用Velocity:基础##&lt;/p&gt;
&lt;p&gt;为了熟悉Velocity，我们将从基本的组件开始：参数，属性，值，和链式调用。因为jQuery几乎无所不在，看看Velocity和jQuery的关系也是有必要的。&lt;/p&gt;
&lt;p&gt;###Velocity和jQuery###&lt;/p&gt;
&lt;p&gt;Velocity可以独立于jQuery运行，但是二者可以一起使用。一般我们推荐这么做来获得jQuery的链式调用能力：当你已经使用jQuery预选择了一个元素，你可以调用.velocity()来拓展它从而施加动画效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 把jQuery元素对象赋值给一个变量
var $div = $(“div”);
// 使用Velocity对元素施加动画
$div.velocity({ opacity: 0 });
这种语法和jQuery自带的animate函数一模一样：
$div.animate({ opacity: 0 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本书所有的例子都使用Velocity和jQuery的结合，因此可以使用这种语法。&lt;/p&gt;
&lt;p&gt;###参数###&lt;/p&gt;
&lt;p&gt;Velocity接收多个参数。第一个参数是一个映射CSS属性到其最终值的对象。属性及其接收值的类型直接与CSS中使用的相对应（如果你不熟悉基础的CSS属性，在读这段代码之前读一本HTML和CSS的介绍性书籍）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 对元素施加动画使width变为“500px”，opacity变为1。
 $element.velocity({ width: “500px”, opacity: 1 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; –&lt;br&gt; &lt;em&gt;Tip&lt;/em&gt;  &lt;/p&gt;
&lt;h2 id=&quot;在JavaScript中，如果你将要提供一个包含字母（而不是只有整数）的属性值，把属性值放在引号中。&quot;&gt;&lt;a href=&quot;#在JavaScript中，如果你将要提供一个包含字母（而不是只有整数）的属性值，把属性值放在引号中。&quot; class=&quot;headerlink&quot; title=&quot; 在JavaScript中，如果你将要提供一个包含字母（而不是只有整数）的属性值，把属性值放在引号中。&quot;&gt;&lt;/a&gt; 在JavaScript中，如果你将要提供一个包含字母（而不是只有整数）的属性值，把属性值放在引号中。&lt;/h2&gt;&lt;p&gt;你可以传递一个指定了动画选项的对象作为第二个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “500px”, opacity: 1 }, { duration: 400, 
easing: “swing” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里也有一个简写的参数语法：你可以使用逗号分隔语法，而不是传递一个包含选项的对象作为第二个参数。这要求以任何逗号分隔的顺序列出动画时长的值（接收一个整数），缓动模式（一个字符串），以及回调函数（一个函数）。（你一会将会学到这些选项的作用。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //时长1000ms的动画 (使用默认缓动模式swing)
  $element.velocity({ top: 50 }, 1000);
  //时长1000ms的动画，并且使用缓动模式“ease-in-out”
  $element.velocity({ top: 50 }, 1000, “ease-in-out”);
 //使用缓动模式“ease-out”，使用默认时长值400ms)
 $element.velocity({ top: 50 }, “ease-out”);
 //时长1000ms的动画,并且在动画完成时触发一个回调函数        
 $element.velocity({ top: 50 }, 1000, function() 
 { alert(“Complete.”) });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你只需要指定基本选项(时长，缓动模式，回调函数)的时候，这个简写语法是一种传递动画选项的快捷方法。如果你在这三个选项之外传递一个动画选项，你必须把所有选项调回对象语法。&lt;br&gt;因此，如果你想要指定一个延时选项，改变以下的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ top: 50 }, 1000, “ease-in-out”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这种语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//重新指定上面使用的动画选项，但包括一个值为500ms的延时选项  
$element.velocity({ top: 50 }, { duration: 1000, easing: “ease-in-
out”, delay: 500 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你不能这么做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//错误：把动画选项分为逗号分隔语法和对象语法来写
$element.velocity({ top: 50 }, 1000, { easing: “ease-in-out”, 
delay: 500 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###属性###&lt;/p&gt;
&lt;p&gt;基于CSS的属性动画和基于JavaScript的属性动画有两处区别。&lt;/p&gt;
&lt;p&gt;首先，不像在CSS中那样，Velocity中每个CSS属性只接收单个数值。所以，你可以传入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ padding: 10 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ paddingLeft: 10, paddingRight: 10 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是你不能传入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 错误：CSS属性被传入了多个数值
$element.velocity({ padding: “10 10 10 10” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你想要把四个padding值(top, right, bottom, 和 left)加入动画，将它们列为分离的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 正确
$element.velocity({
  paddingTop: 10,
  paddingRight: 10,
  paddingBottom: 10,
  paddingLeft: 10
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他可以接收多个数值的常见CSS属性包括&lt;code&gt;magrin&lt;/code&gt;，&lt;code&gt;transform&lt;/code&gt;， &lt;code&gt;text-shadow&lt;/code&gt;，和&lt;code&gt;box-shadow&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了形成动画而将组合属性分离到它们的子属性中给了你对缓动值的进一步控制。举个例子，在CSS中，当对父padding属性下的多个子属性施加动画时，你只可以指定一种属性范围的缓动类型。在JavaScript中，你可以为每个子属性指定独立的缓动值——这个特性的优势会在之后这章关于CSS transform属性的讨论中变得明确。&lt;/p&gt;
&lt;p&gt;列出我们的独立子属性也可以使你的动画代码更易阅读和维护。&lt;/p&gt;
&lt;p&gt;基于CSS的属性动画和基于JavaScript的属性动画的第二处不同是JavaScript属性没有词与词之间的横杠，第一个词之后的所有词必须大写。例如，padding-left变成了paddingLeft，而background-color变成了backgroundColor。还有一点，JavaScript属性名不应该被置于引号中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 正确
$element.velocity({ paddingLeft: 10 });
// 错误: 使用了横杠且没有大写
$element.velocity({ padding-left: 10 });
// 错误：在JavaScript格式的属性名两边使用了引号
$element.velocity({ “paddingLeft”: 10 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###值###&lt;/p&gt;
&lt;p&gt;Velocity支持&lt;code&gt;px&lt;/code&gt;,&lt;code&gt;em&lt;/code&gt;,&lt;code&gt;rem&lt;/code&gt;,&lt;code&gt;%&lt;/code&gt;,&lt;code&gt;deg&lt;/code&gt;,&lt;code&gt;vw&lt;/code&gt;和&lt;code&gt;vh&lt;/code&gt;单位。如果你没有为数值提供某个类型的单位，一个基于CSS属性类型的合适的单位会被自动添加。对于大多数属性，px是默认单位，不过一个接收旋转角度的属性，比如rotateZ,会被自动添加deg单位：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({
  top: 50, // 默认设置为px单位类型
  left: “50%”, // 我们手动指定了%单位类型      
  rotateZ: 25 // 默认设置为deg单位类型
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为你所有的属性值显式声明单位类型，通过使px单位和它的替代选择之间的对比更加明显来增加代码在快速浏览时的清晰程度。&lt;/p&gt;
&lt;p&gt;另一个Velocity相对于CSS的优势是它支持可以被选择性添加在属性值之前的四种数值运算符：+，—，*，和/。它们和JavaScript中的数学运算符一一对应。你可以把这些数值运算符与一个等号组合来进行相应的数学运算。请参考实例中的行内代码注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({
  top: “50px”, // 没有运算符。不出所料地向前运动50px。
  left: “-50”, // 负运算符。不出所料地向前运动-50px。
  width: “+=5rem”, // 将当前宽度值转换为对应的rem值并加上5个单位值。
  height: “-10rem”, // 将当前高度值转换为对应的rem值并减去10个单位值。
  paddingLeft: “*=2” // 把当前的paddingLeft值加倍。
  paddingRight: “/=2” // 把当前的paddingLeft值除以2。
 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Velocity的简写特性，像数值运算符，把动画逻辑完全保留在动画引擎中。这不仅仅因排除了手动数值计算而使代码更加简洁，也通过告诉Velocity更多你计划如何对元素施加动画来提升了性能。Velocity处理的逻辑越多，它优化你的代码来达到更高的帧数的能力就越强。&lt;/p&gt;
&lt;p&gt;###链式调用###&lt;/p&gt;
&lt;p&gt;当多个Velocity调用被连续链接在一个元素（或一系列元素）上的时候，它们会自动形成队列。这说明每个动画在前一个动画完成时开始：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
  // 对width和height属性施加动画
  .velocity({ width: “100px”, height: “100px” })
  // 当宽度和高度的动画完成之后，对top属性施加动画
  .velocity({ top: “50px” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##使用Velocity:选项##&lt;/p&gt;
&lt;p&gt;为了完善对Velocity的介绍，让我们快速浏览最常用的选项:时长，缓动，起始回调及结束回调，循环，延时，和显示。&lt;/p&gt;
&lt;p&gt;###时长###&lt;/p&gt;
&lt;p&gt;你可以指定时长选项，它决定了一个动画调用要多长时间结束，以毫秒（1/1000秒）为单位或是三种简写时长之一：“慢”（相当于600ms），“普通”（400ms），或者“快”（200ms）。当以毫秒指定一个时长值时，应提供一个不带任何单位类型的整数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 施加时长1000ms（1秒）的动画
$element.velocity({ opacity: 1 }, { duration: 1000 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ opacity: 1}, { duration: “slow” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你回顾你的代码时，使用命了名的简写时长的好处是它们表达了一个动画的节奏（是慢还是快？）。如果你全部使用这些简写，它们自然也将带给你的站点更统一的动画设计，因为所有的动画将会落在三个速度分类中而不是被传递一个随意的值。&lt;/p&gt;
&lt;p&gt;###缓动###&lt;/p&gt;
&lt;p&gt;缓动是定义一个动画的整个过程中不同部分发生快慢的数学函数。举个例子,“ease-in-out”缓动类型表明动画应该在第一部分缓缓加速（淡入）然后在最后部分缓缓减速（淡出）。相比之下，“ease-in”缓动类型产生的动画在第一部分加速到一个目标速度但随后保持一个恒定速度直到动画完成。“ease-out”缓动类型是“ease-in”的相反情况，动画开始并且保持一个恒定速度直到在动画的最后部分缓缓减速。&lt;/p&gt;
&lt;p&gt;与第一章，“JavaScript动画的优势”中讨论的基于物理的运动很相似，缓动给你力量来向你的动画注入人格。拿一个使用线性缓动的动画会让人感到多么的机械来说。（线性缓动产生一种以相同速率开始，运行，和结束的动画。）这种机械的感受是与现实世界的线性机械运动相联系的结果：自我导航的机械物体往往以直线移动并且以恒定速度操作，因为没有任何美学的抑或生理的原因去让它们不那么做。&lt;/p&gt;
&lt;p&gt;与此相对，有生命的东西-不管是人体或是正被风吹的树-在真实世界中从不以一个恒定的速度移动。摩擦力和其他外部力量令它们以不同的速度移动。&lt;/p&gt;
&lt;p&gt;伟大的动画设计师对有机的运动怀有敬意，因为这让人感觉界面正流畅地回应用户的互动。在移动应用中，举个例子，你希望一个菜单在你将它滑出屏幕时马上加速离开你的手指。如果菜单只是以一个恒定速度从你的手指移开-像一个机械手臂-你将会感到滑动只是触发了一连串不受你控制的运动事件。&lt;/p&gt;
&lt;p&gt;关于缓动类型的力量，你将会在第三章：“动画设计理论”中学到更多。对于现在，让我们快速浏览Velocity的所有可用的缓动类型：&lt;/p&gt;
&lt;p&gt;+jQuery UI的三角函数缓动。关于这些缓动方程的完整列表，以及它们的加速效果简介的互动演示，请查阅easing.net上的demo。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “100px” }, “easeInOutSine”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;+CSS缓动：”ease-in”, “ease-out”, “ease-in-out”, 和 “ease” (一个与”ease-in-out”有细微不同的版本)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “100px” }, “ease-in-out”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;+CSS贝塞尔曲线：贝塞尔曲线缓动允许对一个缓动加速曲线结构的完全控制。一条贝塞尔曲线通过指定一张图表上四个等距点的高度来定义，Velocity接收的图表格式是有四项二进制值的数组。访问cubic-bezier.com来查看一个创建贝塞尔曲线的互动指南。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “100px” }, [ 0.17, 0.67, 0.83, 
0.67 ]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;+弹簧模型：这种缓动类型模仿一个被拉伸然后突然释放的弹簧的弹性形变。正如定义弹簧运动的经典物理方程，这种缓动类型允许你传递一个形式为[张力，摩擦力]的二项数组。一个更高的张力值（默认为500）增加了总速度及弹性。一个更低的摩擦力（默认为20）增加了振动结束时的速度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “100px” }, [ 250, 15 ]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;+“spring”缓动是一种预定义的弹簧模型的实现，它在你不想试验张力和摩擦力值的时候使用方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: “100px” }, “spring”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;记住你也可以传递缓动选项作为一个选项对象参数中的一个直接定义的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ width: 50 }, { easing: “spring” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不要被你可用的缓动选项的数量吓倒。你将经常依靠CSS缓动类型和“spring”缓动，它们适合绝大部分动画使用实例。最复杂的缓动类型，贝塞尔曲线，被脑中有一个高度具体的缓动方式且不怕麻烦的开发者使用最多。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本节其余的Velocity选项必须被直接传递入一个选项对象。不像那些已经被描述的，这些附加选项不能以简写的逗号分隔语法在Velocity中使用。&lt;/p&gt;
&lt;p&gt;###起始回调和结束回调###&lt;/p&gt;
&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;complete&lt;/code&gt;选项允许你指定在动画中的特定节点被触发的函数：给&lt;code&gt;begin&lt;/code&gt;选项传递一个在动画开始前被调用的函数。相反地，传给&lt;code&gt;complete&lt;/code&gt;选项一个在动画完成时被调用的函数。&lt;/p&gt;
&lt;p&gt;在这两种选项中，函数在每次动画调用时只被调用一次，就算多个元素同时被施加动画：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var $divs = $(“div”);
$divs.velocity(
   { opacity: 0 },
   // 在动画开始前打开一个警告窗口
   {
   begin: function () { console.log(“Begin!”); },
    // 一旦动画完成就打开一个警告窗口
   complete: function () { console.log(“Complete!”); }
} );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;回调函数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这些选项常被叫做“回调函数”（或“回调”）因为它们将在特定的事件发生时被“调用”。回调函数对触发依赖于元素可见度的事件十分有用。举个例子，如果一个元素在开始时不可见，然后发生动画使透明度变为1，那么随后触发一个UI事件，一旦用户能看见新内容时便更改内容，可能是合适的。&lt;/p&gt;
&lt;p&gt;记住你不需要使用回调函数来依次排列动画；当多个动画被指派在单个元素或一组元素上时，动画会自动按顺序触发。回调函数用来使非动画逻辑形成队列。&lt;/p&gt;
&lt;p&gt;###循环###&lt;/p&gt;
&lt;p&gt;把循环选项设成一个整数，指定了一个动画在被调用时的属性映射表中的值与调用前元素的这些值之间应交替的次数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ height: “10em” }, { loop: 2 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果元素的初始高度是5em，它的高度会在5em和10em之间交替两次。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;complete&lt;/code&gt;选项在一个循环的调用中被使用，它们会被各触发一次-分别在最开始和整个循环队列的终点；它们不会在每次循环交替中被重复触发。&lt;/p&gt;
&lt;p&gt;你也可以传递&lt;code&gt;true&lt;/code&gt;来触发无限循环，而不是传递一个整数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ height: “10em” }, { loop: true });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无限循环忽略了&lt;code&gt;complete&lt;/code&gt;回调，因为它们不会自然结束。然而，它们可以通过Velocity的&lt;code&gt;stop&lt;/code&gt;命令被手动结束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity(“stop”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;非无限循环对动画队列是有用的，不然它们将需要重复链式动画的代码。举个例子，如果你想要让一个元素弹上弹下两次（也许是警告用户有一条新消息在等待他们），没有优化的代码看起来大概是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
  // 假定translateY开始时为“0px”
  .velocity({ translateY: “100px” })
  .velocity({ translateY: “0px” })
  .velocity({ translateY: “100px” })
  .velocity({ translateY: “0px” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更紧凑且易维护的代码版本看起来大概是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 重复（循环）这段动画两次
$element.velocity({ translateY: “100px” }, { loop: 2 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这个优化的版本，如果你已经在心里想好了最大值应该被改变多少（当前是100px），你只需要在一部分代码中更改最大值。如果在你的代码中有很多这种重复的例子，那么循环对你的工作流多么有益，是显而易见的。&lt;/p&gt;
&lt;p&gt;无限循环对加载指示器有巨大的帮助，加载指示器一般无限循环动画直到数据被加载完成。&lt;/p&gt;
&lt;p&gt;首先，通过使加载指示器元素的透明度在可见和不可见之间无限循环，令其表现为有节奏的闪动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 假定透明度开始时是1（完全可见）
$element.velocity({ opacity: 0 }, { loop: true });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，一旦数据结束加载，你可以停止动画，然后隐藏这个元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
  // 首先停止无限循环
  .velocity(“stop”)
  // ... 所以你可以对元素施加一个新动画，
  // 你可以施加它来使元素变回不可见。
  .velocity({ opacity: 0 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###延时&lt;/p&gt;
&lt;p&gt;以毫秒指定延时选项,来在动画开始之前插入一个暂停。延时选项的目标是把动画的计时逻辑完整保留在Velocity中-与在一个Velocity动画开始时依赖使用jQuery的$.delay()函数来改变相反：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在进行动画使透明度变为0之前等待100ms
$element.velocity({ opacity: 0 }, { delay: 100 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以把loop选项和delay选项一起设定来创建一个循环交替间的暂停：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 循环四次，在每次循环前等待100ms
$element.velocity({ height: “+=50px” }, { loop: 4, delay: 
100 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###显示与可见度&lt;/p&gt;
&lt;p&gt;Velocity的显示与可见度选项与它们的CSS同仁直接对应，并且接收同样的值，包括：“none”，“inline”，“inline-block”，“block”，“flex”，等等。另外，Velocity允许“auto”值，这指定&lt;code&gt;display&lt;/code&gt;属性为元素的默认值。（作为参考，a和span标签默认为“inline”，而div和大部分其他元素默认为“block“）。Velocity的可见度选项，像它的CSS同仁一样，接收”hidden“，”visible“，和”collapse“值。&lt;/p&gt;
&lt;p&gt;在Velocity中，当&lt;code&gt;display&lt;/code&gt;选项被设为”none“(或可见度被设为”hidden“)，一旦动画完成，元素的CSS属性即被相应地设置。这有效地使元素在动画完成时被隐藏，并且在与将元素的透明度变为0的动画联合使用时很有用（这里的意图是将一个元素淡出至页面外）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 使一个元素的透明度渐变为0，然后把它移出页面文档流
$element.velocity({ opacity: 0 }, { display: “none” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面的代码有效地替换了jQuery中的等效代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
        .animate({ opacity:0 })
        .hide();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;快速回顾：可见度与显示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以供参考，CSS&lt;code&gt;display&lt;/code&gt;属性指定了一个元素如何影响它周围的元素以及被它包含的元素的定位。对比之下，CSS&lt;code&gt;visibility&lt;/code&gt;属性仅仅影响一个元素是否能被看见。如果一个元素被设为”visibility:hidden”,它将继续在页面中占据空间，但是这个空间将简单地表现为一个空间隔-这个元素的每一部分都是不可见的。作为替代，如果一个元素被设为“display:none”，这个元素将完全从页面文档流中被移除，并且所有在其中或环绕它的元素将填补被移除元素的空间，好像这个元素从未存在过。&lt;/p&gt;
&lt;p&gt;注意，你可以设置元素的visibility为”hidden“来简单地把元素同时标记为不可见和无法交互，而不是把这个元素移出页面文档流。当你想隐藏一个继续在页面上占位的元素时这很有用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将一个元素淡入到opacity:0，然后让它变得无法交互
$element.velocity({ opacity: 0 }, { visibility: “hidden” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，让我们考虑相反方向的动画（显示元素而不是隐藏元素）：当&lt;code&gt;diaplay&lt;/code&gt;或&lt;code&gt;visibility&lt;/code&gt;被设为”none“或”hidden“之外的值，这个值会在动画开始前被设置，因此元素在即将到来的动画过程中是可见的。换句话说，你正在取消之前元素被移出视图时发生的隐藏过程。&lt;/p&gt;
&lt;p&gt;以下，&lt;code&gt;display&lt;/code&gt;在元素开始淡入之前被设为”block“：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({ opacity: 1 }, { display: “block” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这有效地替换了等效的jQuery代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
  .show()
  .animate({ opacity: 0 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;提示&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查看Velocity动画选项的完整概述，请查阅Velocity.org的文档。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;包含动画逻辑&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;加上Velocity的&lt;code&gt;delay&lt;/code&gt;选项，Velocity对CSS&lt;code&gt;display&lt;/code&gt;和&lt;code&gt;visibility&lt;/code&gt;设定的包含允许动画逻辑被完全保留在Velocity中。在生产环境代码中，每当一个元素被淡入或淡出视图时，几乎总伴随着&lt;code&gt;display&lt;/code&gt;和&lt;code&gt;visibility&lt;/code&gt;上的改变。借助像这样的Velocity简写帮助你保持你的代码干净且易于维护，因为这样对外部jQuery函数的依赖更少，并且避免了重复使用通常会使动画逻辑臃肿的辅助函数。&lt;/p&gt;
&lt;p&gt;注意Velocity包括了以上演示的切换透明度动画的简写方式。它们的功能和jQuery的&lt;code&gt;fadeIn&lt;/code&gt;及&lt;code&gt;fadeOut&lt;/code&gt;函数一模一样。你仅需传递相应地传递命令给Velocity作为第一个参数，并且，如果想要的话，你可以传入一个选项对象，像往常一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity(“fadeIn”, { duration: 1000 });
$element.velocity(“fadeOut”, { duration: 1000 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##使用Velocity：附加特性&lt;/p&gt;
&lt;p&gt;附加的Velocity.js特性中值得注意的包括：回退命令，滚动，颜色，和变形（平移，旋转，和缩放）。&lt;/p&gt;
&lt;p&gt;###回退命令&lt;/p&gt;
&lt;p&gt;传递“reverse”作为Velocity的第一个参数，来使元素发生动画返回至上一个Velocity调用前的值。&lt;code&gt;reverse&lt;/code&gt;命令和一个标准的Velocity命令表现一样；它可以带有参数并且会和其他链式Velocity调用一起被加入队列。&lt;/p&gt;
&lt;p&gt;回退默认设置了元素的上一个Velocity的调用中使用的选项（时长，缓动，等等）。然而，你可以传递一个新选项对象来覆写这些选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 使用上一个Velocity调用的选项来施加动画返回初始值
$element.velocity(“reverse”);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 做和上面一样的事，不过把上一个Velocity调用的时长值替换为2000ms
$element.velocity(“reverse”, { duration: 2000 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前一个调用的&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;complete&lt;/code&gt;选项被&lt;code&gt;reverse&lt;/code&gt;命令忽视了；&lt;code&gt;reverse&lt;/code&gt;从不重复调用回调函数。&lt;/p&gt;
&lt;p&gt;###滚动&lt;/p&gt;
&lt;p&gt;传递“scroll”作为Velocity的第一个参数来滚动浏览器至一个元素的顶部。&lt;code&gt;scroll&lt;/code&gt;命令和一个标准的Velocity调用表现一模一样；它可以带有参数并且会和其他链式Velocity调用一起被加入队列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element
  .velocity(“scroll”, { duration: 1000, easing: “spring” })
  .velocity({ opacity: 1 });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这使用1000ms的时长和“spring”缓动将浏览器滚动到元素的顶部。然后，一旦元素被滚动进入视窗，它会完全淡入。&lt;/p&gt;
&lt;p&gt;为了向一个父元素有滚动条的元素滚动，你可以使用&lt;code&gt;container&lt;/code&gt;选项，它接收一个jQuery对象或者一个原始的元素。注意CSS&lt;code&gt;position&lt;/code&gt;属性必须被设为&lt;code&gt;relative&lt;/code&gt;,&lt;code&gt;absolute&lt;/code&gt;,或者&lt;code&gt;fixed&lt;/code&gt;中的一个-&lt;code&gt;static&lt;/code&gt;不会起作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 滚动元素进入$(“#container”)元素的视图中
$element.velocity(“scroll”, { container: $(“#container”) });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在两种情况中-不管滚动是相对于浏览器窗口还是相对于一个父元素-滚动命令总是被调用在&lt;em&gt;正被滚动进入视窗&lt;/em&gt;的元素上。&lt;/p&gt;
&lt;p&gt;默认情况下，滚动发生在y轴。传入&lt;code&gt;axis：x&lt;/code&gt;选项来水平滚动来取代垂直滚动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 滚动浏览器到目标div的左边缘
$element.velocity(“scroll”, { axis: “x” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，滚动命令还独特地接收一个以px设定的&lt;code&gt;offset&lt;/code&gt;选项，它偏移了目标滚动位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 滚动到距离元素上边缘上方50px的位置
$element.velocity(“scroll”, { duration: 1000, offset: “-50px” });
// 滚动到距离元素上边缘下方250px的位置
$element.velocity(“scroll”, { duration: 1000, offset: “250px” });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###颜色&lt;/p&gt;
&lt;p&gt;Velocity支持这些CSS属性：&lt;code&gt;color&lt;/code&gt;,&lt;code&gt;backgroundColor&lt;/code&gt;, &lt;code&gt;borderColor&lt;/code&gt;,和&lt;code&gt;outlineColor&lt;/code&gt;的颜色动画。在Velocity中，颜色属性只接收16进制，举个例子，#000000（黑色）或#e2e2e2（浅灰）。为了达到颗粒度更小的颜色控制，你可以对颜色属性的单个红，绿，和蓝分量进行动画，也包括alpha通道分量。红，绿和蓝的数值范围在0到255之间，alpha通道（等同于透明度）的范围在0到1之间。&lt;/p&gt;
&lt;p&gt;参考以下例子中的行内注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({
  // 施加动画使背景颜色变到以十六进制表示的黑色
  backgroundColor: “#000000”,
  // 同步地施加动画使背景的alpha分量（透明度）变到50%
  backgroundColorAlpha: 0.5,
  // 也对元素的文本颜色的red分量施加动画使其变为总量的一半
  colorRed: 125
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###变形&lt;/p&gt;
&lt;p&gt;CSS变形属性对在2D和3D空间的元素施加平移，缩放，和旋转操作。它包括很多子组件，其中Velocity支持以下几种：&lt;/p&gt;
&lt;p&gt;+&lt;code&gt;translateX&lt;/code&gt;:沿x轴移动一个元素&lt;br&gt;+&lt;code&gt;translateY&lt;/code&gt;:沿y轴移动一个元素&lt;br&gt;+&lt;code&gt;rotateZ&lt;/code&gt;:沿z轴旋转一个元素（在2D表面上实际为顺时针或逆时针）&lt;br&gt;+&lt;code&gt;rotateX&lt;/code&gt;:沿x轴旋转一个元素（在3D空间里实际为移向用户或远离用户）&lt;br&gt;+&lt;code&gt;rotateY&lt;/code&gt;:沿y轴旋转一个元素（在3D空间里实际为向左移动或向右移动）&lt;br&gt;+&lt;code&gt;scaleX&lt;/code&gt;:增加一个元素的宽度值&lt;br&gt;+&lt;code&gt;scaleY&lt;/code&gt;:增加一个元素的高度值&lt;/p&gt;
&lt;p&gt;在Velocity中，你可以在一个属性对象中以单独属性来施加这些组件带来的动画效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$element.velocity({
  translateZ: “200px”,
  rotateZ: “45deg”
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##使用Velocity：不使用jQuery（中级）&lt;/p&gt;
&lt;p&gt;如果你是一个宁愿不借助jQuery的帮助来使用JavaScript工作的中级开发者，你将会高兴地得知Velocity也可以在jQuery不出现在页面上的时候工作。相应地，目标元素被直接传递入动画调用作为第一个参数，而不是把一个动画调用链接到一个jQuery元素对象上-就像本章之前的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Velocity(element, { opacity: 0.5 }, 1000); // Velocity
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就算Velocity脱离jQuery被使用，它也保持和jQuery的$.animate()一样的语法；区别在于所有的参数都被向右移动来腾出位置以便在首位传入目标元素。另外，全局Velocity对象而不是具体的jQuery元素对象被用于调用动画。&lt;/p&gt;
&lt;p&gt;当你脱离jQuery使用Velocity时，你不再对jQuery对象施加动画，而是原生文档对象模型（DOM）元素。原生DOM元素可以通过以下函数获取：&lt;/p&gt;
&lt;p&gt;+&lt;code&gt;document.getElementByID()&lt;/code&gt;：用ID属性获取一个元素&lt;br&gt;+&lt;code&gt;document.getElementsByTagName()&lt;/code&gt;获取带有特定标签名的所有元素&lt;br&gt;+&lt;code&gt;document.getElementsByClassName()&lt;/code&gt;获取带有特定CSS类的所有元素&lt;br&gt;+&lt;code&gt;document.querySelectorAll()&lt;/code&gt;这个函数和jQuery的选择引擎的作用一模一样&lt;/p&gt;
&lt;p&gt;让我们进一步探索&lt;code&gt;document.querySelectorAll()&lt;/code&gt;，因为它可能将成为你在不借助jQuery帮助时选择元素的利器。（这是一个性能强大的且被众浏览器广泛支持的函数。）使用jQuery的元素选择器语法，你可以简单地传递给&lt;code&gt;querySelectorAll&lt;/code&gt;一个CSS选择器（和你在样式表中用来选择目标元素的选择器一样），并且它将以一个数组的形式返回所有符合的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.querySelectorAll(“body”); // 获取body元素
document.querySelectorAll(“.squares”); // 获取所有带“square”类的元素     
document.querySelectorAll(“div”); // 获取所有div
document.querySelectorAll(“#main”); //  获取所有id为“main”的元素 
document.querySelectorAll(“#main div”); // 获取所有id为“main”的元素中的
div
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你把这些查找之一的结果赋值给一个变量，随后你可以重复使用这个变量来对目标元素施加动画：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取所有元素
var divs = document.querySelectorAll(“div”);
// 对所有div施加动画
Velocity(divs, { opacity: 0 }, 1000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为你不再拓展jQuery元素对象，你可能在想如何把元素一个个链接起来，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 它们彼此链接
$element
   .velocity({ opacity: 0.5 }, 1000)
   .velocity({ opacity: 1 }, 1000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了不借助jQuery来再现这个模式，简单地把一个函数接着另一个函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对同样地元素施加的动画彼此自动链接起来
Velocity(element, { opacity: 0 }, 1000);
Velocity(element, { opacity: 1 }, 1000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###结语&lt;/p&gt;
&lt;p&gt;现在你已经有了对使用JavaScript进行web动画的好处的认识，加上对Velocity基础的一些掌握，你已经准备好去探索专业动画设计之下的迷人理论基础。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##第二章：Velocity.js动画##&lt;br&gt;在这一章，你将学到由Velocity.js提供的特性，指令，和选项。如果你熟悉基于jQuery的动画，那么你已经知道如何使用Velocity.js了；它的功能几乎和jQuery的$.animate()函数一模一样。&lt;/p&gt;
&lt;p&gt;不过抛开你现有的知识，本章中对特性的井井有条的分类将会向你介绍动画引擎行为的细微差别。掌握这些细微差别将会帮助你从新手成为专业人士。即使你已经对jQuery动画和Velocity.js相当熟悉了，也给自己一个机会，快速浏览本章。&lt;strong&gt;你必定会发现一些你没意识到的可行之事。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译,Javascript" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91-Javascript/"/>
    
    
      <category term="翻译,Javascript" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91-Javascript/"/>
    
  </entry>
  
</feed>
