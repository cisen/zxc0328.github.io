<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zindex&#39;s blog</title>
  <subtitle>Frontend Rocks</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-22T12:05:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zindex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Travis CI和Github的前端云构建</title>
    <link href="http://yoursite.com/2017/05/22/fe-cloud-building/"/>
    <id>http://yoursite.com/2017/05/22/fe-cloud-building/</id>
    <published>2017-05-22T08:04:00.000Z</published>
    <updated>2017-05-22T12:05:50.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在思考团队里前端代码部署的问题，之前采用的方案是在本地构建，推到Github上一个专门放build后前端代码的仓库，然后Github的Webhook去触发后端的部署逻辑。代码就从这个仓库里拉取。&lt;/p&gt;
&lt;p&gt;这种方案看起来没什么大问题，但总觉得比较awkward。首先这套方案不够自动化，需要大量的人工操作。然后Github的Webhook其实并不是特别好用，如果后期要和我们内部的私有云平台对接起来，还要经过一些桥接才可以。&lt;/p&gt;
&lt;p&gt;本来呢，因为最近学了docker的缘故，我想写一个简单的Node服务，用来自动构建代码，然后通知服务端部署。每个应用就是一个单独的容器，这样环境就可以隔离。这个方案想来也不错。直到我仔细研究了一下Travis CI，才发现这个CI真是不简单。云端构建的任务用Travis CI就可以完美的实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;关于CI&quot;&gt;&lt;a href=&quot;#关于CI&quot; class=&quot;headerlink&quot; title=&quot;关于CI&quot;&gt;&lt;/a&gt;关于CI&lt;/h3&gt;&lt;p&gt;CI是持续集成的意思，持续集成里主要包括构建和测试代码。之前对Travis CI的印象是可以跑测试，仔细看了之后才发现Travis CI其实是一个云服务，提供了一个虚拟的Linux环境。你可以运行自定义的脚本。这个Linux环境的自由度还是非常大的。对于前端构建来说，Travis CI的网络环境可以快速安装npm包，这是一个非常大的优势。&lt;/p&gt;
&lt;h3 id=&quot;travis-yml文件&quot;&gt;&lt;a href=&quot;#travis-yml文件&quot; class=&quot;headerlink&quot; title=&quot;.travis.yml文件&quot;&gt;&lt;/a&gt;&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/h3&gt;&lt;p&gt;Travis CI的配置文件其实就是让你写几个生命周期hook，内容一般是shell命令。比如&lt;code&gt;install&lt;/code&gt;这个hook里主要写一些安装依赖的逻辑，&lt;code&gt;script&lt;/code&gt;这个hook里主要是写测试和构建的逻辑，&lt;code&gt;deploy&lt;/code&gt;这个hook里是写部署的逻辑。另外这几个hook都有各自的&lt;code&gt;before&lt;/code&gt;和&lt;code&gt;after&lt;/code&gt;版本。总而言之自由度是很大的。&lt;/p&gt;
&lt;p&gt;一个示例&lt;code&gt;.travis.yml&lt;/code&gt;文件。虽然我们不能直接&lt;code&gt;.travis.yml&lt;/code&gt;中写逻辑，但我们可以运行任意的脚本，所以可以看出&lt;code&gt;.travis.yml&lt;/code&gt;的能力基本等价于shell脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;language: node_js
node_js:
  - &amp;quot;7&amp;quot;
install:
  - npm install
script:
  - npm run build
after_script:
  - tar -cvf bundle.tar ./dist
  - node deploy.js
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;云端构建&quot;&gt;&lt;a href=&quot;#云端构建&quot; class=&quot;headerlink&quot; title=&quot;云端构建&quot;&gt;&lt;/a&gt;云端构建&lt;/h3&gt;&lt;p&gt;在看过了上节的&lt;code&gt;.travis.yml&lt;/code&gt;文件之后，云端构建的大致逻辑应该已经非常清楚了。我们在Travis CI的虚拟机中安装node依赖，build代码，压缩代码，然后运行一个js脚本。这个脚本的内容就是将代码上传到CDN。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deploy.js&lt;/code&gt;中还可以向后端的平台发送部署的请求，以达到自动部署的目的。如果后端是分布式的架构，向管理的节点发送请求即可。&lt;/p&gt;
&lt;h3 id=&quot;一些展望&quot;&gt;&lt;a href=&quot;#一些展望&quot; class=&quot;headerlink&quot; title=&quot;一些展望&quot;&gt;&lt;/a&gt;一些展望&lt;/h3&gt;&lt;p&gt;Travis CI的能力取决于这个虚拟机里提供了怎样的环境。Travis CI支持docker，因此我们可以用Travis CI进行docker镜像的构建和上传。Travis CI支持Nodejs，因此我们可以在虚拟机中安装hexo，进行博客的云端构建和自动部署。云端的构建，由于保证环境的隔离，因此稳定性会比本地高。以上都是Travis CI可能的用途。Travis CI作为一个云服务，在运维方面，还有无限的可能性等我们去探索&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在思考团队里前端代码部署的问题，之前采用的方案是在本地构建，推到Github上一个专门放build后前端代码的仓库，然后Github的Webhook去触发后端的部署逻辑。代码就从这个仓库里拉取。&lt;/p&gt;
&lt;p&gt;这种方案看起来没什么大问题，但总觉得比较awkward。首先这套方案不够自动化，需要大量的人工操作。然后Github的Webhook其实并不是特别好用，如果后期要和我们内部的私有云平台对接起来，还要经过一些桥接才可以。&lt;/p&gt;
&lt;p&gt;本来呢，因为最近学了docker的缘故，我想写一个简单的Node服务，用来自动构建代码，然后通知服务端部署。每个应用就是一个单独的容器，这样环境就可以隔离。这个方案想来也不错。直到我仔细研究了一下Travis CI，才发现这个CI真是不简单。云端构建的任务用Travis CI就可以完美的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编程语言实现模式》-阅读笔记</title>
    <link href="http://yoursite.com/2017/03/30/lip-notes/"/>
    <id>http://yoursite.com/2017/03/30/lip-notes/</id>
    <published>2017-03-30T13:34:59.000Z</published>
    <updated>2017-03-31T13:43:42.000Z</updated>
    
    <content type="html">&lt;p&gt;这里记录一下我阅读《编程语言实现模式》这本书的一些感受。一开始，对于编译原理，我的印象是这门课非常的艰深。在正式学习之前其实我已经看了很多编译相关的东西，比如V8，以及前端模板引擎等等。当时的感觉就是十分神奇。上了课之后首先接触的是形式文法、自动机和正规表达式等等。我的感觉就是，这些东西，是如何被前端大神们运用来写相关框架的呢，完全看不出门路嘛！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Jame Kyle的分享—&lt;a href=&quot;https://www.youtube.com/watch?v=Tar4WgAfMr4&amp;amp;t=9s&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《How to write a compiler》&lt;/a&gt;虽然很好，但是和有实际运用价值的编译技能还差的远呢。&lt;/p&gt;
&lt;p&gt;看龙书看的欲哭无泪，后来转而看《自制编程语言》，把crowbar的代码和流程大概了解了一下。最大的收获就是了解了yacc和lex。此前我对于Lexer和Parser还是抱有一定的恐惧心理的。&lt;/p&gt;
&lt;p&gt;最终让我认清门路的是戴嘉华的&lt;a href=&quot;https://github.com/livoras/blog/issues/14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;。后来我去翻了翻编译原理课本，让我彻底搞清楚几个事情：&lt;/p&gt;
&lt;p&gt;第一点，虽然波神说的很对，最关键的是动手去写，但了解必要的理论是很重要的。问题就在于，编译这边理论很多，类似有限自动机和正规表达式的转换等等知识，后端代码生成和优化等等，会加重认知的负担。所以关键就是，对于一个普通的工程师来说，开发文本处理或者DSL相关程序需要掌握的编译原理知识是哪些。&lt;/p&gt;
&lt;p&gt;第二点，需要了解的概念有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主流编译器，解释器的流水线&lt;/li&gt;
&lt;li&gt;形式文法（EBNF）&lt;/li&gt;
&lt;li&gt;LL(1)文法，以及EBNF和LL(1)之间的转换&lt;/li&gt;
&lt;li&gt;根据LL(1)文法写递归下降Parser&lt;/li&gt;
&lt;li&gt;了解不同的AST类型，会设计AST&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第二章-amp-amp-第三章&quot;&gt;&lt;a href=&quot;#第二章-amp-amp-第三章&quot; class=&quot;headerlink&quot; title=&quot;第二章&amp;amp;&amp;amp;第三章&quot;&gt;&lt;/a&gt;第二章&amp;amp;&amp;amp;第三章&lt;/h3&gt;&lt;p&gt;这章主要讲基于LL(1)的Tokenizing和Parsing。&lt;/p&gt;
&lt;p&gt;很妙的一点在于，在写关于形式文法的地方，这本书没有将BNF和乔姆斯基之类的科班教材中讲的，而是讲文法当成是一种DSL，这其实是非常正确的。Parser Generator的输入一般就是某种类似BNF的DSL。本书中的例子是ANTLR（一个parser generator）的DSL。&lt;/p&gt;
&lt;p&gt;这种务实的风格是延续在整个第二章中的，讲LL(1)的First和Follow集的时候，是这样说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正规的定义中通常使用FIRST和FOLLOW两个运算来计算向前看集合，而实际使用时，这个问题可以等价于“哪些词法单元可能会出现在这个解析选项的开头”，这种思维方式更容易掌握，FIRST和严格定义就不在这里解释了，因为它比较复杂，而且这里也用不着其原理。如果有兴趣，可以在网上找到很多相关材料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First集合的数学定义是这样的：&lt;/p&gt;
&lt;p&gt;试想一下，如果初学者接触到的是严谨的数学定义，而不是一个相对直白的解释和代码演示的话，还是会有不少人打退堂鼓的。&lt;/p&gt;
&lt;p&gt;在实际的学习中，还是需要一些如上文中的“等价于”那样的解释。&lt;/p&gt;
&lt;p&gt;LL(1)的parser是最简单的。也是其余递归下降模式的基础框架。实现的方式就是为每一个规则写一个对应的函数，函数里按First集合来编写，规则里的运算符都可以转化为if或者while等到逻辑，如果是终结符就match，如果是非终结符就递归调用对应规则的函数。&lt;/p&gt;
&lt;p&gt;我看了Regularjs中parser的代码以及上文中vdom模板引擎的代码，结合书中的例子，大概搞懂了，接下来可以把书中的例子用js写一遍试试。&lt;/p&gt;
&lt;p&gt;第二章最后讲了LL(k)类型的parser。LL(k)就是任意k个token的lookup。LL(k)的需求，拿mcss来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mcss有点特殊，是个LL(n)的解释器，比如在设计中，函数在mcss是 First-class的，可以被返回或传入函数，并保持作用域信息，所以它是一种特殊的值，定义我设计与一般赋值一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$size = ($width, $height) { 
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里当你不读取到&lt;code&gt;{&lt;/code&gt; 是无法判断 &lt;code&gt;=&lt;/code&gt; 后面是函数定义 还是 普通css中的 compound&lt;br&gt;values  . 众所周知参数列表可能无限长，所以必须是LL(n)的Parser才能够解答。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有些语言语法里有很相似的语言结构，它们只在最后边才有区别。比如C++的函数定义和函数声明的前面都是一样的，直到;或{才能加以区别。&lt;/p&gt;
&lt;p&gt;所以想要能够写DSL解释器的话，LL(k)式的模式也是要懂的。LL(k)的问题就是要要预parse，如果条件满足，再真正parse一遍。这样带来的问题就是运行效率上比较慢。解决的办法是&lt;strong&gt;回溯法&lt;/strong&gt;，通过类似动态规划的空间换时间的方法，缓存parse的结果，加速parse的过程。&lt;/p&gt;
&lt;h3 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h3&gt;&lt;p&gt;Vue的AST。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下我阅读《编程语言实现模式》这本书的一些感受。一开始，对于编译原理，我的印象是这门课非常的艰深。在正式学习之前其实我已经看了很多编译相关的东西，比如V8，以及前端模板引擎等等。当时的感觉就是十分神奇。上了课之后首先接触的是形式文法、自动机和正规表达式等等。我的感觉就是，这些东西，是如何被前端大神们运用来写相关框架的呢，完全看不出门路嘛！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>crowbar-note-1</title>
    <link href="http://yoursite.com/2017/03/28/crowbar-note-1/"/>
    <id>http://yoursite.com/2017/03/28/crowbar-note-1/</id>
    <published>2017-03-28T10:52:55.000Z</published>
    <updated>2017-03-28T10:52:55.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>产品思维碎碎念</title>
    <link href="http://yoursite.com/2017/03/27/product-share-overview/"/>
    <id>http://yoursite.com/2017/03/27/product-share-overview/</id>
    <published>2017-03-27T04:35:28.000Z</published>
    <updated>2017-03-28T10:41:17.000Z</updated>
    
    <content type="html">&lt;p&gt;理论上来说，我们团队的成员都应该是对互联网有特殊热情的同学，或者是对手机里的各种App如数家珍，或者是对各大网站了如指掌。现在看来，之前有这方面的偏好，当然是好，但大多数人对互联网还没有那么深的认知。因此我觉得我们需要通过一系列的分享，来使得大家养成产品思维。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;互联网公司大局&quot;&gt;&lt;a href=&quot;#互联网公司大局&quot; class=&quot;headerlink&quot; title=&quot;互联网公司大局&quot;&gt;&lt;/a&gt;互联网公司大局&lt;/h3&gt;&lt;p&gt;截止目前（2017年3月28日），中国上市互联网公司的市值排名前五位的是：&lt;/p&gt;
&lt;p&gt;1 腾讯 2800亿美元&lt;br&gt;2 阿里巴巴 2668亿美元&lt;br&gt;3 百度 582亿美元&lt;br&gt;4 京东 445亿美元&lt;br&gt;5 网易 387亿美元  &lt;/p&gt;
&lt;p&gt;另外还有一些著名的上市互联网公司，比如微博、搜狐、携程等等。著名的非上市互联网公司有小米、美团和蚂蚁金服。独角兽公司（未上市，估值超过100亿美元的创业公司）有滴滴和今日头条。&lt;/p&gt;
&lt;p&gt;这些公司基本上占据了中国互联网的大部分版图。这些公司之间由合作也有竞争，并不是毫无关系的。腾讯和阿里两个巨无霸都想在竞争对手擅长的领域布局，比如腾讯投资了京东，在腾讯的应用中，会向京东导入流量，京东的支付也会优先支持微信支付。在O2O市场，阿里投资了饿了么，腾讯投资了美团大众点评。在社交方面，阿里投资了微博，目前微博盈利能力增强，但依然和阿里有着很深的合作关系。当然阿里也进行了很多直接的收购，比如优酷和UC等。&lt;/p&gt;
&lt;p&gt;大家要养成的能力就是，看到一家公司时，要能够说出这家公司的主流产品和所属的领域。比如阿里，大家可能觉得主要是电商，但其实阿里目前发展的比较快的还有云计算业务。了解一家公司服务的布局，最好的办法就是看公司的财报。比如大家如果看了网易的财报，就会很轻松的发现网易其实是一家游戏公司，发展的比较快的是跨境电商业务，其他就是广告收入，而其他的众多产品，在营收上贡献不大。公司毕竟是以盈利为目的的，因此盈利多的领域基本就可以认为是公司会主力经营的业务。后面我们会专门做一个《如何解读互联网公司财报》的分享。&lt;/p&gt;
&lt;p&gt;对国外的互联网公司也要了解。虽然因为国内的政治环境、基础设施、用户群体等等原因，国内的互联网世界和国外有很多不同之处，但不可否认的是国内互联网创业的模式大部分还是借鉴国外的。比如Uber和滴滴，Twitter和微博等等。国外互联网公司，主要是美国，主要就是Google、Facebook、Aamazon、Linkedin几家大公司和Twitter、Uber、Airbnb等等有名的创业公司。国外的互联网，在技术、商业、设计和产品上都是领先的，为了拓展自己的视野，大家就更要关注了。&lt;/p&gt;
&lt;h3 id=&quot;产品的分类&quot;&gt;&lt;a href=&quot;#产品的分类&quot; class=&quot;headerlink&quot; title=&quot;产品的分类&quot;&gt;&lt;/a&gt;产品的分类&lt;/h3&gt;&lt;p&gt;产品分类其实是一门玄学。因为分类的标准有很多种。你可以按产品的功能来分，那么自拍类产品应该属于摄影产品。但App Store里自拍相机类产品是分在社交这个分类下的，因为自拍产品最终产出的目的是为了在社交网络上展示。这是自拍产品的特有的属性。&lt;/p&gt;
&lt;p&gt;所以分类这个，因人而异。大家只要在自己脑海里建立一个体系，遇到产品能顺利的归类，就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社交&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主流的社交应用，包括很多类别，即时通讯类的主要就是微信和QQ，钉钉这样的办公应用也是这个类别。匿名社交的比如陌陌。&lt;/p&gt;
&lt;p&gt;早期的博客和论坛，有很强的社交属性，也有一定的内容属性，我们可以叫社区类产品，暂且归类到社交类下。如果你用论坛但是只是默默潜水，那就偏内容属性，所以这个还要看用户的使用。&lt;/p&gt;
&lt;p&gt;互联网发展早期的博客的论坛现在已经进化出了很多的形式，比如微博和贴吧。社交作为一种功能，现在也被广泛的集成到各种“主业”不是社交的应用中，比如天气App里面可以有一个简单的社区。&lt;/p&gt;
&lt;p&gt;因此社交类应用是指，主要功能是社交的应用。其他应用也可以集成社交功能，从而拥有社交属性，比如支付宝，但这样没法改变一个应用的本质属性。大家在分析App的时候，要注意这一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电商&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电商应用的特征相对来说比较鲜明，当然里面也可以分为B2B的比如阿里巴巴，B2C的比如天猫和京东，C2C的比如淘宝和闲鱼。电商领域按售卖商品的类别，也可以细分为，跨境电商（考拉海购、小红书）、美妆电商（蘑菇街、美丽说、聚美优品）、生鲜电商等等各种细分的市场。我们一般把这些App成为垂直领域应用。意思就是这类App的目标用户只是针对某一类人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;O2O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;O2O（Online To Offline）类的应用，其实应该是电商下的一个子类，和B2C和C2C并列。但由于这块市场这几年的增长非常快，潜力很大，因此现在我们一般单独拿出来讨论。&lt;/p&gt;
&lt;p&gt;O2O主要涉及的是人的衣食住行以及吃喝玩乐，比如各种外卖（饿了么）、团购（美团大众点评）、出行（滴滴、Ofo）等等。将线下的生意和线上的在线支付和用户体系等等结合起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摄影&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前说了，自拍应用在App Store中是放在社交类别下的。不管如何，摄影类的应用在手机自带相机质量越来越好，社交应用非常普及的今天，需求是非常大的。看一下图片社交应用Instagram的情况，就可以知道图片社交是目前社交网络中最主流的一种形式。&lt;/p&gt;
&lt;p&gt;这个市场的特点是基本没有一款应用能占据大部分份额，各家都有机会。这可能是因为用户对摄影的应用有着个性化的需求，也可能是因为大公司没有进入这一市场的缘故。国内在这方面做的大的是美图，现在已经在香港上市了。这一类的应用要发展，纯粹的工具属性是不够的，一般都需要借助社交平台之力。&lt;/p&gt;
&lt;p&gt;这里要提一下的是最近非常火的短视频应用。短视频应用其实算是一种视频社交应用，放到社交分类下讨论也是可以的，比如秒拍，快手等等。自建社区毕竟是一种高风险的决策，秒拍和微博合作，因此秒拍会的内容会嵌入微博的Feed流，借助了社交平台的力量，给秒拍带来了曝光。关于短视频应用，我们今后也会进行专题的讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;效率类应用有笔记应用、Office类应用、todo类应用、日程规划应用、日记应用，还有一些番茄钟应用，用来协助用户提高工作效率。&lt;br&gt;其他的工具类应用则是五花八门了，天气应用，记账应用等等，这些在App Store里面是有专门的类别的。&lt;/p&gt;
&lt;p&gt;Workflow和Pin这种比较高端的效率App，一般都是由个人开发者开发，可以说是应用商店中的一股清流。这样的App也许是比较适合我们去尝试开发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旅行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旅行这个分类主要是从市场来看的，旅行类应用瞄准的是人们出行时的需求，机票、酒店、景区门票、攻略、行程安排等等。&lt;/p&gt;
&lt;p&gt;主要的玩家是携程去哪儿。最近Airbnb进入中国市场，Airbnb主要的竞争对手是酒店，Airbnb今后的目标是进军整个旅行市场。专注于旅行本身的有蚂蜂窝、蝉游记、面包旅行、氢气球旅行等等。当然携程这样的巨无霸App中也是集成了旅行相关的功能的。&lt;/p&gt;
&lt;p&gt;综上，旅行市场看起来还是比较简单的，酒店机票业务实际也属于O2O的范畴。最近Airbnb的兴起，应该会为这个市场带来一些变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;教育&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在线教育这个市场，是近几年随着MOOC的发展而发展的一个市场。这个市场可以分为几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;职业培训（网易云课堂，特别是里面的微专业）&lt;/li&gt;
&lt;li&gt;K12教育（比如百度作业帮、小猿搜题）&lt;/li&gt;
&lt;li&gt;资格培训（各种托福雅思公务员驾照App，比如猿题库）&lt;/li&gt;
&lt;li&gt;MOOC（国内的有学堂在线、中国大学MOOC，当然也包括Coursera和edX等等老玩家）&lt;/li&gt;
&lt;li&gt;科教类（比如榫卯，烧杯以及各种以交互式的科普知识为目的的App）&lt;/li&gt;
&lt;li&gt;英语类（这类应用也属于广义的工具类应用，背单词是为考试服务的，因此也可以说是属于前面提到的几种类别，但因为需求最大，因此可以单独讨论，主流的比如英语流利说、扇贝单词和百词斩）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有部分应用会同时做职业培训、K12、K17（高考）等等方面，比如有道精品课。&lt;/p&gt;
&lt;p&gt;目前中国中产阶级越来越多，消费升级表现之一就是对于教育的投资。线下和线上的教育市场都会被拉动起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;视频/音乐类&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;视频和音乐类应用的历史很悠久了，这里说的是提供视频和音乐服务的产品。视频方面有优酷土豆、PPTV、乐视、搜狐视频等。音乐方面有QQ音乐、网易云音乐和虾米音乐。&lt;/p&gt;
&lt;p&gt;互联网时代，中国的视频和音乐市场最关键是就是版权之争。10年前版权宽松的时代已经一去不复返了。现在的视频网站的资源主要来自版权的购买。&lt;/p&gt;
&lt;p&gt;除此之外，自制内容也是很火的。国外这方面最典型的就是Netflix。国内比较典型的就是乐视自制的《太子妃升职记》，还有之前在优酷上火的万合天宜系列的网剧。目前国内比较流行的模式就是拿一个IP（知识产权，比如畅销小说）改编网剧（因为国内IP不够优质，最近开始改编日剧，不过质量实在是惨不忍睹）。个人觉得目前来说国内的文化产业还是比较浮躁的，比较着急赚钱变现。&lt;/p&gt;
&lt;p&gt;音乐市场上，网易云音乐也希望能挖掘草根音乐人并与其达成合作，在残酷的版权竞争之外另辟蹊径。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;资讯类&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;资讯类包括了老牌门户网站新浪网易搜狐的新闻客户端，以及新秀今日头条和UC等。今日头条和主打的是个性化的推荐，UC则是用其独特的编辑风格，吸引了很多人的眼球。&lt;/p&gt;
&lt;p&gt;也有好奇心日报和一个这种垂直类的内容提供商。好奇心日报专注于报道互联网、快时尚、消费电子等行业的新闻，同时也有着独特的互动栏目，主要瞄准的是年轻人生活中的种种。一个可以理解为一个平台，培养一些在网络上受欢迎的“网红”作家。&lt;/p&gt;
&lt;p&gt;P.S. 网红这个词，比如网红作家，网红剧等，基本可以等同于，在90后左右的年轻人为主的社交网络中被广泛传播和讨论，有一定人气的意思。不仅仅是Papi酱这种传统意义的网红，知乎大V，甚至支付宝的微信公众号，只要是在社交网络上有很多Follower的，都称为网红。&lt;/p&gt;
&lt;p&gt;P.P.S 好奇心有一个栏目叫“好奇心词典”，专门解释在当前时代语境下的新鲜词汇。上面的解释大概就是这个模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏就不用多说了。国内手机游戏的巨头是腾讯，第二的是网易，但网易和腾讯之间的差距还是非常明显的。腾讯的游戏依托自身的流量平台，以及相对更平民化的研发策略，占据了大部分的市场。游戏这个市场的特点就是寡头瓜分市场，小公司很难生存。利润上来说游戏是互联网行业中最高的之一。&lt;/p&gt;
&lt;h3 id=&quot;产品的盈利模式&quot;&gt;&lt;a href=&quot;#产品的盈利模式&quot; class=&quot;headerlink&quot; title=&quot;产品的盈利模式&quot;&gt;&lt;/a&gt;产品的盈利模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;广告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广告是历史最悠久的互联网产品盈利模式了。互联网开山鼻祖Google一开始就是靠广告作为收入来源的。&lt;/p&gt;
&lt;p&gt;广告一般嵌入在应用的展示位中，按点击来进行收费。&lt;/p&gt;
&lt;p&gt;Google和Facebook这种掌握了大量流量的公司，会专门有部门来负责广告的投放，也会提供工具来让广告主对自己的广告进行管理和数据分析。&lt;/p&gt;
&lt;p&gt;甚至有Google Ads这种产品，提供给你一个广告平台，你把代码放到自己的产品中，通过用户的点击，获得收入。广告主只需要和Google Ads进行接触。&lt;/p&gt;
&lt;p&gt;除了搜索引擎和社交应用，内容类产品和工具类产品也可以用广告进行变现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电商&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电商是最容易理解的，因为电商的盈利模式和线下的零售业是很相似的。&lt;/p&gt;
&lt;p&gt;B2C的电商比如京东，可以从自营商品的销售中直接获利，而淘宝这样的C2C平台，是通过向店主收取服务费用进行盈利的，O2O的盈利模式也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内购&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏的内购，售卖的是虚拟道具。&lt;/p&gt;
&lt;p&gt;工具类产品的内购，售卖的是高级功能。本质上是将服务标价售卖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识变现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知识变现是最近比较火的一种新的盈利模式，当然本质上还是一种收费的服务。&lt;/p&gt;
&lt;p&gt;常见的知识变现有打赏、收费提问、Live、收费群等等。&lt;/p&gt;
&lt;p&gt;知乎Live售卖的是讲座的门票，小密圈售卖的是和圈主交流的机会。知识变现的本质是提供服务，通过这个服务，用户可以学习到知识。其实和我们熟悉的收费培训道理是一样的，只不过目前的知识变现侧重于碎片化的分享和交流，而不是体系化的培训。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;以上，总结了我个人认为对产品思维入门比较重要的三个点。还有很多地方没有谈到，比如在产品分类时没有提到直播应用（其实是直播应用比较复杂，有点难分类）。这是我心目中一个互联网从业者应该有的认知，在这个基础上，我们才能对具体的产品，具体的行业，进行更深入的研究和思考。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;理论上来说，我们团队的成员都应该是对互联网有特殊热情的同学，或者是对手机里的各种App如数家珍，或者是对各大网站了如指掌。现在看来，之前有这方面的偏好，当然是好，但大多数人对互联网还没有那么深的认知。因此我觉得我们需要通过一系列的分享，来使得大家养成产品思维。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>终端工具翻墙不完全指南</title>
    <link href="http://yoursite.com/2017/03/26/proxy-for-terminal/"/>
    <id>http://yoursite.com/2017/03/26/proxy-for-terminal/</id>
    <published>2017-03-26T14:10:22.000Z</published>
    <updated>2017-03-28T11:24:19.000Z</updated>
    
    <content type="html">&lt;p&gt;写这篇文章的动机是之前Github曾经短暂的被墙过，这样的话，如果终端没有翻墙，那就没法推代码了。之后几天国内访问Github也一直很慢，于是尝试了给终端翻墙。网上的文章很多，但没有特别满意的，因此决定自己写一篇。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;说是不完全指南，因为我这篇文章针对的是macOS下使用Shadowsocks翻墙的用户来说的。当然其他其他的系统，如果是使用Shadowsocks，道理应该差不多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预备工作&lt;/strong&gt;：安装Shadowsocks客户端，配置好服务器。搞清楚Shadowsocks在本地运行的端口，一般是1080或者1086。&lt;/p&gt;
&lt;h3 id=&quot;Homebrew翻墙&quot;&gt;&lt;a href=&quot;#Homebrew翻墙&quot; class=&quot;headerlink&quot; title=&quot;Homebrew翻墙&quot;&gt;&lt;/a&gt;Homebrew翻墙&lt;/h3&gt;&lt;p&gt;macOS下装软件要用Homebrew，但Homebrew的源在国外，国内用是很慢的。首先我们要让Homebrew翻墙，才能顺利的往下进行其他工作。&lt;/p&gt;
&lt;p&gt;Homebrew下载用的是curl。因此我们只要配置curl使用代理就可以了。&lt;/p&gt;
&lt;p&gt;curl的代理在&lt;code&gt;~/.curlrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们在这里加一行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socks5 = “127.0.0.1:1080”&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;1080是之前说的Shadowsocks的本地端口，下文就不再说明了。&lt;/p&gt;
&lt;h3 id=&quot;安装Polipo&quot;&gt;&lt;a href=&quot;#安装Polipo&quot; class=&quot;headerlink&quot; title=&quot;安装Polipo&quot;&gt;&lt;/a&gt;安装Polipo&lt;/h3&gt;&lt;p&gt;&lt;code&gt;brew install polipo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;装好后记得把之前加上的curl的代理删掉。&lt;/p&gt;
&lt;p&gt;然后配置polipo，修改&lt;code&gt;/usr/local/opt/polipo/homebrew.mxcl.polipo.plist&lt;/code&gt;设置&lt;code&gt;parentProxy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;homebrew.mxcl.polipo&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
    &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
    &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
    &amp;lt;array&amp;gt;
        &amp;lt;string&amp;gt;/usr/local/opt/polipo/bin/polipo&amp;lt;/string&amp;gt;
        &amp;lt;string&amp;gt;socksParentProxy=localhost:1080&amp;lt;/string&amp;gt;
    &amp;lt;/array&amp;gt;
    &amp;lt;!-- Set `ulimit -n 20480`. The default OS X limit is 256, that&amp;#39;s
         not enough for Polipo (displays &amp;#39;too many files open&amp;#39; errors).
         It seems like you have no reason to lower this limit
         (and unlikely will want to raise it). --&amp;gt;
    &amp;lt;key&amp;gt;SoftResourceLimits&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
      &amp;lt;key&amp;gt;NumberOfFiles&amp;lt;/key&amp;gt;
      &amp;lt;integer&amp;gt;20480&amp;lt;/integer&amp;gt;
    &amp;lt;/dict&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加了&lt;code&gt;&amp;lt;string&amp;gt;socksParentProxy=localhost:1080&amp;lt;/string&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后配置polipo开机自启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样polipo就设置完成了，polipo的http代理默认在&lt;code&gt;localhost:8123&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;NPM翻墙&quot;&gt;&lt;a href=&quot;#NPM翻墙&quot; class=&quot;headerlink&quot; title=&quot;NPM翻墙&quot;&gt;&lt;/a&gt;NPM翻墙&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;npm config set proxy http://127.0.01:8123
npm config set https-proxy http://127.0.0.1:8123
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Git翻墙&quot;&gt;&lt;a href=&quot;#Git翻墙&quot; class=&quot;headerlink&quot; title=&quot;Git翻墙&quot;&gt;&lt;/a&gt;Git翻墙&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;git config --global http.proxy http://localhost:8123
git config --global https.proxy http://localhost:8123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用&lt;code&gt;git config --list&lt;/code&gt;查看是否设置成功。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;上面讲了NPM和Git的代理。其他工具的话，道理是一样的，如果直接支持socks5代理，那是最好。一般都支持Http代理，比如Genymotion。遇到工具网络请求很慢的情况，设置具体工具的代理就可以了。我之前以为在终端设置&lt;code&gt;export http_proxy=http://localhost:8123&lt;/code&gt;就可以。结果并不是这样，并不是所有的工具都走这个终端的代理。&lt;/p&gt;
&lt;p&gt;终端也有了代理，从此我们就可以愉快的进行开发了。妈妈再也不用担心我的cnpm出什么问题了，推代码到Github的心情也更轻松了，连更新博客都勤快了很多呢！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为终端设置Shadowsocks代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的动机是之前Github曾经短暂的被墙过，这样的话，如果终端没有翻墙，那就没法推代码了。之后几天国内访问Github也一直很慢，于是尝试了给终端翻墙。网上的文章很多，但没有特别满意的，因此决定自己写一篇。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊云计算</title>
    <link href="http://yoursite.com/2017/03/21/about-cloud/"/>
    <id>http://yoursite.com/2017/03/21/about-cloud/</id>
    <published>2017-03-21T07:17:18.000Z</published>
    <updated>2017-03-24T14:00:46.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要是写我对团队在云计算方向上现状的一些思考。并没有什么关于云计算的干货，毕竟我在这方面还需要大量的实践才能有足够的发言权。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;IaaS&quot;&gt;&lt;a href=&quot;#IaaS&quot; class=&quot;headerlink&quot; title=&quot;IaaS&quot;&gt;&lt;/a&gt;IaaS&lt;/h3&gt;&lt;p&gt;我们用的最多的就是IaaS（Infrastructure as a Service）了。阿里云中的ECS和RDS就是典型的IaaS，另外阿里云OSS或者亚马逊S3那样的存储服务也是。&lt;/p&gt;
&lt;p&gt;IaaS，简单的理解就是，将计算资源，作为一种基础设施，提供给用户。用户可以像消费水和电一样来按需进行使用计算资源。&lt;/p&gt;
&lt;p&gt;IaaS是基于虚拟化和分布式技术来提供服务的。在云计算之前的时代，公司的网站是部署在一台台实体的服务器上的。一般来说，一家小公司，可能只需要一两台服务器就可以满足业务需求了。有服务器也自然有传统的运维人员，这种工程师精通硬件、网络和安全方面的知识，全权负责机房里服务器的正常运转和性能优化。&lt;/p&gt;
&lt;p&gt;然而维护一台实体服务器的成本是很高的，需要雇佣一个服务器运维人员，需要付出电费和购置服务器的费用，以及架设网络的成本。&lt;/p&gt;
&lt;p&gt;大公司会建立数据中心，其实就是有着大量服务器的厂房。大公司有着足够的人力去维护自有的服务器。&lt;/p&gt;
&lt;p&gt;在那个年代，后端工程师部署服务是直接部署在实体机器上的，在部署时需要和运维人员确定服务器的环境等，经常会有一些沟通上的问题。&lt;/p&gt;
&lt;p&gt;还有一个问题则是，那时的网站是很难动态伸缩的，一个应用往往同时部署在多台服务器上。然而，要使得一个服务能抗下更多的流量，就需要更多的服务器，如果不能在短时间内配置好新服务器，网站在压力之下往往会崩溃。&lt;/p&gt;
&lt;p&gt;云计算对于小公司的好处在于，消除了维护实体服务器需要的各种繁杂的成本。维护实体服务器的责任交给了云服务厂商。小公司只需要购买服务就可以。&lt;/p&gt;
&lt;p&gt;对于大公司来说，云计算可以动态扩容，一键部署，使得应用在压力之下可以弹性伸缩。将计算资源利用率最大化。&lt;/p&gt;
&lt;p&gt;我们使用的ECS其实并不对应一台实体的服务器，但我们在使用的时候可以将ECS当成一台完整的服务器来使用。这就是虚拟化技术的好处。我们可以按需使用计算资源（一台实体服务器往往是8核或者16核CPU这样的配置，我们用不到这么多的CPU）。&lt;/p&gt;
&lt;p&gt;我们也不用担心服务器会被攻击或者数据丢失。ECS提供了自动快照的服务。&lt;/p&gt;
&lt;p&gt;在我看来云计算是对计算资源做的一次抽象，将后端应用和实体的服务器硬件资源隔离了。使得基于硬件的备份和维护这些事情抽象出来，开发人员只用关注应用层面的逻辑就可以了。&lt;/p&gt;
&lt;p&gt;而RDS和OSS这些服务，也是同理。我们不用关心存储具体的物理位置在哪台服务器上，只需要调用这个服务就可以了。&lt;/p&gt;
&lt;p&gt;而RDS、ECS和OSS三个服务的分离，也是一种抽象。ECS只关心业务逻辑，OSS和RDS只关心数据存储。只有无状态的服务才能轻松实现横向的拓展。如果ECS上的应用和数据库一起部署的话，会对应用的可拓展性造成影响。&lt;/p&gt;
&lt;p&gt;具体说到我们团队，ECS和RDS我们使用阿里云的服务。对象存储我们则打算自建。一个是利用手上的物理服务器，降低一些成本，还有一个就是研究一下分布式存储相关的技术，加深团队在云计算方面的技术深度（Ceph这个开源的分布式存储框架已经非常强大了，我们目前打算先尝试Ceph）。&lt;/p&gt;
&lt;h3 id=&quot;PaaS&quot;&gt;&lt;a href=&quot;#PaaS&quot; class=&quot;headerlink&quot; title=&quot;PaaS&quot;&gt;&lt;/a&gt;PaaS&lt;/h3&gt;&lt;p&gt;PaaS（Platform as a Service）方面的服务的代表就是Google的App Engine（以下简称GAE）。在App Engine中你只需要写业务逻辑，不需要关心服务和数据的部署。GAE号称会根据你应用的流量实时拓展服务的部署。&lt;/p&gt;
&lt;p&gt;GAE带来的其实是更高的一层抽象。将基础设施的使用也屏蔽了。其实这个就将当于大家写了一个Flask应用，push到Github，写一个简单的配置文件，然后就可以访问了。你不用关心Nginx的配置，也不用关心部署多个实例以及均衡负载这些问题。It just works。&lt;/p&gt;
&lt;p&gt;另外你还可以在控制台用GUI控制你的应用，以及读取监控数据等等。&lt;/p&gt;
&lt;p&gt;我对此是非常感兴趣的，特别是Docker的出现，使得自动化的部署，环境的隔离以及标准化变成了一件比较简单的事情。&lt;/p&gt;
&lt;p&gt;我构想中的Muxi App Engine（以下简称MAE）是这样的：&lt;/p&gt;
&lt;p&gt;支持Python和Node两种环境，会根据ECS上的实时部署情况，自动将容器实例部署在最合适的ECS上，并且在流量变大时会自动伸缩。在MAE控制台上可以看到常规的Log统计。可以在MAE上用配置中的Git仓库和分支进行一键部署，前端代码也是一样的。&lt;/p&gt;
&lt;p&gt;MAE的目标是将一些应用公共的流程尽量标准化，目前我们的自动化部署还是需要自己写Webhook脚本的。统计的话也是需要手动去配置的。Nginx相关的一些配置也是手动的。&lt;/p&gt;
&lt;p&gt;MAE是一个单独的服务，部署在一台服务器上。MAE对可支配的ECS都有着记录，并且在对应的ECS上都运行着守护进程，和MAE服务通信。&lt;/p&gt;
&lt;p&gt;MAE时代的开发和目前并没有太大的区别，只是每个应用需要有一个MAE的配置文件，里面写了域名、Github仓库、Docker环境等等信息。&lt;/p&gt;
&lt;p&gt;我们在MAE上新建一个应用，然后点击部署，就可以部署了。&lt;/p&gt;
&lt;p&gt;对于我们的大部分，自己托管数据的应用（相比匣子这样需要实时爬取的应用），比如学而、桂声等等，MAE这样的模式可以很好的讲平台层的运维工作简单化、标准化。&lt;/p&gt;
&lt;p&gt;当然MAE如何和微服务结合这个也是一个问题，目前的应用其实是有分拆成服务的空间的，这样的话MAE其实应该是以服务为单位的。&lt;/p&gt;
&lt;h3 id=&quot;SaaS&quot;&gt;&lt;a href=&quot;#SaaS&quot; class=&quot;headerlink&quot; title=&quot;SaaS&quot;&gt;&lt;/a&gt;SaaS&lt;/h3&gt;&lt;p&gt;SaaS（Software as a Service）离普通用户最近的云计算形式。我们用Tower、百度云盘、石墨文档这些，都属于SaaS。&lt;/p&gt;
&lt;p&gt;我们日后推出的服务，比如云简历，或者是其他工具类的应用，都是以软件形式向用户提供了某种基于云计算的服务。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;基于综合的考虑，我认为云计算是目前最有用，也是最触手可及的前沿技术。&lt;/p&gt;
&lt;p&gt;目前后端技术这边，机器学习/人工智能、云计算、大数据，是几个比较火的领域。当然这几个领域目前有融合的趋势。&lt;/p&gt;
&lt;p&gt;对于我们来说，要构筑我们的技术壁垒，云计算是最好的突破口。在知识水平、业务体量等种种的不利因素下，云计算是可以深挖，并且&lt;strong&gt;实践&lt;/strong&gt;的一个领域。&lt;/p&gt;
&lt;p&gt;无论是对于我们内部服务的支持，或者是对于个人技术能力，就业市场竞争力的提升来说，这都是一个最优的方向。&lt;/p&gt;
&lt;p&gt;所以在接下来的很长一段时间，我希望大家能一起努力，在云计算上，达到一个不算太寒碜的水准。这需要所有同学的支持，包括前端、客户端和设计组的同学，因为转向云计算会对目前的开发流程产生很大的影响。然后在UI和品牌方面，自然也需要前端和设计师的配合。PM同学也需要理解这个战略。&lt;/p&gt;
&lt;p&gt;就写这么多吧。祝一切顺利。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是写我对团队在云计算方向上现状的一些思考。并没有什么关于云计算的干货，毕竟我在这方面还需要大量的实践才能有足够的发言权。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://yoursite.com/2016/12/26/my2016/"/>
    <id>http://yoursite.com/2016/12/26/my2016/</id>
    <published>2016-12-26T06:58:46.000Z</published>
    <updated>2017-01-01T08:40:08.000Z</updated>
    
    <content type="html">&lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;回看我的进度，1月的时候我开始写简历生成器和学而的后台，那段时间我对于前端工程化很痴迷。把Dan Abramov的视频看了很多遍。主要用React写东西。&lt;/p&gt;
&lt;p&gt;寒假主要是写学而后台，写个人主页，看YDKJS和《JavaScript忍者秘籍》。寒假里面我发现了大批的电子书，对于JS的语言有了更深入的了解。也开始对公司和业务有一些自己的思考。我对于浏览器的探索也在那个时候开始了，主要是看了Mozilla工程师写的自制浏览器那一系列的博客。从进度上来看，那个时候真是热火朝天的学学学，新事物扑面而来，整个人还是很有干劲的。&lt;/p&gt;
&lt;p&gt;在找工作这问题上，当时我还是很没有底的。&lt;/p&gt;
&lt;p&gt;那段时间还在刷PAT，打算去参加春季的考试，但最后还是没有去，觉得没有准备好。&lt;/p&gt;
&lt;p&gt;接下来就是3月了，开学了，要上课要辅修，事情很多。学习的进度就没有那么快了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.14&lt;/p&gt;
&lt;p&gt;投简历+学而+团队+i华大 = 爆炸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来就是接触简单的算法，去网易面试。&lt;/p&gt;
&lt;p&gt;4月学校的出版社实习期间开始看jQuery源码。&lt;/p&gt;
&lt;h3 id=&quot;找工作&quot;&gt;&lt;a href=&quot;#找工作&quot; class=&quot;headerlink&quot; title=&quot;找工作&quot;&gt;&lt;/a&gt;找工作&lt;/h3&gt;&lt;p&gt;3月开始面试，第一个面的是阿里，二面挂了，一些很简单的问题没有准备，比如正则和简单的DOM API。后来面了饿了么，过了。在面试网易的时候，饿了么表示如果不能确定offer那就算了，于是我就在没有保底offer的情况下，去网易面试了。&lt;/p&gt;
&lt;p&gt;去网易的面试算是我第一次很正式的面试。总的来说，其实很平稳，但对我来说，记忆犹新。最让我感到印象深刻的还是面试期间那种忐忑的心情。好在最后一切顺利。现在看来，觉得还是挺幸福的。&lt;/p&gt;
&lt;h3 id=&quot;团队&quot;&gt;&lt;a href=&quot;#团队&quot; class=&quot;headerlink&quot; title=&quot;团队&quot;&gt;&lt;/a&gt;团队&lt;/h3&gt;&lt;p&gt;5月份的时候，团队出了大事，主要就是工作室要装修。领导为了面子工程，把我们的304改成了展示厅。对当时的我来说这真是和晴天霹雳一般。&lt;/p&gt;
&lt;p&gt;匆忙的租了房子，其实最后也没起多大作用。这次搬家对我们来说，意味着很多。和过去告别。真正的成长，担起团队的责任。&lt;/p&gt;
&lt;p&gt;这个时候，我们确立了核心成员的概念。一个团队，只需要核心成员，不是核心成员的都可以离开了。一个团队的人数并不是关键，团队的凝聚力和战斗力才是最关键的。&lt;/p&gt;
&lt;p&gt;其他的话，其实从我进度里看，关于团队的很多。大部分都是一些消极的抱怨，还有一些思考。暑假的时候，和大家远程交流，开会。很困难，到最后其实很有多的摩擦。但无论如何，事情都算是过去了。&lt;/p&gt;
&lt;p&gt;在12月的时候，我决定从团队的日常事务中抽身，专心做自己的事情。经过这段时间来看，团队是可以自己正常运转的。很开心啊，像是自己的孩子长大了一样。&lt;/p&gt;
&lt;h3 id=&quot;在网易的三个月&quot;&gt;&lt;a href=&quot;#在网易的三个月&quot; class=&quot;headerlink&quot; title=&quot;在网易的三个月&quot;&gt;&lt;/a&gt;在网易的三个月&lt;/h3&gt;&lt;p&gt;在网易的实习经历，在业务上是比较平淡的。做的有数这个平台的确是很复杂的，但我加入的时候这个平台已经比较成熟了，所以也没有太多挑战性的东西。没有见证初期的技术选型和架构的选择，所以在这方面没有学到太多想学到的。在大公司，技术选型这个是一个多方博弈的结果，要考虑公司本身的基础设施，并不是简单的引入开源项目就可以的。&lt;/p&gt;
&lt;p&gt;在网易主要是写了一个Regular-devtool，其他的话就写了一些简单的业务。生活的话，可以说还是非常幸福的。环境这些都挺不错的。现在想来还挺怀念呢。&lt;/p&gt;
&lt;h3 id=&quot;华师匣子&quot;&gt;&lt;a href=&quot;#华师匣子&quot; class=&quot;headerlink&quot; title=&quot;华师匣子&quot;&gt;&lt;/a&gt;华师匣子&lt;/h3&gt;&lt;p&gt;这个可以直接看之前写的&lt;a href=&quot;https://zxc0328.github.io/2016/12/19/ios-story/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;华师匣子开发记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一些新的探索&quot;&gt;&lt;a href=&quot;#一些新的探索&quot; class=&quot;headerlink&quot; title=&quot;一些新的探索&quot;&gt;&lt;/a&gt;一些新的探索&lt;/h3&gt;&lt;p&gt;函数式编程，以及相关的一些，还有编译原理。这两个Topic是我下半年的核心。这是我最近觉得最感兴趣的方向。对这些方向只进行了一些初步的探索。&lt;/p&gt;
&lt;p&gt;前端工具上，7月我写了Ninja，在团队的项目中用了半年。说实话这个是我最自豪的事情。&lt;/p&gt;
&lt;p&gt;12月开始写Build your own Vuejs，希望能顺利写完。&lt;/p&gt;
&lt;h3 id=&quot;未来打算&quot;&gt;&lt;a href=&quot;#未来打算&quot; class=&quot;headerlink&quot; title=&quot;未来打算&quot;&gt;&lt;/a&gt;未来打算&lt;/h3&gt;&lt;p&gt;我现在的一个理念，就是，你想学什么，那就自己写一个。光用是不行的。比如像了解前端MVVM框架，就自己实现一个。想学编译原理，可以自己实现一个简单的编译器。我认为这是很有趣的事情，也是很了不起的事情。&lt;/p&gt;
&lt;p&gt;未来打算在前端工具和框架这个方向上深入的研究。然后正式学习函数式编程。以及DSL相关的知识。保持好奇心。保持对生活的热爱！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从0到1：我和木犀的故事</title>
    <link href="http://yoursite.com/2016/12/19/muxi-story/"/>
    <id>http://yoursite.com/2016/12/19/muxi-story/</id>
    <published>2016-12-19T03:28:47.000Z</published>
    <updated>2016-12-23T07:12:39.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一个人的i华大技术中心&quot;&gt;&lt;a href=&quot;#一个人的i华大技术中心&quot; class=&quot;headerlink&quot; title=&quot;一个人的i华大技术中心&quot;&gt;&lt;/a&gt;一个人的i华大技术中心&lt;/h3&gt;&lt;p&gt;2014年开始，虽然我们还是习惯说自己是技术部的，但名义上已经是i华大技术中心了。底下分技术研发部和视觉设计部。&lt;/p&gt;
&lt;p&gt;说一个人，我指的是技术方面，设计那边还是很强大的。除了做主任的学姐和炳权学长，其他人并不会技术，然后之前的主任学姐三四月份就跑路了，炳权学长也很早就在名义上退出了。因此这个技术部就只有我一个人了。&lt;/p&gt;
&lt;p&gt;然后就是2014年四月份，技术中心春招。我依稀记得那个时候来了有大概三四十号人。然后我在306做培训，其实就是教他们切页面。&lt;/p&gt;
&lt;p&gt;那个时候也没想着要做一个技术团队，就想要把技术中心做好吧。当时我自己其实也是小白，也教不了他们什么。这三四十号人也并不是完全合适，因此最后待的比较久的，就只有龚红霞一个人。&lt;/p&gt;
&lt;p&gt;2014年的上半年还发生了一件事情，就是桂声10周年庆，请了很多高校的团队来交流，有武大和理工人的来了。当时我们的技术实力几乎为0，然而却在PPT上写了我们用Node，现在想起来还是觉得脸红。我听他们讲JSON，API这些，完全不懂。想来这应该就是我想打造一个技术团队的最初来源吧。&lt;/p&gt;
&lt;h3 id=&quot;木犀&quot;&gt;&lt;a href=&quot;#木犀&quot; class=&quot;headerlink&quot; title=&quot;木犀!&quot;&gt;&lt;/a&gt;木犀!&lt;/h3&gt;&lt;p&gt;木犀这个名字，想来应该就是14年下半年提出的。之所以叫木犀，是因为华师的桂花很出名，但直接叫桂花又太俗。我偶然得知木犀是桂花的学名，于是就选用了这个名字。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有个插曲，炳权曾经提议说我们可以叫handle，现在想起来还是觉得很搞笑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2014年的秋招，来了很多人，胡薇、韩伟、老王、王露晨、梁晓怡，这都是之后设计组的核心，想来之后那段时间也是设计组的黄金时代。小桂漫画，壁纸，表情，都是那段时间做的。&lt;/p&gt;
&lt;p&gt;还有一个人，那就是朱承浩。&lt;/p&gt;
&lt;p&gt;对我建设团队帮助最大的还是炳权，因为炳权那个时候已经在冰岩了（虽然我到15年上半年才知道），他会给我们很多建议，我也拓宽了很多视野。&lt;/p&gt;
&lt;p&gt;2014年下半年我们开始学Python，决定用Python做后端的语言。但那个时候还没有能力去完成一个网站的后台。那段时间我主要是用Drupal这个CMS来做学而的第一版。&lt;/p&gt;
&lt;p&gt;学而第一版其实反响还是很不错的，现在数据库里都还有那个时候的评论。这对我来说是一个鼓励，说明产品是有需求的。然后Drupal这个东西，开发难度很大，这坚定了我们自己学后台的决心。&lt;/p&gt;
&lt;p&gt;2015年的到来，是一切奇迹的开始。放弃Drupal和各种前端插件，真正的踏入Web开发的大门，就是从哪个时候开始的。所以说木犀的成长史，也是技术的成长史。&lt;/p&gt;
&lt;p&gt;首先我们在15年2月全面使用了Tower（这个时间点之前设计组好像就已经在用了）。大家看我和承浩的进度都是从15年2月开始的。至于Tower，对，没错，是炳权告诉我的，因为冰岩在用。&lt;/p&gt;
&lt;p&gt;之后就是承浩的时间了。他学了Flask，我们用Flask搭的第一个网站是什么，我已经忘了。我只记得那个时候，光部署网站，就要花好几天，因为书上讲的是AWS这种云服务的部署。手动的部署还是有一些门槛的。那个时候，因为了解的层次比较低，会觉得很多东西是玄学。&lt;/p&gt;
&lt;p&gt;3月我们去了联创交流，具体可以参见我的&lt;a href=&quot;http://zxc0328.github.io/2015/03/27/联创交流行/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;5月份和6月份其实还有一次转折。5月份的时候，理工的token团队办了十五周年庆，我们去参加了技术交流会。这次是我们第一次以木犀团队的名义出去交流。也是从2015年上半年开始，我们慢慢习惯以木犀团队的身份出现在所有人的眼中。这次交流会上，我们依然没有太多的干货，相比于其他团队，我们感受到了我们还太年轻。&lt;/p&gt;
&lt;p&gt;6月联创Hackday。我们主要是去感受了一下气氛。3月和6月两次去启明，对于我和承浩两个做技术的人来说，这个冲击不亚于工业文明对封建社会的冲击。首先是感受到了华科那边浓厚的技术气氛，其次是感到了一些压力，因为我们团队是如此的弱小，而华师的技术氛围又不想。当然是压力也是动力，不管如何，从2015上半年之后，我们团队在技术上便开始了不断的进步。&lt;/p&gt;
&lt;p&gt;联创Hackday&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150606_230735.jpg&quot; alt=&quot;hackday&quot;&gt;&lt;/p&gt;
&lt;p&gt;暑假承浩买了Mac，从此就一发不可收拾。那个暑假我在极验实习。其他人进行了我们第一次的夏令营（夏令营这个想法也是炳权提供的）。那个夏令营还是很愉快的，我们做出了第一版的内网，对于Flask的掌握已经好很多了。&lt;/p&gt;
&lt;p&gt;夏令营照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/0067HQaegw1ew2zdt5kfvj318g0xc7kh.jpg&quot; alt=&quot;xialy&quot;&gt;&lt;/p&gt;
&lt;p&gt;夏令营最后去落雁岛玩的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/64c45edcjw1fb0mmjzukkj21ci0ya4qp.jpg&quot; alt=&quot;lyd&quot;&gt;&lt;/p&gt;
&lt;p&gt;2015年9月，团队已经初具规模了。后面的事情，15级的同学应该都清楚了。&lt;/p&gt;
&lt;p&gt;接下来的事情就是2015年下半年开发的学而的第二版，完全用Flask写，有同步的路由和REST API组成，前端移动版是一个SPA，用了Webpack和React。这就是我们第一个工程化的产品。&lt;/p&gt;
&lt;p&gt;技术团队的成长，其实就是我的成长，承浩的成长，已经后面14级其他同学和15级同学的成长，每次有一个人成长为核心成员，团队就变的更加的强大。&lt;/p&gt;
&lt;h3 id=&quot;番外：304-306-502&quot;&gt;&lt;a href=&quot;#番外：304-306-502&quot; class=&quot;headerlink&quot; title=&quot;番外：304-306-502&quot;&gt;&lt;/a&gt;番外：304-306-502&lt;/h3&gt;&lt;p&gt;一开始，i华大技术中心的办公地点是在304。那时候我们还是非常自由的，304可以随意的改造。经历过那段时刻的同学应该知道，那段时间是很有归属感的一段时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/0067HQaegw1ew2zdsct9bj30hs0hsgpb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150402_202558.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;直到今年5月份，304和306装修。我仓皇中去合租了一间房子，在教工宿舍，作为我们的临时工作室：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/IMG20160622155941.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那段时光是难忘的，也是别扭的，痛苦的。那只狗，上门的邻居，狭小的空间，和我自己当时的各种压力混合在一起。&lt;/p&gt;
&lt;p&gt;现在我们主要在306活动，也在304。虽然归属感没有以前这么强了，但因为大家更熟悉了，核心成员也更多了，所以团队的气氛要更好一些。&lt;/p&gt;
&lt;p&gt;我还是希望我们能有一间独立的工作室。我们要时刻保持危机感，来应对未来的无限的可能。&lt;/p&gt;
&lt;h3 id=&quot;前端之路&quot;&gt;&lt;a href=&quot;#前端之路&quot; class=&quot;headerlink&quot; title=&quot;前端之路&quot;&gt;&lt;/a&gt;前端之路&lt;/h3&gt;&lt;p&gt;我个人的前端之路，其实也是木犀从0到1的一个很好的注脚。&lt;/p&gt;
&lt;p&gt;我其实在15年的上半年才开始正式学计算机。那个学期在武大开始辅修，然后在团队开始学Flask和Python。5月的时候，我的前端水平是只会写简单的Banner，相比之前Banner都要用插件的水平来说，算是好一些。那个时候是标准的过程式的编程。&lt;/p&gt;
&lt;p&gt;5月的时候看了一本单页应用开发的书，里面讲到了IIFE，闭包等等。我如获至宝，写个什么组件（其实我当时并没有组件的意识）就用IIFE，其实这算是最初的模块化，工程化意识吧。只不过我那个时候并不清楚模块化和工程化，也不知道正常的编程语言都是自带模块的。&lt;/p&gt;
&lt;p&gt;7月和8月我主要在极验实习，切了不少的页面，里面有一些用jQuery做的组件。这个时候我写展示型的页面以及比较熟练了，CSS也掌握的不错（毕竟在写桂声那些主要就是CSS）。但对于前端的那些Grunt什么的工具，其实我并不是很清楚为什么要用。&lt;/p&gt;
&lt;p&gt;所以对于模块的理解，对我来说是一道坎。真正理解模块和工程，还有闭包，大概是今年的事情了。&lt;/p&gt;
&lt;p&gt;9月回学校之后我看了React，后来就开始用Backbone写学而。那个时候我对MVC了解的还是比较多的，因为之前后端用的就是MVC。写React的时候比较初步的理解了组件化。之后对于Webpack之类的工具也用的很顺手了。&lt;/p&gt;
&lt;p&gt;这个学期对面向对象也略有了解。但对于View和Model的分层，以及组件的抽象，还没有到能手写的地步。那个时候我看Backbone源码，并没有太多感觉。而现在我回头看，就觉得抽象非常的清晰了。&lt;/p&gt;
&lt;p&gt;那个时候我对很多事情的理解都比较的浅薄。对于React Native很崇拜，觉得Web的目标就是取代原生应用。觉得Web就是要做单页应用。也没有很深入的理解前端工具为什么存在，以及组件化的发展史。&lt;/p&gt;
&lt;p&gt;现在来看，其实Web有Web的特点，需要动态化、快速上线、展示型的东西都可以用Web来做，这只是一个简单的技术选型的问题。&lt;/p&gt;
&lt;p&gt;总得来说，这是一个&lt;strong&gt;技术视野&lt;/strong&gt;的问题。如果你用过很多别的语言，那你就应该很容易的理解模块的存在。如果你开发过原生应用，那你就应该很好的理解为什么Web开发的UI应该是组件化的。&lt;/p&gt;
&lt;p&gt;今年开始，我把兴趣移到了函数式，编程语言，还有计算机基础上面。对于前端，我主要在开发工具解决我们自己的工作流中的问题，还有就是研究框架和工具的源码，进一步深入。&lt;/p&gt;
&lt;p&gt;现在回过头来看，我就能发现前端学习的一个最佳的路径，DOM可以不用花很多心思，但组件一定要自己去手动实现。模块可以直接用标准的模块。前端无非是普通的客户端软件开发，从这个视角去看的话，事情就清楚多了。&lt;/p&gt;
&lt;p&gt;计算机基础加上足量的工程经验，应该就可以成就一个好的工程师了。我的前端之路还算顺利，大家的学习道路，在我们这些先行者的踩坑之后，肯定会更加顺利。但有一点是肯定的，要把一样事情学好，需要你的热情，时间，和精力。&lt;/p&gt;
&lt;p&gt;还有一点，就是你的视野是随着你的经验而增长的，视野对你理解一些技术是非常有帮助的。平时我们在安排学习路线时也会特意的去安排背景阅读材料，或者是讲一些思想和Lab结合起来，努力让大家能够尽快的熟悉那些方法论层面的东西。同时，你自己的思考也是离不开的。我经常会思考，踱步。好的书常看常新，经典的思想，也是需要反复的思忖才能领悟的。&lt;/p&gt;
&lt;h3 id=&quot;我们在路上，前方不会太远&quot;&gt;&lt;a href=&quot;#我们在路上，前方不会太远&quot; class=&quot;headerlink&quot; title=&quot;我们在路上，前方不会太远&quot;&gt;&lt;/a&gt;我们在路上，前方不会太远&lt;/h3&gt;&lt;p&gt;2016年，团队最大的新闻当然就是华师匣子的上线。这个是我们的第一款移动应用，也是将来一切产品的推广基础。&lt;/p&gt;
&lt;p&gt;在我看来，团队最大的成长，一个是技术团队在工程化上慢慢摸索，有了自己的方向。我们的方向就是&lt;strong&gt;通过造轮子来深入原理，积极的实践最新的技术，写完善的文档，在社区中争取拥有一定的影响力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在团队的管理上，确立了早读制度，试行了导师制度，管理工作组共同管理团队，成功的进行了秋游，招新算是顺利，团队管理层平滑更换。这些都是一个团队平稳运行的基石。如果说这个大框架搭好了，我们就可以把精力投入到具体的产品和新人培养中去了。&lt;/p&gt;
&lt;p&gt;在接下里的日子里，我们要把产品的汇报制度完善，项目组的气氛要更好，全员大会要常态化，组内技术积累要抓紧，新人双轨培养的计算机基础方向需要花很大的力气建设，UED部门要重新上路。&lt;/p&gt;
&lt;p&gt;对于团队的期望，我不想说太多，我只能说，作为一个木犀人，你就算毕业了，也依然要参与到团队的建设中去，只是不在第一线了而已。只有这样才能慢慢的把事情做好。我们追求的是理想中的团队，可能我们永远都无法到达那个理想中的境界，但一直在成长，一直在进步的话，大家开开心心的，就挺好。&lt;/p&gt;
&lt;p&gt;我们在路上，前方不会太远。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>华师匣子iOS版开发记</title>
    <link href="http://yoursite.com/2016/12/19/ios-story/"/>
    <id>http://yoursite.com/2016/12/19/ios-story/</id>
    <published>2016-12-19T03:28:35.000Z</published>
    <updated>2016-12-21T12:44:19.000Z</updated>
    
    <content type="html">&lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是匣子iOS的Github提交图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-12-21%20at%208.39.43%20PM.png&quot; alt=&quot;iOS Github&quot;&gt;&lt;/p&gt;
&lt;p&gt;上个学期我接下iOS版开发的任务时，其实我心里是没底的。没学过iOS是一方面，关键是我也没有任何客户端开发的经验。当时我对客户端开发的了解几乎为0。之前有接触过一点安卓。但iOS这边玄学的StoryBoard和新语言Swift都让我比较没底。&lt;/p&gt;
&lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h3&gt;&lt;p&gt;我首先看了斯坦福的&lt;a href=&quot;http://web.stanford.edu/class/cs193p/cgi-bin/drupal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS开发课程&lt;/a&gt;。这个课程是一个非常不错的课程。里面实现一个计算器，代码的结构非常的合理，也充分发挥了Swift的特性。当时我的感觉就是，写APP或者其他业务并不是会调API就好，如果想要写漂亮的代码，那还是需要扎实的计算机基础。&lt;/p&gt;
&lt;p&gt;我看着课程，但我并没有跟着写，因为时间不多了。我在了解了基本的MVC架构、StoryBoard中拖控件、拖Outlet和Action、Auto Layout之后，就开始写匣子的几个界面。&lt;/p&gt;
&lt;p&gt;当时写了界面之后，就有所感触了。首先Auto Layout的确是一个非常好的布局方式，让我不再怀念CSS。然后，原生APP中首先所有的组件都是有与之对应的对象实例的，这是顺理成章的事情。但在Web这边，组件需要自己抽象，而且在Web Component没有普及之前，没有原生级别的支持。写iOS的过程中我越发明白，DOM其实只是Web界面UI的实现细节。我们要用某种方式去封装DOM，在UI抽象层编写代码。iOS就完全符合这种方式。想来客户端软件理应是这样的。只不过Web技术从一开始并不是为客户端软件打造的，因此这几年前端走的路，基本就是补上之前落下的课。&lt;/p&gt;
&lt;p&gt;当然Web前端数据驱动，双向绑定这些，在我看来已经是最前沿的东西了。iOS这边肯定也有。但因为我对前端更了解一些，所以觉得前端要更优雅一些。&lt;/p&gt;
&lt;p&gt;最开始做图书馆，于是就遇到了输入框键盘如何收起的问题。点击return，点击屏幕的其他地方都会收起键盘。这里要提到一点，就是这次0基础做iOS，是我第一次在全英文的环境下从头开始学一门技术。这次我全程一行中文都没有看。回头想想，很难想象如何在中文社区解决这些问题。&lt;/p&gt;
&lt;h3 id=&quot;深入&quot;&gt;&lt;a href=&quot;#深入&quot; class=&quot;headerlink&quot; title=&quot;深入&quot;&gt;&lt;/a&gt;深入&lt;/h3&gt;&lt;p&gt;接下来就是各个技术点的学习了。数据持久化要用Core Data，其实就是一个本地的SQLite数据库。这个我基本是当Key Value存储来用了。对数据库还是不是很了解。然后有触摸事件的处理等等。网络请求用Alamofire和SwiftyJSON。学用iOS的Cocoapad装依赖。&lt;/p&gt;
&lt;p&gt;学习的过程中，说起来只有一个比较理论的知识，就是delegate、protocol、extension这些。&lt;/p&gt;
&lt;p&gt;之前在看斯坦福课程的时候还不是很了解。后来用UITableView以及需要不同VC直接通信的时候，就慢慢了解了delegate。我对delegate的了解就是一种委托的模式。任意一个实现了对应接口的对象都可以作为委托的对象。后来在安卓那边了解了一下，大致有同样的实现。&lt;/p&gt;
&lt;p&gt;UITableView实在是一种很经典的接口设计。除了那几个delegate方法之外，UITableView会对Table Cell进行回收的做法，也让我明白了之前面试时问我的长列表优化问题的答案。在Web端我们也可以控制列表只保留可视区域的DOM元素，来做优化。这样不管列表有多少元素，都可以顺利的渲染。&lt;/p&gt;
&lt;h3 id=&quot;课程表&quot;&gt;&lt;a href=&quot;#课程表&quot; class=&quot;headerlink&quot; title=&quot;课程表&quot;&gt;&lt;/a&gt;课程表&lt;/h3&gt;&lt;p&gt;课程表一度是我迟迟不愿意动手的一个模块。其实匣子里大部分模块的逻辑都是简单的查询和拉取数据。课程表也不例外，但课程表的View相对来说比较复杂。我咨询了安卓的同学之后才知道要自己画View，自己handle触摸事件。于是就写了一个双向的滑动，在触摸事件中修改View的偏移。&lt;/p&gt;
&lt;p&gt;画课表的格子也花了我一段时间，最后算是解决了。后期还要再完善。课程表的实现让我得以一窥iOS开发的常态———自定义View。实际上大部分的控件应该还是需要自己来写的，毕竟大家的APP看上去都很Unique。&lt;/p&gt;
&lt;p&gt;iOS的View可以自定义drawRect方法。这应该就是暴露了底层的2D绘图API，类似于Web中的Canvas。&lt;/p&gt;
&lt;h3 id=&quot;收尾&quot;&gt;&lt;a href=&quot;#收尾&quot; class=&quot;headerlink&quot; title=&quot;收尾&quot;&gt;&lt;/a&gt;收尾&lt;/h3&gt;&lt;p&gt;其他大大小小的问题还有很多，比如我一度纠结于如何取消Navigation bar上面返回按钮的文字，结果发现在Story Board里面的Back Button打一个空格就行了。踩了很多坑，有一个很大的坑就是我一度用中文做了包名，导致后来数据迁移一直报错。&lt;/p&gt;
&lt;p&gt;Banner的话，最后是用原生的UIPageView实现的。之前一度以为要自己实现一个。想来自己的水平还是不够的。&lt;/p&gt;
&lt;p&gt;后期陆续完成了数据迁移，远程推送，本地推送，闪屏处理，还有和后端元信息API的整合。&lt;/p&gt;
&lt;p&gt;上线的时候，担心我们的服务器不支持IPv6，担心不会过审。不过最后很顺利的过审核了。苹果的工作效率没有想象中的那么低。&lt;/p&gt;
&lt;p&gt;苹果要求HTTPS和IPv6，Safari10支持全部ES6属性。这意味着苹果一直走在时代的最前沿。在这一点上我要给苹果点赞。&lt;/p&gt;
&lt;p&gt;这次iOS的开发算是让我获得了iOS的初级开发经验，点亮了客户端开发的技能点。为后续我的Hybrid研究开了一个好头。&lt;/p&gt;
&lt;h3 id=&quot;关于Swift&quot;&gt;&lt;a href=&quot;#关于Swift&quot; class=&quot;headerlink&quot; title=&quot;关于Swift&quot;&gt;&lt;/a&gt;关于Swift&lt;/h3&gt;&lt;p&gt;Swift给我的印象还是很不错的。静态类型，经典的面向对象，外加和JS类似的函数式特性，我用起来觉得很顺手。OC看起来太恐怖了，如果不是有Swift，想来我也不会鼓起勇气去写iOS。Swift未来还会进军服务端，虽然是Apple自家的东西，但开源了，想来发展应该会是不错的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Build your own Vuejs Chapter1 Vue Overview</title>
    <link href="http://yoursite.com/2016/12/12/build-your-own-vuejs-1/"/>
    <id>http://yoursite.com/2016/12/12/build-your-own-vuejs-1/</id>
    <published>2016-12-12T09:11:50.000Z</published>
    <updated>2016-12-12T09:17:47.000Z</updated>
    
    <content type="html">&lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Chapter1-Vuejs-Overview&quot;&gt;&lt;a href=&quot;#Chapter1-Vuejs-Overview&quot; class=&quot;headerlink&quot; title=&quot;Chapter1: Vuejs Overview&quot;&gt;&lt;/a&gt;Chapter1: Vuejs Overview&lt;/h2&gt;&lt;p&gt;Vuejs is a simple yet powerful MVVM library. It helps us to build a modern user interface for the web.&lt;/p&gt;
&lt;p&gt;By the time of writing, Vuejs has 36,312 stars on Github. And 230,250 monthly downloads on npm. Vuejs 2.0 brings in a lightweight virtual DOM implementation for render layer. This unlock more possibilities like server-side rendering and native component rendering.&lt;/p&gt;
&lt;p&gt;Vuejs claims to be a progressive JavaScript framework. Though the core library of Vuejs is quite small. Vuejs has many accompanying tools &amp;amp; supporting libraries. So you can build large-scale application using the Vuejs ecosystem.&lt;/p&gt;
&lt;h3 id=&quot;Components-of-Vuejs-internals&quot;&gt;&lt;a href=&quot;#Components-of-Vuejs-internals&quot; class=&quot;headerlink&quot; title=&quot;Components of Vuejs internals&quot;&gt;&lt;/a&gt;Components of Vuejs internals&lt;/h3&gt;&lt;p&gt;Let’s get acquaintance with the core components of Vuejs internals. Vue internals falls into serval parts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Vue%20source%20overview.png&quot; alt=&quot;Vue internal&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Instance-lifecycle&quot;&gt;&lt;a href=&quot;#Instance-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;Instance lifecycle&quot;&gt;&lt;/a&gt;Instance lifecycle&lt;/h4&gt;&lt;p&gt;A new Vue instance will go through several phases. Such as observing data, initializing events, compiling the template, and render. And you can register  lifecycle hooks that will be called in the specific phase.&lt;/p&gt;
&lt;h4 id=&quot;Reactivity-system&quot;&gt;&lt;a href=&quot;#Reactivity-system&quot; class=&quot;headerlink&quot; title=&quot;Reactivity system&quot;&gt;&lt;/a&gt;Reactivity system&lt;/h4&gt;&lt;p&gt;The so called &lt;em&gt;reactivity system&lt;/em&gt; is where vue’s data-view binding magic comes from. When you set vue instance’s data, the view updated accordingly, and vice versa. &lt;/p&gt;
&lt;p&gt;Vue use &lt;code&gt;Object.defineProperty&lt;/code&gt; to make data object’s property reactive. Along with the famous &lt;em&gt;Observer Pattern&lt;/em&gt; to link data change and view render together.&lt;/p&gt;
&lt;h4 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h4&gt;&lt;p&gt;Virtual DOM is the tree representation of the actual DOM tree that lives in the memory as JavaScript Objects. &lt;/p&gt;
&lt;p&gt;When data changes, vue will render a brand new virtual DOM tree, and keep the old one. The virtual DOM module diff two trees and patch the change into the actual DOM tree.&lt;/p&gt;
&lt;p&gt;Vue use &lt;a href=&quot;https://github.com/snabbdom/snabbdom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;snabbdom&lt;/a&gt; as the base of its virtual DOM implementation. And modify a bit to make it work with Vue’s other component.&lt;/p&gt;
&lt;h4 id=&quot;Compiler&quot;&gt;&lt;a href=&quot;#Compiler&quot; class=&quot;headerlink&quot; title=&quot;Compiler&quot;&gt;&lt;/a&gt;Compiler&lt;/h4&gt;&lt;p&gt;The job of the compiler is to compile template into render functions(ASTs). It parses HTML along with Vue directives (Vue directives are just plain HTML attribute) and other entities into a tree. It also detects the maximum static sub trees (sub trees with no dynamic bindings) and hoists them out of the render. The HTML parser Vue uses is originally written by &lt;a href=&quot;http://ejohn.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John Resig&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We will not cover the implementation detail of the Compiler in this book. Since we can use build tools to compile vue template into render functions in build time, Compiler is not a part of vue runtime. And we can even write render functions directly, so Compiler is not an essential part to understand vue internals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Set-up-development-environment&quot;&gt;&lt;a href=&quot;#Set-up-development-environment&quot; class=&quot;headerlink&quot; title=&quot;Set up development environment&quot;&gt;&lt;/a&gt;Set up development environment&lt;/h3&gt;&lt;p&gt;Before we can start building our own Vue.js, we need to set up a few things. Including module bundler and testing tools, since we will use a test-driven workflow.&lt;/p&gt;
&lt;p&gt;Since this is a JavaScript project, and we’gonna use some fancy tools, the first thing to do is run &lt;code&gt;npm init&lt;/code&gt; and set up some information about this project. &lt;/p&gt;
&lt;h4 id=&quot;Set-up-Rollup-for-module-bundling&quot;&gt;&lt;a href=&quot;#Set-up-Rollup-for-module-bundling&quot; class=&quot;headerlink&quot; title=&quot;Set up Rollup for module bundling&quot;&gt;&lt;/a&gt;Set up Rollup for module bundling&lt;/h4&gt;&lt;p&gt;We will use Rollup for module bundling. &lt;a href=&quot;http://rollupjs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rollup&lt;/a&gt; is a JavaScript module bundler. It allows you to write your application or library as a set of modules – using modern ES2015 import/export syntax. And Vuejs use Rollup for module bundling too.&lt;/p&gt;
&lt;p&gt;We gotta write a configuration for Rollup to make it work. Under root directory, touch &lt;code&gt;rollup.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  entry: &amp;#39;src/instance/index.js&amp;#39;,
  format: &amp;#39;umd&amp;#39;,
  moduleName: &amp;#39;Vue&amp;#39;,
  dest: &amp;#39;dist/vue.js&amp;#39; 
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And don’t forget to run &lt;code&gt;npm install rollup rollup-watch --save-dev&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;Set-up-Karma-and-Jasmine-for-testing&quot;&gt;&lt;a href=&quot;#Set-up-Karma-and-Jasmine-for-testing&quot; class=&quot;headerlink&quot; title=&quot;Set up Karma and Jasmine for testing&quot;&gt;&lt;/a&gt;Set up Karma and Jasmine for testing&lt;/h4&gt;&lt;p&gt;Testing will require quite a few packages, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install karma jasmine karma-jasmine karma-chrome-launcher
 karma-rollup-plugin --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Under root directory, touch &lt;code&gt;karma.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(config) {
  config.set({
    frameworks: [&amp;#39;jasmine&amp;#39;],
    files: [
      &amp;#39;./test/**/*.js&amp;#39;
    ],
    browsers: [&amp;#39;Chrome&amp;#39;],
    preprocessors: {
     &amp;#39;./test/**/*.js&amp;#39;: [&amp;#39;rollup&amp;#39;]
    },
    rollupPreprocessor: {
      format: &amp;#39;iife&amp;#39;,
      sourceMap: &amp;#39;inline&amp;#39;
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Directory-structure&quot;&gt;&lt;a href=&quot;#Directory-structure&quot; class=&quot;headerlink&quot; title=&quot;Directory structure&quot;&gt;&lt;/a&gt;Directory structure&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- package.json
- rollup.conf.js
- node_modules
- dist
- test
- src
    - observer
    - instance
    - util
    - vdom
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Bootstrapping&quot;&gt;&lt;a href=&quot;#Bootstrapping&quot; class=&quot;headerlink&quot; title=&quot;Bootstrapping&quot;&gt;&lt;/a&gt;Bootstrapping&lt;/h3&gt;&lt;p&gt;We’ll add some npm script for convenience. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;package.json&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
   &amp;quot;build&amp;quot;: &amp;quot;rollup -c&amp;quot;,
   &amp;quot;watch&amp;quot;: &amp;quot;rollup -c -w&amp;quot;,
   &amp;quot;test&amp;quot;: &amp;quot;karma start&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To bootstrap our own Vuejs, let’s write our first test case.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;test/options/options.spec.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &amp;quot;../src/instance/index&amp;quot;;

describe(&amp;#39;Proxy test&amp;#39;, function() {
  it(&amp;#39;should proxy vm._data.a = vm.a&amp;#39;, function() {
      var vm = new Vue({
          data:{
              a:2
          }
      })
    expect(vm.a).toEqual(2);
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This test case tests whether props on vm’s data like &lt;code&gt;vm._data.a&lt;/code&gt; are proxied to vm itself, like &lt;code&gt;vm.a&lt;/code&gt;. This is one of Vue’s little tricks.&lt;/p&gt;
&lt;p&gt;So we can write our first line of real code now, in &lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/index.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initMixin } from &amp;#39;./init&amp;#39;

function Vue (options) {
  this._init(options)
}

initMixin(Vue)

export default Vue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is nothing exciting, just Vue constructor calling &lt;code&gt;this._init&lt;/code&gt;. So let’s find out how the &lt;code&gt;initMixin&lt;/code&gt; fucntion work:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/init.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initState } from &amp;#39;./state&amp;#39;

export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
      var vm = this
      vm.$options = options
      initState(vm)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The instance method of Vue Class are injected using a mixin pattern. We’ll find this mixin pattern quite common when writing Vuejs’s instance method later. Mixin is just a function that takes a constructor, add some methods to its prototype, and return the constructor.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;initMixin&lt;/code&gt; add &lt;code&gt;_init&lt;/code&gt; method to &lt;code&gt;Vue.prototype&lt;/code&gt;. And this method calls &lt;code&gt;initState&lt;/code&gt; from &lt;code&gt;state.js&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/state.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
export function initState(vm) {
  initData(vm)
}

function initData(vm) {
  var data = vm.$options.data
  vm._data = data
  // proxy data on instance
  var keys = Object.keys(data)

  var i = keys.length
  while (i--) {
    proxy(vm, keys[i])
  }
}

function proxy(vm, key) {
    Object.defineProperty(vm, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter() {
        return vm._data[key]
      },
      set: function proxySetter(val) {
        vm._data[key] = val
      }
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we got to the place where proxy takes place. &lt;code&gt;initState&lt;/code&gt; calls &lt;code&gt;initData&lt;/code&gt;, and &lt;code&gt;initData&lt;/code&gt; iterates all keys of &lt;code&gt;vm._data&lt;/code&gt;, calls &lt;code&gt;proxy&lt;/code&gt; on each value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt; define a property on &lt;code&gt;vm&lt;/code&gt; using the same key, and this property has both getter and setter, which actually get/set data from &lt;code&gt;vm._data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So that’s how &lt;code&gt;vm.a&lt;/code&gt; is proxied to &lt;code&gt;vm._data.a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;npm run build&lt;/code&gt; and &lt;code&gt;npm run test&lt;/code&gt;. You should see something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn4.snapgram.co/images/2016/12/11/ScreenShot2016-12-12at2.02.17AM.png&quot; alt=&quot;success&quot;&gt;&lt;/p&gt;
&lt;p&gt;Bravo! You successfully bootstrapped your own Vuejs! Keep working!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊Chrome Devtools的Timeline</title>
    <link href="http://yoursite.com/2016/11/29/timeline/"/>
    <id>http://yoursite.com/2016/11/29/timeline/</id>
    <published>2016-11-29T12:15:49.000Z</published>
    <updated>2016-11-30T08:46:41.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Timeline的使用场景&quot;&gt;&lt;a href=&quot;#Timeline的使用场景&quot; class=&quot;headerlink&quot; title=&quot;Timeline的使用场景&quot;&gt;&lt;/a&gt;Timeline的使用场景&lt;/h3&gt;&lt;p&gt;Timeline的使用场景一个是在页面发生明显的卡顿时，比如CSS动画或者页面滚动时，用来分析卡顿的原因。还有一个场景便是进行页面渲染性能的评估，看页面渲染性能是否有优化的空间，或者通过截图观察页面渲染的过程，优化&lt;a href=&quot;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Speed Index&lt;/a&gt;来提升用户体验。&lt;/p&gt;
&lt;h3 id=&quot;关于渲染&quot;&gt;&lt;a href=&quot;#关于渲染&quot; class=&quot;headerlink&quot; title=&quot;关于渲染&quot;&gt;&lt;/a&gt;关于渲染&lt;/h3&gt;&lt;p&gt;我们知道，如果以每秒16-24帧的速度连续播放图片，那人就会产生动画的幻觉。在UI动画中，因为目前主流显示设备的刷新率达到了60Hz，我们追求的的帧率是60fps。那理想情况下，每一帧的时间应该是&lt;code&gt;1/60=16.67ms&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;又因为JavaScript是单线程事件驱动的模型。所以浏览器在一帧之内要完成JavaScript脚本的运行，然后计算，合成这帧画面，并渲染。&lt;/p&gt;
&lt;h3 id=&quot;Long-Frame&quot;&gt;&lt;a href=&quot;#Long-Frame&quot; class=&quot;headerlink&quot; title=&quot;Long Frame&quot;&gt;&lt;/a&gt;Long Frame&lt;/h3&gt;&lt;p&gt;所谓的Long Frame，也就是我们在Timeline的FPS中被标注为红色（如下图）的那些帧，便是用时超过正常标准的那些帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/longframe.png&quot; alt=&quot;longframe&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;long frame&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Long Frame往往意味着卡顿，因为帧率低于60fps，甚至30fps。我们会通过查看这帧中的JS运行情况，浏览器渲染情况，以及浏览器用户触发事件的情况来分析卡顿的原因。&lt;/p&gt;
&lt;h3 id=&quot;Timeline中有价值的数据&quot;&gt;&lt;a href=&quot;#Timeline中有价值的数据&quot; class=&quot;headerlink&quot; title=&quot;Timeline中有价值的数据&quot;&gt;&lt;/a&gt;Timeline中有价值的数据&lt;/h3&gt;&lt;h4 id=&quot;JS调用栈&quot;&gt;&lt;a href=&quot;#JS调用栈&quot; class=&quot;headerlink&quot; title=&quot;JS调用栈&quot;&gt;&lt;/a&gt;JS调用栈&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/jsstack.png&quot; alt=&quot;jscallstack&quot;&gt;&lt;br&gt;&lt;em&gt;JS Call Stack&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果是JS运行时间过长，比如超过10ms，那我们就有必要检查这个JS的调用栈，可以通过查看Details一栏中的Bottom-up选项卡来看到自顶向下的调用信息。分析那个函数调用占用了过多的时间，并加以解决。&lt;/p&gt;
&lt;h4 id=&quot;浏览器渲染信息&quot;&gt;&lt;a href=&quot;#浏览器渲染信息&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染信息&quot;&gt;&lt;/a&gt;浏览器渲染信息&lt;/h4&gt;&lt;p&gt;浏览器渲染每一帧画面，需要经过这些阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/frame-full.jpg&quot; alt=&quot;render&quot;&gt;&lt;br&gt;&lt;em&gt;render pipeline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中我们需要避免的主要就是Layout，如果触发了Layout的重新计算，那就意味着你的页面需要重绘，这是一个非常expensive的任务。如果我们在CSS动画时使用了GPU加速，那这些动画就不会造成重绘，而是作为一个单独的层在Compose阶段进行组合。&lt;/p&gt;
&lt;p&gt;如果是浏览器渲染用时过多，我们就需要检查代码中是否触发了不必要的浏览器重绘。这方面的优化主要是针对CSS的优化，是一个专门的专题。一般的措施是采用CSS3 transform进行动画，开启硬件加速来避免浏览器重绘。&lt;/p&gt;
&lt;h4 id=&quot;事件输入&quot;&gt;&lt;a href=&quot;#事件输入&quot; class=&quot;headerlink&quot; title=&quot;事件输入&quot;&gt;&lt;/a&gt;事件输入&lt;/h4&gt;&lt;p&gt;我们可以在Flame Chart的Interaction部分看到浏览器在这段时间触发的事件。&lt;/p&gt;
&lt;p&gt;用户注册的事件，都有对应的回调函数。因此如果这个回调函数包含大量的逻辑，并且这个事件触发非常频繁的话，比如scroll或者touchmove，那我们就需要对事件触发的频率进行限制。在防止回调函数频繁触发层面，对应的办法有JS层面的节流函数。在限制事件注册的数量层面，我们可以使用事件代理，尽量避免在一个DOM元素上注册多个触发频繁的事件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题外话：在调试移动端页面时，我发现Chrome在Timeline里标出了pinch这样的事件。说明浏览器的渲染层是支持这样的高级事件的。但在DOM的标准中没有找到这样的事件。需要大家用touch事件来合成。Chrome的这个做法不知道应该理解成浏览器面向未来的支持，还是浏览器私有的实现。当然，在移动端的操作系统层面，识别pinch应该不是一个难事。DOM的touch event中没有支持pinch，swipe等事件，这个问题值得思考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;其他数据&quot;&gt;&lt;a href=&quot;#其他数据&quot; class=&quot;headerlink&quot; title=&quot;其他数据&quot;&gt;&lt;/a&gt;其他数据&lt;/h4&gt;&lt;p&gt;Timeline中还有很多有价值的数据，比如CPU占有率，JS的Heap大小（可以简单的理解成JS的内存占用情况），DOM节点的数量，事件监听器的数量等等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unix·Talk 聊聊工程</title>
    <link href="http://yoursite.com/2016/11/19/unix-talk-engineering/"/>
    <id>http://yoursite.com/2016/11/19/unix-talk-engineering/</id>
    <published>2016-11-19T02:43:14.000Z</published>
    <updated>2016-11-29T14:50:59.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;工程是什么&quot;&gt;&lt;a href=&quot;#工程是什么&quot; class=&quot;headerlink&quot; title=&quot;工程是什么&quot;&gt;&lt;/a&gt;工程是什么&lt;/h3&gt;&lt;p&gt;首先请大家观察这两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-11-27%20at%207.00.59%20PM.png&quot; alt=&quot;vs&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果说左边的小草房是课程作业的话，那右边的高楼大厦，就是我们所说的工程。&lt;/p&gt;
&lt;p&gt;大家可以思考一下，建造两者的过程有何不同。建左边的小房子也许不需要太多的材料，也不需要对材料进行深度的加工。在设计上，只要有基本的构想即可，不需要精准的蓝图。在施工上也相对随性一些。&lt;/p&gt;
&lt;p&gt;而右边的高楼大厦，需要钢筋混凝土这种深度加工的材料去构建，需要严密的蓝图和施工周期。同时也需要数百倍于左图的人力去建造。&lt;/p&gt;
&lt;p&gt;从产出的规模和流程的复杂度来说，软件工程师和建筑工程师或者电气工程师一样，都在一套成熟的流程和体系下，打造大规模的产品。&lt;/p&gt;
&lt;p&gt;所以，在互联网行业，工程就是一套完整的产品研发方法论。同时也包括项目开发周期中的项目管理，前期估算，后期测试等流程。&lt;/p&gt;
&lt;p&gt;那为什么我们需要这套方法论呢？很简单。如果没有这套方法论指导，我们就无法顺利的开发出大型的软件，或者，我们的开发效率会很低。我们需要用工具来加速我们的开发，自动化一些无聊的工作。我们需要用设计模式来解耦我们的代码，让代码的可维护性更高。我们也需要项目管理，来让不同分工的工程师协同工作，顺利完工。&lt;/p&gt;
&lt;p&gt;而这套方法论，学校里是很少有讲到的。这也是因为，工程相关的方法论需要工程师在项目开发的过程中不断的实践总结，毕竟纸上得来终觉浅，而工程这种和实际问题特别相关的方向，则更需要在实际的项目才能有更深入的理解。&lt;/p&gt;
&lt;h3 id=&quot;工程的几个关键词&quot;&gt;&lt;a href=&quot;#工程的几个关键词&quot; class=&quot;headerlink&quot; title=&quot;工程的几个关键词&quot;&gt;&lt;/a&gt;工程的几个关键词&lt;/h3&gt;&lt;h4 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h4&gt;&lt;p&gt;俗话说，没有金刚钻，就不揽瓷器活。无论是客户端还是服务端，大家都有专属的神兵利器。&lt;/p&gt;
&lt;p&gt;其中大家使用频率最高的便是编辑器或者IDE。前端有Sublime，安卓有Android Studio，iOS有Xcode，后端有Vim。强大的IDE往往&lt;br&gt;包含了从代码提示到编译打包的一条路服务。而Sublime这样的轻量级编辑器，需要我们进行各种DIY，打造成自己想要的样子。好用的编辑器往往会提高开发的效率，带来生产力的提高。&lt;/p&gt;
&lt;p&gt;在客户端开发中，打包构建工具也是一个重要的类别。好用的打包工具不仅仅可以降低打包的时间，在前端等领域，好用的打包工具甚至代表了一种工具生态，串联起了一个完整的工具链。&lt;/p&gt;
&lt;p&gt;开发中用到的工具还有很多。很多小工具的诞生，往往是为了解决某一个具体问题的。程序员往往希望一切机械的事务都可以自动化。并且也喜欢将繁杂的数据可视化。这两个动机驱动了很多小工具的诞生。&lt;/p&gt;
&lt;p&gt;趁手的工具代表了先进的生产力。这也是构建大型工程时必须借助的垫脚石。工程化程度高的技术团队，往往都有着自己的先进工具。&lt;/p&gt;
&lt;h4 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h4&gt;&lt;p&gt;编码规范包括代码风格，目录结构等等。这些编码规范的存在，一方面是约束团队成员的代码质量，使得一些低级错误和语言中的bad practice得到提醒和控制。一方面，代码规范中的一些代码风格相关的部分，是为了让团队成员的代码风格统一，这样有利于后期代码库的维护和迭代。&lt;/p&gt;
&lt;p&gt;我们可以使用一些Lint工具和持续集成等技术来将编码规范落地。一个团队的编码规范应该被写在一个单独的仓库或者文档里，以供团队成员参考。&lt;/p&gt;
&lt;h4 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h4&gt;&lt;p&gt;设计模式有很多，从常见的工厂模式，单例模式，观察者模式，装饰器模式等到应用架构层面的MVC，MVVM等。&lt;/p&gt;
&lt;p&gt;设计模式主要帮我们将一个大型的系统解耦成不同的层次。比如将数据层和视图层分离，并用一个中间层将二者联系起来。&lt;/p&gt;
&lt;p&gt;因为大型的系统的模块数量众多，不同模块之间关系复杂。我们要用设计模式来将不同的模块划入不同的层次。&lt;/p&gt;
&lt;p&gt;而观察者模式这样的设计模式主要是为了使模块之间可以实现松耦合下的通信。虽然模块之间有着各种的依赖和调用关系，但我们并不打算让不同模块直接相互调用，而是实现一套接口，并借助中间人通信。这样如果某个模块被替换，只要新的模块实现了相同的接口，整个系统依然可以正常运行。&lt;/p&gt;
&lt;p&gt;在开发软件时，我们一般都遵循一套成熟的模式，在此基础上，完成业务代码的编写。设计模式也是大型软件的基石。&lt;/p&gt;
&lt;p&gt;对于设计模式，关键点往往不是你能说出几个设计模式，而是你懂得在什么情况下使用合适的设计模式。&lt;/p&gt;
&lt;h4 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h4&gt;&lt;p&gt;现在主流的版本控制工具是Git。Git主要的作用是版本控制，同时也帮助我们进行多人的协作。&lt;/p&gt;
&lt;p&gt;没有Git的话，如果我们需要保留多个不同版本的代码，就需要手动保存。在多人协作时，没有Git也是无法想象的。比如用FTP进行协作，每次都覆盖式的保存，这样的的代码管理无疑是非常原始的。&lt;/p&gt;
&lt;p&gt;事实上Git的Branch以及Github的pull request等等机制造就了一套独特的Git工作流。这套工作流无疑是团队协作的最佳选择之一。&lt;/p&gt;
&lt;h4 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h4&gt;&lt;p&gt;其实编程的精华便在于对过程（precedure）以及数据的抽象。这是一种编程的内功。通过对过程的抽象，我们可以将程序中可复用的模块提取成单独的函数，然后进行组合，这样可以大大增强程序的表现力。通过对数据的抽象，我们可以封装数据的细节，从一个更通用的维度来对数据进行操作。&lt;/p&gt;
&lt;p&gt;对于抽象，推荐大家看《计算机程序的构造与解释》这本书。当然抽象要合理才行，过度的抽象也会使代码的易读性受损。&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h4&gt;&lt;p&gt;测试主要是为了保证软件的质量。在软件被开发完成之后，会进行一系列的测试，以保证软件的高可用性。一般团队会有专门的测试工程师。负责测试用例的编写。&lt;/p&gt;
&lt;p&gt;对于后端这样主要负责数据处理的逻辑，我们可以编写自动化的单元测试，并且进行持续集成。单元测试以一个模块为单元进行测试，这样我们在错误发生时，可以准确的定位到具体的模块。单元测试也被用在测试驱动的开发中，测试驱动的开发就是先写测试用例，然后编写可以通过这个测试用例的代码。&lt;/p&gt;
&lt;p&gt;对于客户端代码来说，因为UI复杂多变。所以自动化的单元测试只有在对框架/库的代码进行测试时比较实际，在业务逻辑层面，比如视图层，我们一般采用人工测试。当然现在也有自动化的UI测试方案。&lt;/p&gt;
&lt;h4 id=&quot;项目管理&quot;&gt;&lt;a href=&quot;#项目管理&quot; class=&quot;headerlink&quot; title=&quot;项目管理&quot;&gt;&lt;/a&gt;项目管理&lt;/h4&gt;&lt;p&gt;项目管理，是学校软件工程课程中主要涉及的。这个主要涉及传统软件的开发流程。从需求分析，成本估算，开发流程到最后的测试。&lt;/p&gt;
&lt;p&gt;互联网的开发模型上主要还是比较敏捷的迭代。通常以一个月甚至几周的周期进行迭代。其中Web应用的特点便是可以随时发布更新，所以在这方面显得更突出一些。&lt;/p&gt;
&lt;p&gt;关于项目管理或者软件工程，大家可以去看《人月神话》，《构建之法》等书。虽然这些书主要针对的是传统软件工程，但我们在互联网产品的开发中还是可以从中汲取一些经验的。&lt;/p&gt;
&lt;h3 id=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;a href=&quot;#适合我们团队的一套工程化流程&quot; class=&quot;headerlink&quot; title=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;/a&gt;适合我们团队的一套工程化流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技术选型&lt;/strong&gt;-选用最合适的技术栈，当然为了把玩新技术而选用比较新的技术栈也是可以的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合适的工具&lt;/strong&gt;-鼓励大家，没有在开源社区找到符合自己要求的工具时，打造自己专属的工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git协作&lt;/strong&gt;-Git工作流&lt;/li&gt;
&lt;li&gt;代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;项目架构&lt;/strong&gt;-合适的抽象，不仅仅是MVC等架构，也包括其他可以复用的组件和Utility模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码审查&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单元测试（后端）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人肉或自动测试（客户端）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制Vue插件</title>
    <link href="http://yoursite.com/2016/11/13/vue-finger/"/>
    <id>http://yoursite.com/2016/11/13/vue-finger/</id>
    <published>2016-11-13T08:21:56.000Z</published>
    <updated>2016-11-30T08:48:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-finger，一个插件的诞生&quot; class=&quot;headerlink&quot; title=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;/a&gt;Vue-finger，一个插件的诞生&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-fin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊CSS Modules</title>
    <link href="http://yoursite.com/2016/11/12/css-modules/"/>
    <id>http://yoursite.com/2016/11/12/css-modules/</id>
    <published>2016-11-12T12:02:32.000Z</published>
    <updated>2016-11-13T09:22:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决全局作用域：Webpack-css-loader&quot;&gt;&lt;a href=&quot;#解决全局作用域：Webpack-css-loader&quot; class=&quot;headerlink&quot; title=&quot;解决全局作用域：Webpack css-loader&quot;&gt;&lt;/a&gt;解决全局作用域：Webpack css-loader&lt;/h3&gt;&lt;p&gt;Webpack的css-loader首先做出了解决全局作用域的尝试。解决办法就是在写CSS类名时加入&lt;code&gt;:local(...)&lt;/code&gt;这样的标记。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:local(.className) { background: red; }
:local .className { color: green; }
:local(.className .subClass) { color: green; }
:local .className .subClass :global(.global-class-name) { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转化为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;._23_aKvs-b8bW2Vg3fwHozO { background: red; }
._23_aKvs-b8bW2Vg3fwHozO { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 .global-class-name { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的办法就是把CSS类名转化为hash字符串，这样就可以保证每个类名都是独一无二的，自然也就不用在意命名冲突的问题了。只要在类名在当前模块内不会相互冲突就可以了。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules&quot;&gt;&lt;a href=&quot;#CSS-Modules&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules&quot;&gt;&lt;/a&gt;CSS Modules&lt;/h3&gt;&lt;p&gt;上述的办法，还是有一些不便。大多数情况下，比如在JavaScript中，变量都默认是局部变量。你想要声明一个全局变量，只能去全局作用域声明，或者把变量挂到local上（非严格模式下，不写var声明的是全局变量这种坑就不说了）。&lt;/p&gt;
&lt;p&gt;Webpack的开发者之后将css-loader中的local变成了默认设定，于是CSS Modules这个规范就呼之欲出了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/css-modules/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules规范&lt;/a&gt;。我们可以通过&lt;code&gt;css-loader?modules&lt;/code&gt;这个参数来开启CSS Modules。&lt;/p&gt;
&lt;p&gt;CSS Modules中的类名默认就是local的，如果你想要声明全局类名，可以加上&lt;code&gt;:global(...)&lt;/code&gt;这个标记。&lt;/p&gt;
&lt;h3 id=&quot;Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;Single Responsibility Principle&quot;&gt;&lt;/a&gt;Single Responsibility Principle&lt;/h3&gt;&lt;p&gt;讲CSS Modules的下一个特性之前。我们先聊点其他的，我们知道设计模式中有一条叫做Single Responsibility Principle。&lt;/p&gt;
&lt;p&gt;比如我们有一个button：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
    padding:2em;
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其把这些属性写在一个class里，我们可以把它拆分成多个单独的class：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--large{
    padding:2em;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在HTML中组合使用就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--large button--warnning&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的好处是什么呢？我们的UI中，一个组件往往有很多不同的状态。如果我们将每一个class写成只专注于一个属性，做好一件事，那就可以用这些class组合成所有我们想要的不同状态的组件。相比给每个状态的组件写一个单独的class，代码要更优雅简洁一些。&lt;/p&gt;
&lt;p&gt;比如我们想要一个small尺寸的普通button，只要加两个class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--small{
    padding:1em;
}
.button--large{
    padding:2em;
}
.button--normal{
    background-color:blue;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后组合就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--small button--normal&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;CSS-Classes-Composing&quot;&gt;&lt;a href=&quot;#CSS-Classes-Composing&quot; class=&quot;headerlink&quot; title=&quot;CSS Classes Composing&quot;&gt;&lt;/a&gt;CSS Classes Composing&lt;/h3&gt;&lt;p&gt;要想实现上述的这种组合，可以使用SASS的Mixin，但Mixin主要是提供了源代码中的抽象，最后生成的代码，和手写不同状态class的代码量，是一样的。&lt;/p&gt;
&lt;p&gt;CSS Modules提供的Classes Composing则刚好可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;比如我们想渲染一段文字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text{
  font-size: 20px;
  composes: red from &amp;quot;./common/color.css&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;color.css里是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.red{
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后渲染出的class是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;composes&lt;/code&gt;引入的类被作为一个单独的class引入，而不是和text类合在一起。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules和Vue工作流的整合&quot;&gt;&lt;a href=&quot;#CSS-Modules和Vue工作流的整合&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules和Vue工作流的整合&quot;&gt;&lt;/a&gt;CSS Modules和Vue工作流的整合&lt;/h3&gt;&lt;p&gt;Vue-loader在v9.8.0之后加入了对CSS Modules的支持。&lt;/p&gt;
&lt;p&gt;我们只要在&lt;code&gt;.vue&lt;/code&gt;文件的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;处加一个&lt;code&gt;module&lt;/code&gt;就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style lang=&amp;quot;sass&amp;quot; module&amp;gt;
.text{
  font-size: 20px;
  composes: red from &amp;quot;sass!./common/color.scss&amp;quot;;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有一点要注意，就是&lt;code&gt;composes&lt;/code&gt;引入的如果是需要预处理器处理的，要在前面加上预处理器的标记，比如SASS用户就加上&lt;code&gt;sass!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果需要对CSS Modules进行一些配置（其实这个是对Webpack的css-loader的配置，所以配置时可以参考&lt;a href=&quot;https://github.com/webpack/css-loader&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;css-loader的文档&lt;/a&gt;），写在vue-loader的配置的&lt;code&gt;cssModules&lt;/code&gt;属性里即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;loader: &amp;#39;vue&amp;#39;,
options: {
    cssModules: {
        localIdentName: &amp;#39;[name]-[local]-[hash:base64:5]&amp;#39;,
        camelCase: true
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vue-loader会自动将一个&lt;code&gt;$style&lt;/code&gt;属性注入到对应的Vue实例中。在模板中用class binding语法写就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div :class=&amp;quot;$style.app&amp;quot;&amp;gt;
    &amp;lt;div :class=&amp;quot;$style.text&amp;quot;&amp;gt;
      some text
    &amp;lt;/div&amp;gt;
    &amp;lt;main-text&amp;gt;&amp;lt;/main-text&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$style&lt;/code&gt;其实是一个原class名和处理之后class名的hash，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  app: &amp;quot;App-app-3cl75_0&amp;quot;,
  text: &amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我写一了一个简单的&lt;a href=&quot;https://github.com/zxc0328/css-modules-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO仓库&lt;/a&gt;，可以供参考。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;CSS Modules可以解决全局作用域和Class组合两个问题，加上SASS等预处理器，着实让我们在写CSS时的工程化程度大大提高了。&lt;/p&gt;
&lt;p&gt;对于使用Vue的同学来说，vue-loader可以使CSS Modules可以轻松的整合到已有的工作流中。如果你正在使用Vue，可以试试使用CSS Modules。&lt;/p&gt;
&lt;h3 id=&quot;Links&quot;&gt;&lt;a href=&quot;#Links&quot; class=&quot;headerlink&quot; title=&quot;Links&quot;&gt;&lt;/a&gt;Links&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://glenmaddern.com/articles/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules Welcome to the Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=zR1lOuyQEt8&amp;amp;index=29&amp;amp;list=LLHdx8Qwo6uxw0fj3gQ5yeTg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The case for CSS modules - Mark Dalgleish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React: CSS in JS by vjeux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>猪场实习感受-项目管理</title>
    <link href="http://yoursite.com/2016/10/03/project-management-in-netease/"/>
    <id>http://yoursite.com/2016/10/03/project-management-in-netease/</id>
    <published>2016-10-03T07:39:01.000Z</published>
    <updated>2016-10-03T08:08:53.000Z</updated>
    
    <content type="html">&lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;总的来说就是PM提出需求，交互出交互稿，然后这时研发和视觉可以同时开始进行。最后进行测试，测试通过后上线。这就是一个互联网产品版本迭代的过程。&lt;/p&gt;
&lt;h3 id=&quot;时间规划&quot;&gt;&lt;a href=&quot;#时间规划&quot; class=&quot;headerlink&quot; title=&quot;时间规划&quot;&gt;&lt;/a&gt;时间规划&lt;/h3&gt;&lt;p&gt;在上一个版本的开发过程中，PM和各个负责人就可以开始讨论下一个版本的需求，然后项目经理和大家一起确定这个版本的研发、测试和上线的时间节点。这个时间一旦确定，就必须严格执行，如果有需求无法完成要移到下一个版本做，必须经各个负责人确认后向大家发邮件说明。&lt;/p&gt;
&lt;h3 id=&quot;评审&quot;&gt;&lt;a href=&quot;#评审&quot; class=&quot;headerlink&quot; title=&quot;评审&quot;&gt;&lt;/a&gt;评审&lt;/h3&gt;&lt;p&gt;在我实习时，我作为开发，主要参加的就是交互的评审。这个评审的时间点在即将进入研发之前。其实主要就是交互设计师讲解交互稿，相关的开发人员提出自己的疑问，完善交互的可行性。&lt;/p&gt;
&lt;p&gt;按理来说应该还有需求评审、设计评审和代码评审。这些在实习时，比如代码评审因为时间的原因，没有做。在木犀的项目实践中，我觉得我们可以加入这些评审。时间的节点在视觉和开发完成，即将进入测试之前。&lt;/p&gt;
&lt;h3 id=&quot;JIRA&quot;&gt;&lt;a href=&quot;#JIRA&quot; class=&quot;headerlink&quot; title=&quot;JIRA&quot;&gt;&lt;/a&gt;JIRA&lt;/h3&gt;&lt;p&gt;JIRA是一款很有名的项目管理工具。在公司，我们一般是按需求创建Story，然后把交互、视觉和开发等任务关联到这个需求上。JIRA还有一个作用就是用来管理Bug。发现Bug的人可以提交Bug并指派给相关的责任人。JIRA有各种面板和筛选，可以方便的管理项目。&lt;/p&gt;
&lt;p&gt;我们暂时可以用Tower的任务来发挥JIRA的作用。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h3&gt;&lt;p&gt;测试主要是由专职的测试进行。测试负责编写测试用例，以及进行测试。&lt;/p&gt;
&lt;p&gt;当然，开发人员自己的自测是第一道防线。在开发完全之后，会进行冒烟测试，由测试提供用例，开发自行测试。用例主要和这一个版本的需求有关，主要就是检测一下需求中的功能是否被实现。只有冒烟测试通过了，才能进入真正的测试阶段。&lt;/p&gt;
&lt;p&gt;在测试人员进行测试的阶段。开发人员往往还要配合进行若干次的回归测试。同时要及时解决测试提出的Bug。&lt;/p&gt;
&lt;p&gt;首先测试开发环境下的项目，然后是测试环境，最后是预发布环境。预发布环境测试通过且Bug都解决的情况下，就可以上线了。&lt;/p&gt;
&lt;p&gt;对于我们这样的小团队来说，专职的测试是不太可能有的。主要就是在项目组中加入一位兼职的同学担任测试这个角色，然后各个模块的同学做到充分的自测。视觉、产品和交互进行走查（就是以用户的角度使用产品，来看是否有问题）。这样就可以保证较好的产品质量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个组件的诞生(下)</title>
    <link href="http://yoursite.com/2016/09/30/let-s-build-a-component-2/"/>
    <id>http://yoursite.com/2016/09/30/let-s-build-a-component-2/</id>
    <published>2016-09-30T02:34:07.000Z</published>
    <updated>2016-10-03T03:17:57.000Z</updated>
    
    <content type="html">&lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot;&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url1: &amp;quot;/somewhere/1.jpg&amp;quot;,
        url2: &amp;quot;/somewhere/2.jpg&amp;quot;
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction
            var indicators = document.querySelector(&amp;quot;.indicator&amp;quot;);
            indicators.map( (item, index) =&amp;gt; {
                _.removeClass(item, &amp;quot;hightLight&amp;quot;);
                if (index === data.index) {
                    _.addClass(item, &amp;quot;highLight&amp;quot;);
                }
            })    
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这的确可以实现我们想要的逻辑，但是看起来还是有点累赘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/4f19d188d43babcf6362d2372307492c_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们能把一部分逻辑写在模板里，然后在组件中，只需要修改数据，模板就会进行对应的渲染，是不是很酷呢？&lt;/p&gt;
&lt;p&gt;这就是所谓的&lt;strong&gt;数据驱动&lt;/strong&gt;。组件帮我们封装了底层的DOM操作细节。我们只需要声明组件的状态就可以了。用户的交互造成组件的状态改变，然后状态的改变又造成了DOM层面的重新渲染。组件就像是一个黑盒子，接收我们输入的数据，输出视图。计算机做的事情其实就是处理数据。因此，我们做这样的抽象，是非常&lt;strong&gt;符合本能的一种抽象&lt;/strong&gt;。可以让我们集中精力来关注业务逻辑。同时也&lt;strong&gt;降低了前端组件的复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那就让我们来试试吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url }}&amp;quot; for=&amp;quot;url in urls&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot; &amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot; 
        class=&amp;quot;{{ $index === index ? &#39;highLight&#39; : &#39;normal&#39; }}&amp;quot;
          for=&amp;quot;url in urls&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url: [&amp;quot;/somewhere/1.jpg&amp;quot;, &amp;quot;/somewhere/2.jpg&amp;quot;]
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction //更新index
            this.render() //重新渲染
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有一个新的&lt;code&gt;for=&amp;quot;url in urls&amp;quot;&lt;/code&gt;，我们把这个叫做指令。指令可以理解为为模板增加分支、循环等逻辑的标记。模板引擎在编译这个指令时就会按数据进行对应的渲染。这里用到的是循环指令，作用就是按给定的数据循环遍历，每遍历到一个就讲数据填充到模板中进行渲染。&lt;code&gt;$index&lt;/code&gt;是这个指令中一个特殊的变量，代表当前遍历到的元素的下标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样就清楚多啦。我们修改&lt;code&gt;data.index&lt;/code&gt;，然后调用&lt;code&gt;this.render()&lt;/code&gt;这个生命周期方法。不用操纵任何DOM节点。视图就更新了。是的，我们在某种程度上实现了数据驱动！&lt;/p&gt;
&lt;h3 id=&quot;Vue-and-beyond&quot;&gt;&lt;a href=&quot;#Vue-and-beyond&quot; class=&quot;headerlink&quot; title=&quot;Vue and beyond&quot;&gt;&lt;/a&gt;Vue and beyond&lt;/h3&gt;&lt;p&gt;大家可以对比一下Vue的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue({
  el: &amp;#39;#app&amp;#39;,
  data: {
    message: &amp;#39;Hello Vue.js!&amp;#39;
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和我们的组件的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        message: &amp;#39;Hello Vue.js!&amp;#39;
    },
    events: {
        &amp;quot;.some-button.click&amp;quot;: this.oClick,
    },
    methods: {
        onClick: function() {
            // 业务逻辑
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是很像呢，除了&lt;code&gt;events&lt;/code&gt;这个选项。因为Vue把这些逻辑都放到指令中了，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;button v-on:click=&amp;quot;reverseMessage&amp;quot;&amp;gt;Reverse Message&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以Vue的本质，就是一个用来构建用户界面的组件库。和我们一步步的设计API，调整模板，构建出来的这个组件，没有本质的区别。&lt;/p&gt;
&lt;p&gt;但Vue为什么好用呢？首先Vue有完善的指令系统，比如&lt;code&gt;v-for``v-for&lt;/code&gt;和&lt;code&gt;v-if&lt;/code&gt;等。其次是Vue实现了数据的双向绑定。双向绑定就是用户在界面上输入的数据，可以被同步到组件的状态中。刚才，我们在自己的组件中实现了将组件状态同步到界面，而双向绑定就以为着这个同步可以是反向的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双向绑定的实现是一个单独的话题。Angular使用的脏检查是一个流派。Vue使用&lt;code&gt;Object.defineProperty&lt;/code&gt;API来实现。React倒是没有数据绑定的概念，不过React的Virtual DOM Diff从某种角度来说，其实也是脏检查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们所实现的其实是一种粗犷的同步方式。并没有实现所谓的数据“绑定”。数据绑定就以为着为每个模板中被绑定的数据创建一个&lt;code&gt;Watcher&lt;/code&gt;，这个&lt;code&gt;Watcher&lt;/code&gt;决定数据变化时做什么操作。比如对于DOM中的表达式，&lt;code&gt;Watcher&lt;/code&gt;就会对这个表达式重新求值，然后更新这个表达式所在的DOM节点的对应属性。&lt;/p&gt;
&lt;p&gt;按之前我们的做法，如果一个数据变动，就会造成整个组件的重新渲染。这样明显是低效的。数据绑定可以做到特定DOM节点的更新，这是目前前端组件的主流。&lt;/p&gt;
&lt;h3 id=&quot;从MVC到MVVM&quot;&gt;&lt;a href=&quot;#从MVC到MVVM&quot; class=&quot;headerlink&quot; title=&quot;从MVC到MVVM&quot;&gt;&lt;/a&gt;从MVC到MVVM&lt;/h3&gt;&lt;p&gt;前端的MVC或者MVVM，View一般就指模板（模板可以看成是抽象的View，DOM则是这个抽象View的implementation detail）。我们的第一个组件构造器构造出来的对象其实是MVC中的Controller。里面的&lt;code&gt;data&lt;/code&gt;属性应该被单独拿出作为一个Model对象，这个对象可以通过观察者模式和Controller进行通信。&lt;/p&gt;
&lt;p&gt;MVVM中的Model就是一个plain object，比如我们打造的组件中的&lt;code&gt;data&lt;/code&gt;。Vue这样的MVVM框架，Vue实例其实是MVVM中的VM，即ViewModel。Model，如上文说的，是一个挂载在&lt;code&gt;data&lt;/code&gt;属性上的普通的对象。我们修改这个对象，就会驱动View的更新。MVVM的独特处之一就在于此。MVVM的独特处之二就是，Model和View直接数据的双向绑定。VM和MVC中Controller的不同之处在于通信方式的不同。MVVM中各个部分的联动比较复杂，我们叫reactive system。MVC中的事件广播模式，主要是在组件之间的通信这个层面比较明显。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个组件的诞生(上)</title>
    <link href="http://yoursite.com/2016/09/29/let-s-make-a-component/"/>
    <id>http://yoursite.com/2016/09/29/let-s-make-a-component/</id>
    <published>2016-09-29T02:24:27.000Z</published>
    <updated>2016-09-30T08:00:43.000Z</updated>
    
    <content type="html">&lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var banner = {
    init: function() {
        this.addEvent();
    },
    addEvent: function() {
        var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
        var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
        buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(1)
        })
        buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
            this.switchClassName(-1)
        })

    },
    switchClassName: function(direction) {
        // 切换Class类名
    }
}

banner.init();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;1.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;2.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;3.jpg&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/monocle-guy/jolly-god-old-chap-thumb.jpg&quot; alt=&quot;old chap&quot;&gt;&lt;/p&gt;
&lt;p&gt;正当你觉得自己可以刷知乎的时候，主管把你叫到一边，告诉你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你这个页面上需要有两个banner，怎么办呢？复制粘贴吗?&lt;/li&gt;
&lt;li&gt;如果在需要在某个时间点从页面上移除banner，怎么办呢？手动remove节点吗，销毁对象吗？&lt;/li&gt;
&lt;li&gt;如果banner中图片的URL是从服务端API请求到的动态的数据，难道要用一个个用修改图片的src的方法来显示这些数据吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;听到这里，你的内心是崩溃的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.troll.me/images/y-u-no/css-floats-y-u-no-clear-yourself-thumb.jpg&quot; alt=&quot;y no &quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;面向对象大法&quot;&gt;&lt;a href=&quot;#面向对象大法&quot; class=&quot;headerlink&quot; title=&quot;面向对象大法&quot;&gt;&lt;/a&gt;面向对象大法&lt;/h3&gt;&lt;p&gt;这时，你想起了大学时学过的面向对象。你把你的组件改成了这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Banner = function(options) {
}

Banner.prototype.init = function() {
    this.addEvent();
}

Banner.prototype.addEvent = function() {
    var buttonLeft = document.querySelector(&amp;quot;.button-left&amp;quot;);
    var buttonRight = document.querySelector(&amp;quot;.button-right&amp;quot;);
    buttonLeft.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(1);
    })
    buttonRight.addEventListener(&amp;quot;click&amp;quot;, function() {
        this.switchClassName(-1);
    })
}

Banner.prototype.switchClassName = function(direction) {
    // 切换Class类名
}

Banner.prototype.destroy = function() {
    //todo:解绑事件
}

//初始化
var banner1 = new Banner();
var banner2 = new Banner();

//销毁
banner1.destroy();
banner2.destroy();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;棒，这样就可以轻松的使用多个banner，并通过调用&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;等生命周期方法来初始化和销毁组件了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生命周期&lt;br&gt;这是组件开发中的一个术语。如果把组件比作一个生物，我们设计的API，比如&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;destroy&lt;/code&gt;就相当于这个生物的出生和死亡。一个组件从&lt;code&gt;init&lt;/code&gt;被调用时被初始化，渲染到页面上，然后和用户发生交互，这时调用的方法也属于生命周期的一部分。用户界面随着用户的交互而发生变化，所以组件也不是一成不变的。生命周期方法其实就是在组件的某个阶段会被调用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;模板和渲染&quot;&gt;&lt;a href=&quot;#模板和渲染&quot; class=&quot;headerlink&quot; title=&quot;模板和渲染&quot;&gt;&lt;/a&gt;模板和渲染&lt;/h3&gt;&lt;p&gt;还有一个问题没有解决，那就是如何轻松的将数据填充到DOM节点中呢？&lt;/p&gt;
&lt;h4 id=&quot;字符串拼接大法&quot;&gt;&lt;a href=&quot;#字符串拼接大法&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接大法&quot;&gt;&lt;/a&gt;字符串拼接大法&lt;/h4&gt;&lt;p&gt;你首先想出了一个比较笨的办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var url = &amp;quot;/images/1.png&amp;quot;
var template = funtion(url) {
    return &amp;quot;&amp;lt;img src=&amp;#39;&amp;quot; + url + &amp;quot;&amp;#39;/&amp;gt;&amp;quot;;
}

template(url); // &amp;quot;&amp;lt;img src=&amp;#39;/images/1.png&amp;#39;/&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是传说中的字符串拼接大法。一种非常原始的“模板”。简单的说就是把HTML中不变的部分原样写成字符串，中间的变化的部分，我们叫模板的变量，会被作为参数输入到模板函数中。然后这些变量和字符串拼接起来，就生成了目标HTML字符串。&lt;/p&gt;
&lt;p&gt;上例中的&lt;code&gt;template&lt;/code&gt;函数做的事情，我们叫做“编译”模板。当然这个函数非常简单，只是拼接了一下字符串。一个成熟的模板引擎的编译函数做的事情，要更接近于传统意义上的“编译”。&lt;/p&gt;
&lt;h4 id=&quot;DOM-based模板&quot;&gt;&lt;a href=&quot;#DOM-based模板&quot; class=&quot;headerlink&quot; title=&quot;DOM based模板&quot;&gt;&lt;/a&gt;DOM based模板&lt;/h4&gt;&lt;p&gt;字符串拼接大法的问题，相信大家都看到了，就是写起来非常的麻烦，各种单引号和双引号。如果要换行还必须用&lt;code&gt;+&lt;/code&gt;号拼接。&lt;/p&gt;
&lt;p&gt;于是我们就想到了，如果我们把模板作为普通的HTML，那就会方便很多。我们只要像写HTML那样把模板写在HTML文件中，比如:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要向获取模板的内容，只需要这样：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的就是这个模板的字符串了。&lt;/p&gt;
&lt;p&gt;假设我们写了一个模板引擎，它的作用就是将&lt;code&gt;&lt;/code&gt;花括号内的表达式，在模板的context下面解析，并返回值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context，就是指一个特定的作用域。里面有当前作用域下面的变量（标识符）和对应的值之间的映射。模板的context就是指一个有模板中相关变量的作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个模板引擎是这样使用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#39;complie&amp;#39; from &amp;#39;templateEngine&amp;#39;

var templateString = document.querySelector(&amp;quot;#template&amp;quot;).innerHTML
var data = {
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
var HTMLString = compile(templateString, data)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当&lt;code&gt;compile&lt;/code&gt;函数遇到变量时，就会从&lt;code&gt;data&lt;/code&gt;中去找。&lt;code&gt;data&lt;/code&gt;在这个例子就是context。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插一句，被大家吐槽的&lt;code&gt;eval&lt;/code&gt;函数可以用来做在特定context下求值的事情，这正是这种模板引擎所需要做的。所以你可以用&lt;code&gt;eval&lt;/code&gt;来实现一个简单的模板引擎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为这个花括号中可以是任意合法的JavaScript表达式，所以你也可以这样玩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//其他省略
var data = {
    displayFlag: false,
    url1: &amp;quot;/images/1/png&amp;quot;,
    url2: &amp;quot;/images/1/png&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那这段模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;{{ displayFlag ? &#39;display:block&#39;:&#39;display:none&#39;}}&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被解析为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;template&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/images/1.png&amp;quot;/&amp;gt;
    &amp;lt;img src=&amp;quot;/images/2.png&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很神奇，不是吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ricardomartins.com.br/wp-content/uploads/2015/05/Magic_meme.gif&quot; alt=&quot;magic&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;render生命周期方法&quot;&gt;&lt;a href=&quot;#render生命周期方法&quot; class=&quot;headerlink&quot; title=&quot;render生命周期方法&quot;&gt;&lt;/a&gt;&lt;code&gt;render&lt;/code&gt;生命周期方法&lt;/h4&gt;&lt;p&gt;因为现在我们的组件不再使用静态的HTML字符串了，我们需要一个函数来输出HTML字符串。所以我们需要在组件上增加一个叫&lt;code&gt;render&lt;/code&gt;的生命周期函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Banner.prototype.render = function() {
    this.el.innerHTML = compile(this.el.innerHTML, this.data);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的&lt;code&gt;el&lt;/code&gt;是这个组件的一个配置项，代表这个组件的根节点。组件的模板来自根节点的内容。模板编译之后输出的HTML字符串又会替换根节点中的模板，从而渲染这个组件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，模板所在的节点和渲染组件的节点可以不是同一个，这个是和具体的组件框架实现相关的。只要模板可以以字符串的形式被引入，就可以达到目的了。是否放在HTML的DOM节点中并不是问题的关键。我们可以写单独的模板文件并用webpack等打包工具引入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h3&gt;&lt;p&gt;一个组件中，比如模板根节点，组件某个节点的事件和handler的Map，事件的handler，以及组件的&lt;code&gt;data&lt;/code&gt;这样的数据，应该在组件实例化的时候，作为配置被传入构造函数中。&lt;/p&gt;
&lt;p&gt;所以，让我们改造一下Banner构造函数和&lt;code&gt;init&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Banner = function(options) {
    this.data = options.data || {};
    this.el = options.el || document.querySelector(&amp;quot;body&amp;quot;);
    this.events = options.events;
}

Banner.prototype.init = function(options) {
    this.render();//渲染模板
    this.addEvent(this.events);//根据events这个Map来绑定事件
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，如果你这样再初始化一个组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        url1: &amp;quot;/somewhere/1.jpg&amp;quot;,
        url2: &amp;quot;/somewhere/2.jpg&amp;quot;
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑        
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里我们新增了events和methods两个对象，这其实就是将之前写死在组件内部逻辑里的事件绑定和回调函数拿出来，在初始化时传入，由组件内部根据这个配置自动绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并调用&lt;code&gt;init&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;banner.init()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时你的页面上就出现了一个banner！大功告成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/pp.png&quot; alt=&quot;pp&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;API设计和抽象&quot;&gt;&lt;a href=&quot;#API设计和抽象&quot; class=&quot;headerlink&quot; title=&quot;API设计和抽象&quot;&gt;&lt;/a&gt;API设计和抽象&lt;/h3&gt;&lt;p&gt;到这里，我们的组件之旅就达到了一个阶段。我们对比一下就可以发现，传统的Backbone和jQuery UI的组件就是类似这种模式的。&lt;/p&gt;
&lt;p&gt;具体的说，首先你的组件是一个构造函数，你通过传入不同的配置来实例化不同的组件。不知道大家有没有发现，我们的组件以及&lt;strong&gt;不仅仅是一个Banner&lt;/strong&gt;了，而是一个&lt;strong&gt;通用&lt;/strong&gt;的组件。你通过传入不同的模板、数据、事件和回调来实例化不同的组件。可以是一个Banner，也可以是一个评论框等等。&lt;/p&gt;
&lt;p&gt;传统前端组件有着相似的生命周期API设计。比如初始化、渲染、销毁等。这个和前端组件的特点有关，就算是React或者Vue这样最新的技术，它的生命周期API也不外乎这几种，再加上一些和自己这个库运行流程相关的特有的API而已。&lt;/p&gt;
&lt;p&gt;模板是一种对DOM的封装。模板把我们从手动操纵DOM中解放出来。我们在传统的HTML基础上加入表达式和分支逻辑，让模板可以根据输入的数据渲染出相应的HTML字符串。这实际上就是将HTML作为底层的细节封装起来。模板作为一种&lt;strong&gt;中间形态&lt;/strong&gt;存在，是&lt;strong&gt;一种抽象&lt;/strong&gt;。抽象，是计算机最&lt;strong&gt;本质&lt;/strong&gt;的一种属性。我们在平时的API设计和编码时应该牢记这一点，培养自己的抽象思维。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zxc0328.github.io/2016/09/30/let-s-build-a-component-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下一篇&lt;/a&gt;会讲到如何将我们的组件改造成数据驱动的模式，并将这个组件和Vue进行对比。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;你是一个新手前端工程师，今天你接到了一个需求，写一个banner。banner嘛，大家都知道，就是一个用来展示图片的东西，不同的图片可以滚动切换。&lt;/p&gt;
&lt;p&gt;你心想着这很简单啊，于是刷刷刷写了一个。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编码》导读</title>
    <link href="http://yoursite.com/2016/09/15/read-code/"/>
    <id>http://yoursite.com/2016/09/15/read-code/</id>
    <published>2016-09-15T10:32:05.000Z</published>
    <updated>2016-10-25T15:19:44.000Z</updated>
    
    <content type="html">&lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;《编码》讲的是什么呢？笼统的说，就是用自底向上的角度一层层的解析计算机的原理。比如第一章到第三章将的是编码的本质——信息和符号的对应。第四章到第六章讲的是电信号可以用来表示一种编码，从而传递信息。第七章到第九章介绍了二进制，也就是计算机系统中最基本的编码形式。第十章：逻辑与开关和第十一章：门，介绍了布尔代数，以及如何使用门电路进行布尔代数的运算。第十二章和第十三章介绍了二进制加法器和减法器，加法器已然是现代CPU中运算单元的雏形了。第十四章介绍的反馈与触发器是实现计算机中储存芯片的基础。第十五章字节与十六进制是为理解后续的存储器数据格式而准备的。第十六章讲了存储器的组织，这便是现代计算机系统中存储系统的原理。第十七章，是全书最难的一章，讲了如何制作一个CPU。CPU本质上就是一个可以编程的运算器。第十八章介绍了从算盘到机械结构到电子管再到晶体管的技术革命，晶体管、超大规模集成电路使得现代CPU的出现成为了可能。第十九章介绍了Intel 8080CPU的指令集。第二十章介绍了字符的存储格式，这可以帮助你理解计算机是如何存储文本的。第二十一章：总线，介绍了计算机系统中CPU、内存和I/O设备如何通信。第二十二章是一个简短的操作系统简史，注意到从这里我们涉及了软件层面的内容。第二十三章定点数和浮点数比较独立，主要讲了计算机是如何存储浮点数的。第二十四章和第二十五章则介绍了编程语言和图形学基础。&lt;/p&gt;
&lt;p&gt;我们可以清晰的看到从硬件到软件，从具体到抽象，从底层到顶层的一个脉络。&lt;/p&gt;
&lt;p&gt;这本书其实包含了我们计算机专业中《数字逻辑》、《计算机组成原理》、《微机系统与接口原理》三门课的主干内容。作者没有试图灌输大量的理论知识，而是试图将这些知识串联起来，包括最后的操作系统和编程语言，其实和计算机硬件是有着不可分割的关系的。在《编码》这本书中你就可以很自然的在章节的推进中体会到这种联系。&lt;/p&gt;
&lt;p&gt;下面我会对一些章节进行详细的解读。主要是解释难点，拓展一些知识，并且写清这一章节的知识对应我们的哪门专业课，而专业课和这本书的要求有何不同等等。&lt;/p&gt;
&lt;p&gt;我希望这本书可以让大家看清计算机的本质，计算机的本质其实就是一个处理信息的机器。你输入数据，计算机输出数据。首先我们需要一套编码系统来表示这些数据，而二进制的编码正好与半导体的性质相吻合，我们可以用布尔代数来对现实问题进行建模，通过门电路来表示这个布尔代数，从而制造出可以进行某种运算的电路。而如果这个电路可编程，再加上输入输出接口，那就是一个CPU了。至于是半导体和二进制之间孰先孰后呢，你可以做进一步的研究（从书中来看，第一台计算机ENIAC是采用十进制的，所以看来应该是半导体在先，二进制在后）（所以今后如果计算机的物理介质有了更新，我们也许就会换一种新的编码方案了）。&lt;/p&gt;
&lt;p&gt;在书中大量讲到的门电路、继电器等等属于实现层面，大家了解一下就好。我们不是电气工程师，我们是软件工程师。当然理解硬件层面细节对于写好代码是很有帮助的。这主要解释的是一个“为什么”的问题。&lt;/p&gt;
&lt;p&gt;你了解了CPU的指令集，和CPU的工作方式，你就理解为什么我们在程序运行时需要“栈”这个数据结构。&lt;/p&gt;
&lt;p&gt;你了解了字符的编码以及浮点数的编码，你就不会奇怪于为什么&lt;code&gt;0.1+0.2&lt;/code&gt;不等于&lt;code&gt;0.3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们要关注的主要是如何用编码来抽象问题。比如用二进制来表示数据，进行运算。比如用指令来对CPU进行编程。比如&lt;/p&gt;
&lt;h3 id=&quot;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot;&gt;&lt;a href=&quot;#第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot; class=&quot;headerlink&quot; title=&quot;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&quot;&gt;&lt;/a&gt;第一章：至亲密友、第二章：编码与组合和第三章：布莱叶盲文与二进制码&lt;/h3&gt;&lt;p&gt;前几章就举了几个编码的例子，让你知道——编码可以用来传递信息。然后布莱叶盲文是一种二进制的编码，因为和计算机的二进制特点符合，所以被拉出来讲了。接下去几章就是铺垫一些电学基础，让你知道我们可以用开关的开和闭，来表示1和0的编码。这样后面就可以借助这个特性，拿开关和电线来组装计算机了。&lt;/p&gt;
&lt;h3 id=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;a href=&quot;#第四章：手电筒的剖析、第五章：绕过拐角的通信&quot; class=&quot;headerlink&quot; title=&quot;第四章：手电筒的剖析、第五章：绕过拐角的通信&quot;&gt;&lt;/a&gt;第四章：手电筒的剖析、第五章：绕过拐角的通信&lt;/h3&gt;&lt;p&gt;第五章里最重要的概念就是接地。大地电阻很大，但大地是导体。电子只要流动就能形成电能，电子是哪里来的？是不是一个环路？这个不重要。接地处电子往大地那里移动，电势就低。电池那边的电子就可以往接地处移动了。&lt;br&gt;有人说，那我一个电路，中间拿掉一个导线，为什么不能接通？因为空气的电阻太大了··· 电子没法移动到空气中。&lt;/p&gt;
&lt;h3 id=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;a href=&quot;#第十章：逻辑与开关与第十一章：门&quot; class=&quot;headerlink&quot; title=&quot;第十章：逻辑与开关与第十一章：门&quot;&gt;&lt;/a&gt;第十章：逻辑与开关与第十一章：门&lt;/h3&gt;&lt;p&gt;第十章首先介绍的内容是：布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数，其实在我们的《离散数学》课里就接触过。&lt;em&gt;注：如果没学过离散数学，可以买《离散数学及其应用》这本书学习，这里说到的形式逻辑主要指命题逻辑&lt;/em&gt;《离散数学》里一开始讲的逻辑，比如这种形式的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/3ad862b103437f908a58b008703464bea93a1ef2&quot; alt=&quot;命题逻辑&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道一个命题可能是真（T），也可能是假（F）。那如果我们把T和F换成1和0，然后将命题逻辑中的合取，析取，否定等关系换了一种表示形式，这就成了布尔代数。&lt;/p&gt;
&lt;p&gt;布尔代数中每个变量都是一个&lt;code&gt;{0,1}&lt;/code&gt;的集合。命题逻辑中的合取在布尔代数中用&lt;code&gt;·&lt;/code&gt;或者AND表示，而析取则用&lt;code&gt;+&lt;/code&gt;或者OR表示。否定则用表示。&lt;/p&gt;
&lt;p&gt;在第十一章中，有一个布尔表达式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(M·N·(W+T)+(F·N·(1-W))+B)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们代入每个变量之中，运用布尔代数运算符的规则，就可以计算出这布尔表达式的值是True或者是False。&lt;/p&gt;
&lt;p&gt;这就是问题的关键了，布尔代数是一个&lt;strong&gt;抽象的计算模型&lt;/strong&gt;。我们可以将现实世界的问题，抽象成布尔表达式（当然这个最终是因为我们可以用命题逻辑来表示现实世界的问题）。&lt;/p&gt;
&lt;p&gt;讲到这里，似乎和计算机没有什么关系。但最精彩的部分就在下面，我们可以&lt;strong&gt;用布尔代数设计电路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个机械开关，有开启和闭合两种状态，可以用来表示0或者1。这个是《编码》前几章大力铺垫的一个事实。既然这样，那我们就可以用两个开关的并联或者串联来表示AND和OR逻辑。更进一步，我们可以用开关和电线表示任何布尔表达式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;用布尔代数可以用某种电路来等价的表示&lt;/strong&gt;这个事实。从在19世纪50年代乔治·布尔发明布尔代数开始，一直到20世纪30年代才被信息论之父香农发现。尽管逻辑电路所需的开关和电线在19世纪都已经存在了。可见这种等价关系的革命性意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，反过来，布尔表达式也可以指导我们设计电路。事实上这个是目前所有逻辑电路设计的理论基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《数字逻辑》这门课讲布尔代数，主要是作为设计电路的一种工具。假如我们要设计电路，解决这个现实问题。这个问题被抽象成几个输入和输出。这些输入和输出是可能是0或者1。我们知道不同变量输入时对应的输出，也就是所谓的真值表。利用真值表，我们可以写出一个布尔表达式。但这个布尔表达式可以化简。我们可以用卡诺图等方式进行化简，化简的目的是简化电路。最终，化简的电路可以转化为门电路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《编码》里只是简单的介绍了布尔代数和门电路，没有深入的介绍电路的设计。这是比较明智的，因为如何设计电路不是我们要关心的话题。《数字逻辑》中在电路设计这块涉及的还有功能表到布尔表达式的转换，布尔表达式的化简等等。有兴趣的同学可以了解一下。&lt;/p&gt;
&lt;p&gt;总结一下，这两章对我们最大的启发就是：逻辑电路设计的理论基础是布尔代数。布尔代数可以用逻辑电路进行等价表示。而逻辑电路则是计算机所有硬件的基础。&lt;/p&gt;
&lt;h3 id=&quot;第十二章：二进制加法器&quot;&gt;&lt;a href=&quot;#第十二章：二进制加法器&quot; class=&quot;headerlink&quot; title=&quot;第十二章：二进制加法器&quot;&gt;&lt;/a&gt;第十二章：二进制加法器&lt;/h3&gt;&lt;p&gt;这章一开始说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们可以造出加法器，同样地，就可以利用加法来实现减法、乘法和除法，计算按揭付款，引导火箭飞到火星、下棋，以及填写我们的话费账单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家可能觉得这是夸张的说法，但其实加法器的确就是CPU中最重要的部分。实现了加法器，再加上存储系统，和控制器，就是一个基本的计算机了。&lt;/p&gt;
&lt;p&gt;所以这章内容可以说是《编码》这本书介绍的如何制造一台计算机中的第一次飞跃（第二次飞跃是第十七章，自动操作）。&lt;/p&gt;
&lt;p&gt;说的很神奇，其实加法器就是由简单的门电路构成的一个电路而已。&lt;/p&gt;
&lt;p&gt;我们已经知道了各种门电路的输入输出，那问题就是，如何来利用门电路，设计一个相对复杂的电路呢？&lt;/p&gt;
&lt;p&gt;这部分的知识对应的是大学中的《数字逻辑》课程。电路的设计有一套成熟的方法，当然我们先不考虑那么多，先来看看《编码》的作者是如何设计这个加法器电路的。&lt;/p&gt;
&lt;p&gt;对于一个电路，我们&lt;strong&gt;首先&lt;/strong&gt;要确定输入和输出，并写出一个真值表。&lt;/p&gt;
&lt;p&gt;我们进行二进制数的相加时，会分别相加两个二进制数的每一位，如果有进位，则将进位加入下一位二进制数的相加中。&lt;/p&gt;
&lt;p&gt;这样，我们就可以将两个二进制数的加法，转化为多次的一位二进制数加法。一位二进制数加法的输入是两个个加数。输出是一位的二进制数，以及一个进位数。比如输入是1加1，输出结果是0，进位位是1。&lt;/p&gt;
&lt;p&gt;现在我们就可以列出两个真值表，一个是加法的真值表，一个是进位的真值表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;+加法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;+进位&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;好了，现在我们可以进入第二步，根据真值表，设计电路。&lt;/p&gt;
&lt;p&gt;我们要设计这样一个电路，输入A和B，都是一位二进制数，输出结果C和进位数D，也是都是一位二进制数。&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;观察真值表的输入和输出&lt;/strong&gt;，发现进位表的真值和与门是一样的。而加法表的真值和异或门是一样的。&lt;/p&gt;
&lt;p&gt;P141页的半加器，就是简单地将一个异或门和一个与门连到相同的输入端。异或门输出的就是加法结果，与门输出的则是进位的结果。&lt;/p&gt;
&lt;p&gt;为什么这个叫半加器呢，因为这个半加器还无法完成真正的加法，因为它的输入中没有考虑进位。真正的一位加法器，输入有两个加数，以及进位位，输出结果和进位位。&lt;/p&gt;
&lt;p&gt;P142页顶部的图就是全加器。它的原理就是级联两个半加器，将第一个半加器的结果和输入的进位位相加，对于两个半加器输出的进位位，则用一个或门来处理。或门在这里其实也是起一个加法器的作用，只不过两个级联的半加器的进位输出不会同时为1&lt;em&gt;（如果前一个半加器产生进位，那结果必然是0，那后一个半加器就不可能产生进位了）&lt;/em&gt;，因此不用考虑输入都为1的情况。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P144页&lt;/em&gt;底部的图，讲8个全加器连接起来，前一个全加器的进位位输出是后一个全加器的进位位输入，第一个全加器的进位输入是0。这样我们就得到了一个8位加法器。&lt;/p&gt;
&lt;p&gt;这个加法器用开关的开和闭表示1或者0的输入，用灯泡的亮和灭表示1或者0的输出。这种方式很原始，但从原理上来说和现代的晶体管电路和LED显示器没有太大的不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种加法器有一个问题，也就是书中P146页讲到的，在时间上必须串行工作，即后一个全机器要等前一个完成运算之后才能进行运算，而不是并行的工作。解决这个问题，可以用前置进位等方法来提高运算的速度。这个会在《数字逻辑》课中讲到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们要知道的一点是，这里的电路是比较naive的。因此作者可以一眼看穿真值表对应的电路。而实际中电子工程师设计的电路是非常复杂的。用专门的方法和设计语言。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《数字逻辑》课程中，有一套非常sophisticated的设计电路的方法。从真值表中得出布尔代数表达式，用卡诺图等工具对这个表达式化简，最后用基本的门电路来实现。我们作为软件工程师，对这套方法有着基本的掌握就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这章的意义重大。我们用19世纪就被发明出来的电子器件，开关，灯泡和继电器，搭建了一个加法器。这可是一个能做&lt;strong&gt;加法&lt;/strong&gt;的机器，这意味着我们可以用机器来做&lt;strong&gt;通用计算&lt;/strong&gt;，而不是之前设计的只能帮你选择猫咪的死板电路（当然我觉得那个电路也很神奇），这在构建可编程计算机的道路上无疑是一个里程碑。&lt;/p&gt;
&lt;p&gt;回首这个过程，最重要的理论上的突破，无疑是布尔代数的发明，以及香农将代数和电路对应起来，用电路实现布尔代数的发现。&lt;/p&gt;
&lt;h3 id=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;a href=&quot;#第十八章：从算盘到芯片&quot; class=&quot;headerlink&quot; title=&quot;第十八章：从算盘到芯片&quot;&gt;&lt;/a&gt;第十八章：从算盘到芯片&lt;/h3&gt;&lt;h3 id=&quot;第二十五章：图形化革命&quot;&gt;&lt;a href=&quot;#第二十五章：图形化革命&quot; class=&quot;headerlink&quot; title=&quot;第二十五章：图形化革命&quot;&gt;&lt;/a&gt;第二十五章：图形化革命&lt;/h3&gt;&lt;p&gt;这章与其说是在讲图形化革命，不如说是PC多媒体方向的发展史。&lt;/p&gt;
&lt;h4 id=&quot;从电传打字机到视频显示器&quot;&gt;&lt;a href=&quot;#从电传打字机到视频显示器&quot; class=&quot;headerlink&quot; title=&quot;从电传打字机到视频显示器&quot;&gt;&lt;/a&gt;从电传打字机到视频显示器&lt;/h4&gt;&lt;p&gt;当然首先提到的还是图形化革命。这里有一个很重要的概念就是人机交互界面（GUI）。在打孔机时代，人机交互的实现主要是，通过纸带或者各种开关进行输入，然后经过计算机批处理之后输出。这个输入-处理-输出的循环，就是一个人机交互的过程。&lt;/p&gt;
&lt;p&gt;20世纪60年代，流行的时分操作系统，输入和输出设备是打字机。这就比较接近于现代计算机的交互了。&lt;/p&gt;
&lt;p&gt;早期的显示器，其实就是“玻璃屏幕电传打字机”。这样的显示设备仅仅只能一行一行的输出字符，和打字机没有太大区别。想要显示图形，那就只能使用ASCII Art了。这种类似打字机的界面，比较接近于我们现在使用的终端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言的标准I/O里的输出函数为什么叫&lt;code&gt;print&lt;/code&gt;呢？这就和当年的输出设备是打字机有关系了。在当时看来，这个函数就是在纸上打印字符，所以叫&lt;code&gt;print&lt;/code&gt;是很贴切的。&lt;br&gt;Linux中的一些命令，也和早期计算机的输入输出有关。比如早期计算机使用磁带作为存储设备。大家有兴趣的可以了解一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下去就是一个关键的分界线了。首先，我们要知道显示设备的原理。光栅显示器的原理就是，用一个像素点矩阵来组成图像。比如分辨率是1920*1080，那就意味着你看到的图像由2073600个像素点组成。&lt;/p&gt;
&lt;p&gt;我们知道红、绿、蓝。三原色可以混合出所有的颜色。那我们就可以通过某种编码来表示显示器像素的颜色。&lt;br&gt;做客户端的同学，会知道代码中有很多表示颜色的方法，比如&lt;code&gt;rgb(255,255,255)&lt;/code&gt;或者&lt;code&gt;#FFFFFF&lt;/code&gt;。这两种其实是一样的。都是用分别用8位二进制数来表示红、绿、蓝三原色的深度。范围是0-255，数值越大，表示这种颜色越深。&lt;/p&gt;
&lt;p&gt;这种编码叫256色，可以表示256的三次方种颜色。这样的显示器已经足够一般人使用了。&lt;/p&gt;
&lt;p&gt;那我们就可以用三个字节来表示一个像素点的颜色。给每个像素点都写入颜色信息，那显示器就可以用这个信息来绘制图像。&lt;/p&gt;
&lt;p&gt;问题就来了，这些信息要放在哪呢（一个1920*1080的矩阵，每个项目占三个字节）。最自然的当然是放在内存中，但内存和显卡直接的通信成本比较高，因此我们可以在显卡上设置一个专用的存储器，也就是我们常说的显存。显存主要的作用就是存放图像渲染的信息。&lt;/p&gt;
&lt;h4 id=&quot;施乐和Mac&quot;&gt;&lt;a href=&quot;#施乐和Mac&quot; class=&quot;headerlink&quot; title=&quot;施乐和Mac&quot;&gt;&lt;/a&gt;施乐和Mac&lt;/h4&gt;&lt;h4 id=&quot;OOP和图形界面&quot;&gt;&lt;a href=&quot;#OOP和图形界面&quot; class=&quot;headerlink&quot; title=&quot;OOP和图形界面&quot;&gt;&lt;/a&gt;OOP和图形界面&lt;/h4&gt;&lt;h4 id=&quot;图像格式与压缩算法&quot;&gt;&lt;a href=&quot;#图像格式与压缩算法&quot; class=&quot;headerlink&quot; title=&quot;图像格式与压缩算法&quot;&gt;&lt;/a&gt;图像格式与压缩算法&lt;/h4&gt;&lt;h4 id=&quot;模拟-数字转换和多媒体&quot;&gt;&lt;a href=&quot;#模拟-数字转换和多媒体&quot; class=&quot;headerlink&quot; title=&quot;模拟/数字转换和多媒体&quot;&gt;&lt;/a&gt;模拟/数字转换和多媒体&lt;/h4&gt;&lt;h4 id=&quot;互联网&quot;&gt;&lt;a href=&quot;#互联网&quot; class=&quot;headerlink&quot; title=&quot;互联网&quot;&gt;&lt;/a&gt;互联网&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;《编码》这本书被列了入我们团队技术方向培养方案的必读书目，可见这本书的地位。因此，我觉得有必要来撰写一篇导读，来帮助大家看透一些问题，把这本书上的知识和课本中的知识对应起来，并且形成一个体系。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 JSConf China见闻</title>
    <link href="http://yoursite.com/2016/09/07/jsconf2016/"/>
    <id>http://yoursite.com/2016/09/07/jsconf2016/</id>
    <published>2016-09-07T03:29:53.000Z</published>
    <updated>2016-09-07T06:48:26.000Z</updated>
    
    <content type="html">&lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;然而最终的结果只能说是差强人意。真正有干货的主要是Ben Lesh的&lt;a href=&quot;&quot;&gt;RxJS&lt;/a&gt;以及James Kyle的&lt;a href=&quot;&quot;&gt;How to build a complier&lt;/a&gt;，然而恰恰因为他们都是比较活跃的工程师，所以他们这两个演讲我都在youtube上看过了。至于Vue，并没有讲很多的干货，主要还是来圈粉的。&lt;/p&gt;
&lt;p&gt;其他的talk里面，PM2作者的分享还是非常solid的，他当场开源了&lt;a href=&quot;&quot;&gt;grid control&lt;/a&gt;这个项目。朴灵的分享尽管主要是打广告，但是还是要我知道了Node性能调优里内存泄露、CPU占用和GC频繁三个方向。&lt;/p&gt;
&lt;p&gt;WebVR和3D这些，说实话只能做到Demo级别的分享。这也是免不了的，外行只能看热闹。主要是给大家演示一下，如果能有启发就再好不过了。&lt;/p&gt;
&lt;p&gt;不过这次大会上我的确看到了很多微博上关注的圈内人，等以后我在圈子里混熟了，水平更好了。那也许可以来参会和大家聊聊。&lt;/p&gt;
&lt;p&gt;其实FEDay的质量明显要更高一些，尽管有翻译英文演讲这种笑话，但是干货明显更多，整体的技术气氛也更好一些。&lt;/p&gt;
&lt;p&gt;总之，对于国内的技术大会，今后还是要慎重的选择。不然还不如在家看youtube上大神的分享呢。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今年9月3号-4号的JSConf是我第二次参加开发者大会。这次JSConf可以说是被我期待很久的。两天，十多个Topic，来自各大国外公司的大神，Vue、RxJS、WebVR等话题，让我非常期待。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Regular Devtools开发手记</title>
    <link href="http://yoursite.com/2016/07/28/regular-devtools-thought/"/>
    <id>http://yoursite.com/2016/07/28/regular-devtools-thought/</id>
    <published>2016-07-28T07:52:00.000Z</published>
    <updated>2016-08-01T11:00:19.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Chrome-Extension组成&quot;&gt;&lt;a href=&quot;#Chrome-Extension组成&quot; class=&quot;headerlink&quot; title=&quot;Chrome Extension组成&quot;&gt;&lt;/a&gt;Chrome Extension组成&lt;/h3&gt;&lt;p&gt;其实前端开发者们熟悉的Chrome Devtools是用Web技术开发的。验证的方法很简单，如果你把Chrome Devtools设置为单独窗口，然而再按下打开Chrome Devtools的快捷键的话（&lt;code&gt;Control+Shift+I&lt;/code&gt;），你可以开启一个’meta inspecting’，也就是打开第二个开发者工具来检查第一个开发者工具的DOM元素。当然了，如果你熟悉Chrome Devtools团队的一些知名开发者，比如&lt;a href=&quot;https://github.com/addyosmani&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Addy Osmani&lt;/a&gt;和&lt;a href=&quot;https://github.com/paulirish&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paul Irish&lt;/a&gt;的话，你可能对Chrome Devtools是用Web技术开发的这个事实习以为常。正如V8并不是完全的C++实现，有一部分API是JavaScript实现，Chrome的界面也不都是原生的，Hybrid无处不在。&lt;/p&gt;
&lt;p&gt;好了，下面我们来说说Chrome Extension。Chrome Extension其实就是使用Web技术来开发的，只不过和一般的页面不同的是，Chrome Extension的执行环境可以访问到一系列的&lt;code&gt;chrome.*&lt;/code&gt;API。比如用&lt;code&gt;chrome.tabs&lt;/code&gt;API来打开新tab，或者监听和tab有关的一系列事件。完整的API文档在&lt;a href=&quot;https://developer.chrome.com/extensions/api_index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Chrome Extension一般由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI page&lt;/li&gt;
&lt;li&gt;Content Script&lt;/li&gt;
&lt;li&gt;Background Script&lt;/li&gt;
&lt;li&gt;Devtools Panel page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓UI page，就是用户点击导航栏中Extension的图标之后出现的弹出框。这个框是一个HTML页面，包含了Extension的UI逻辑。&lt;/p&gt;
&lt;p&gt;如果你的Extension想要访问当前用户页面的DOM结构，那你必须使用Content Script。Content Script的特点就是，它可以访问当前用户页面的DOM结构，但除此之外，当前用户页面上的&lt;code&gt;window&lt;/code&gt;对象等全局变量以及JavaScript脚本运行后产生的变量都无法访问。Content Script是运行在沙盒中的，它只被允许访问页面的DOM结构。不过Content Script作为Extension的一部分，可以和Background Script通信。&lt;/p&gt;
&lt;p&gt;如果我们把一个Chrome Extension看成一个Web应用，Content Script和UI page可以一起被当做Extension这个应用的View层。&lt;/p&gt;
&lt;p&gt;Background Script，正如名字所示，是Extension运行在后台的一个脚本。这个脚本可以和Content Script通信。&lt;/p&gt;
&lt;p&gt;如果你开发的是一款Chrome Devtools Extension，类似Regular Devtools，那你就需要Devtools Panel page了。这个页面负责在Chrome Devtools里新建tab，并且展示tab中的UI。&lt;/p&gt;
&lt;h3 id=&quot;Regular-Devtools的组成&quot;&gt;&lt;a href=&quot;#Regular-Devtools的组成&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的组成&quot;&gt;&lt;/a&gt;Regular Devtools的组成&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7oxh2b.com1.z0.glb.clouddn.com/Screen%20Shot%202016-07-29%20at%202.28.44%20PM.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;p&gt;Regular Devtools的组成和普通Extension不同之处在于没有UI page，取而代之的是Devtools Panel page。这其实没有太大的区别。只不过UI部分由Devtools Panel page来展现而不是UI page。&lt;/p&gt;
&lt;p&gt;上图是Regular Devtools的大致结构。其中Content Script和Background Script两部分构成Model层，负责数据的搜集和处理。Devtools Panel page则是UI层，负责展现数据。下面我们来讲讲具体的实现。&lt;/p&gt;
&lt;h3 id=&quot;获取Regular组件实例&quot;&gt;&lt;a href=&quot;#获取Regular组件实例&quot; class=&quot;headerlink&quot; title=&quot;获取Regular组件实例&quot;&gt;&lt;/a&gt;获取Regular组件实例&lt;/h3&gt;&lt;p&gt;首先我们需要获得Regular组件实例。这一步的实现思路大致就是在页面中注入一个Event Emitter（在页面所有脚本运行之前），并挂载在全局的&lt;code&gt;window&lt;/code&gt;对象上。然后每一个Regular组件的初始化、更新、销毁等生命周期事件发生时都会在Event Emitter上emit相应的事件，并传入实例。这样我们就可以获取到页面中所有的Regualr组件实例以及相应的其他信息了。&lt;/p&gt;
&lt;p&gt;这个Event Emitter的实现可以参考&lt;/p&gt;
&lt;h3 id=&quot;inject大法&quot;&gt;&lt;a href=&quot;#inject大法&quot; class=&quot;headerlink&quot; title=&quot;inject大法&quot;&gt;&lt;/a&gt;&lt;code&gt;inject&lt;/code&gt;大法&lt;/h3&gt;&lt;p&gt;说起来很简单，可以刚才讲到Content Script时我们说到过，它无法访问用户页面上的全局变量，因此Content Script无法访问到用户页面的&lt;code&gt;window&lt;/code&gt;对象，那我们要如何获取挂载在&lt;code&gt;window&lt;/code&gt;对象上的Regualr组件实例数组呢？&lt;/p&gt;
&lt;p&gt;解决办法很简单，Content Script可以访问用户页面的DOM结构，那我们插入一个&lt;code&gt;script&lt;/code&gt;标签就可以在用户页面的context下执行脚本了。&lt;/p&gt;
&lt;p&gt;比如我们可以实现这样一个&lt;code&gt;inject&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function inject(content) {
    var script = document.createElement(&amp;#39;script&amp;#39;)
    script.textContent = &amp;#39;;(&amp;#39; + content.toString() + &amp;#39;)(window)&amp;#39;
    document.documentElement.appendChild(script)
    script.parentNode.removeChild(script)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;跨页面通信&quot;&gt;&lt;a href=&quot;#跨页面通信&quot; class=&quot;headerlink&quot; title=&quot;跨页面通信&quot;&gt;&lt;/a&gt;跨页面通信&lt;/h3&gt;&lt;p&gt;好了，现在我们在页面中注入的脚本已经获取了当前页面下的Regular的实例，并且在Regular的组件发生更新和销毁事件时，Event Emitter都会收到消息。&lt;/p&gt;
&lt;p&gt;大家可以再看一下上面的架构图，页面中的消息要通过Background Script，再由background script发送到devtools page，展现给用户。那我们要如何进行跨页面通信呢。&lt;/p&gt;
&lt;p&gt;首先一个问题就是，如何将消息从用户页面传送到Content Script，刚才强调了，Content Script是运行在沙盒中的，无法直接访问用户页面中的变量。&lt;/p&gt;
&lt;p&gt;不过，幸运的是，&lt;code&gt;window.postMessage()&lt;/code&gt;方法可以解决这个问题。如果你将&lt;code&gt;.postMessage&lt;/code&gt;方法的&lt;code&gt;targetOrigin&lt;/code&gt;参数设置为&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;，那Content Script就会收到这个消息！&lt;/p&gt;
&lt;p&gt;Content Script与Background Script之间的通信可以使用Chrome Extension提供的API&lt;code&gt;chrome.runtime.connect&lt;/code&gt;和&lt;code&gt;chrome.runtime.sendMessage&lt;/code&gt;进行。Background Script与Devtools Page的通信同理。&lt;/p&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h3&gt;&lt;p&gt;Devtools Page中呈现的UI使用了Regular来打造，这些组件根据页面中传来的消息（数据）而呈现不同的状态。&lt;/p&gt;
&lt;p&gt;要想改善UI组件的性能，首先要减少操作DOM节点的频率，也就是减少组件渲染的次数。&lt;/p&gt;
&lt;p&gt;为此，在注入页面的脚本中，我加入了一个&lt;code&gt;debounce&lt;/code&gt;函数，相信大家都不陌生。实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// debounce helper
    var debounce = function(func, wait, immediate) {
        var timeout; //Why is this set to nothing?
        return function() {
            var context = this,
                args = arguments;
            clearTimeout(timeout); // If timeout was just set to nothing, what can be cleared? 
            timeout = setTimeout(function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            }, wait);
            if (immediate &amp;amp;&amp;amp; !timeout) func.apply(context, args); //This applies the original function to the context and to these arguments?
        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数的作用就是将一段时间内发生的多个事件转化为最后一个，起一个缓冲的作用。&lt;/p&gt;
&lt;p&gt;在用户操作Regular组件的过程中，会频繁的发生组件的初始化，销毁，状态更新等事件。一次操作往往能同时触发多个事件。如果我们不进行debounce，那么Devtools UI会频繁的收到消息，造成短时间内的反复渲染，造成页面的卡顿。&lt;/p&gt;
&lt;p&gt;其实用户的一次操作之后，我们只要在Devtools中渲染其最后一次组件状态更新后的组件状态就可以了。所以加入debounce可以明显改善UI的性能。&lt;/p&gt;
&lt;p&gt;Regular Devtools比较特殊的一点，在于页面间消息传递的是JSON数据，因此每一次UI的状态都是全量替换的。如果我直接全量替换所有UI组件的状态，所有组件都会被重新创建，那性能可想而知是很不理想的。&lt;/p&gt;
&lt;p&gt;而且Regular Devtools的UI组件中除了从用户页面中传来的状态，还有UI组件的本地状态，如果直接全量替换一部分状态，那所有组件都会被重新创建，UI组件的本地状态就无法保留下来了。&lt;/p&gt;
&lt;p&gt;对此我的做法是，对老状态对象和新状态对象进行diff，如果部分状态没有改变，则保留其引用。如果状态改变了，是原始值，则直接替换，如果是对象，则递归diff。这样的结果就是，只更新新老状态中不一样的部分，保留相同的部分。&lt;/p&gt;
&lt;p&gt;这样一来，Devtools的UI中只更新状态变化部分对应的UI，不变的部分则保留原样（因为组件状态的引用没有变）。页面上组件再多也不卡了。&lt;/p&gt;
&lt;h3 id=&quot;来自Chrome-Devtools的黑魔法&quot;&gt;&lt;a href=&quot;#来自Chrome-Devtools的黑魔法&quot; class=&quot;headerlink&quot; title=&quot;来自Chrome Devtools的黑魔法&quot;&gt;&lt;/a&gt;来自Chrome Devtools的黑魔法&lt;/h3&gt;&lt;p&gt;Regular Devtools有一个功能，即DOM节点和Regular组件的双向查找。这个是通过Chrome Console CLI的一个API&lt;code&gt;inspect()&lt;/code&gt;实现的。&lt;/p&gt;
&lt;p&gt;原理很简单，向&lt;code&gt;inspect()&lt;/code&gt;中传入DOM节点，Chrome就会检查那个节点。&lt;/p&gt;
&lt;p&gt;至于检查DOM节点反查Regular组件，则也是通过Chrome Console CLI的&lt;code&gt;$0&lt;/code&gt;变量实现的。Console中的&lt;code&gt;$0&lt;/code&gt;变量指向的是最近检查过的DOM节点。拿到这个DOM节点之后，查找它属于哪个Regular组件便可以了。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;Devtools可以提高我们的开发效率，实在是一个很酷的工具。Regular Devtools目前还只有基本的功能。如果你有更好的想法，欢迎参与到Regular Devtools的开发中来！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Regular-Devtools的前辈们&quot;&gt;&lt;a href=&quot;#Regular-Devtools的前辈们&quot; class=&quot;headerlink&quot; title=&quot;Regular Devtools的前辈们&quot;&gt;&lt;/a&gt;Regular Devtools的前辈们&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gaearon&quot;&gt;Dan Abramov&lt;/a&gt;的&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;Redux Devtools&lt;/a&gt;把前端框架开发者工具推向了主流视野，他在React Europe 2015上的这个&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;演讲&lt;/a&gt;被疯转。Redux Devtools可以说是独领风骚，开启了新一代前端框架开发者工具的潮流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Devtools&lt;/a&gt;也可以算是前开发者工具的祖师爷之一了。React Devtools不但有常用的组件树查看功能，还能直接查看JSX代码，筛选组件，双向修改state，查看组件源码等等。&lt;/p&gt;
&lt;p&gt;而Regular Devtools主要参考的则是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;。Vue Devtools是一个轻量，简洁的Devtools，只实现了开发者工具中最核心的功能。而Vue与Regular在某些方面比较相似，所以Vue Devtools就成为了我开发过程中的一个重要参考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
