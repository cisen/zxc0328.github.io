<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zindex&#39;s blog</title>
  <subtitle>Frontend Rocks</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-05T07:01:58.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zindex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fe-microservice</title>
    <link href="http://yoursite.com/2017/06/05/fe-microservice/"/>
    <id>http://yoursite.com/2017/06/05/fe-microservice/</id>
    <published>2017-06-05T07:01:58.000Z</published>
    <updated>2017-06-05T07:01:58.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>木犀后端开发工作流（2017年6月版）</title>
    <link href="http://yoursite.com/2017/06/05/muxi-be-workflow/"/>
    <id>http://yoursite.com/2017/06/05/muxi-be-workflow/</id>
    <published>2017-06-05T07:01:43.000Z</published>
    <updated>2017-06-19T02:49:36.000Z</updated>
    
    <content type="html">&lt;p&gt;木犀后端的技术经历了一个不断演进的过程，从最初的LNMP式的简单直接的部署方式，到Docker容器部署，到现在的Kubernetes集群部署。相比当年艰难的调试由于操作系统环境不同而导致的各种部署问题，现在的部署流程可以说是相当简单而且可靠的。这也要求我们有一套标准化的开发部署流程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;三个环境&quot;&gt;&lt;a href=&quot;#三个环境&quot; class=&quot;headerlink&quot; title=&quot;三个环境&quot;&gt;&lt;/a&gt;三个环境&lt;/h3&gt;&lt;p&gt;在互联网公司，一个产品一般都部署了好几个版本，比如开发、测试、预发布等等。不同的版本对应开发周期不同时间点的产品状态。QA一般就是在部署好的这些环境中进行发布前测试的。&lt;/p&gt;
&lt;p&gt;我们对环境的要求没有那么高，只要有本地、测试、线上三个环境就可以了。下面分别讲讲从本地开发，到部署测试版本，到新版本上线过程中一系列的标准流程。&lt;/p&gt;
&lt;h3 id=&quot;开发分支与Pull-Request&quot;&gt;&lt;a href=&quot;#开发分支与Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;开发分支与Pull Request&quot;&gt;&lt;/a&gt;开发分支与Pull Request&lt;/h3&gt;&lt;p&gt;本地开发其实没有太多的限制，一般就直接在本地运行代码进行开发。需要注意的是我们的仓库中一般有主分支和开发分支，这个开发分支可以是按版本号，每次新版本时从主分支checkout出来。或者是一个持续使用的开发分支。所有人都&lt;strong&gt;不能直接&lt;/strong&gt;向主分支提交代码。但可以直接向开发分支提交代码。&lt;/p&gt;
&lt;p&gt;如果想讲开发分支中的代码合并到主分支，就要发起一个&lt;strong&gt;Pull Request&lt;/strong&gt;。Pull Request在负责人code review（看情况）以及&lt;strong&gt;CI测试通过&lt;/strong&gt;之后才能merge。&lt;/p&gt;
&lt;h3 id=&quot;单元测试与CI&quot;&gt;&lt;a href=&quot;#单元测试与CI&quot; class=&quot;headerlink&quot; title=&quot;单元测试与CI&quot;&gt;&lt;/a&gt;单元测试与CI&lt;/h3&gt;&lt;p&gt;对于有明确输入输出的后端API来说，单元测试是必要的软件质量保障。也是协助开发的一个手段。&lt;/p&gt;
&lt;p&gt;大家在本地提交代码之前先自己跑过测试，通过之后再提交。Pull Request时还会跑一遍CI，来确保代码功能的正确。&lt;/p&gt;
&lt;p&gt;有一个CI通过的图&lt;/p&gt;
&lt;p&gt;Github上使用的比较多的是Travis CI。Docker based的项目可以参考&lt;a href=&quot;https://github.com/Muxi-X/muxi_site/blob/dev-branch/.travis.yml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个CI配置&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里简单介绍一下CI。CI指持续集成，我们说的CI一般是指云端的CI runner。Travis CI本质上其实就是一个云服务。提供了一个虚拟环境来运行你指定的脚本。Travis支持很多语言环境，但最近Travis支持了Docker，所以环境也就不是问题了。要注意我们写测试时要写清进程exit时的状态码，非0的状态码代表非正常退出。Travis就是根据这个来判断测试或者其他错误是否发生的。这决定了这次CI运行是否成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试环境的具体配置&quot;&gt;&lt;a href=&quot;#测试环境的具体配置&quot; class=&quot;headerlink&quot; title=&quot;测试环境的具体配置&quot;&gt;&lt;/a&gt;测试环境的具体配置&lt;/h3&gt;&lt;p&gt;在开发基本完成，代码merge到主分支之后，我们就可以尝试部署一个测试版本了。测试环境和线上的环境差别不大。测试环境部署在我们的测试集群（几台专有网络阿里云学生机）。&lt;/p&gt;
&lt;p&gt;大家可以随意选一台机器然后部署。部署的时候，除了数据库之外的一般都用Docker部署。如果有多个容器需要部署，我们一般用Docker-compose来一键build&amp;amp;run。&lt;/p&gt;
&lt;p&gt;数据库一般就使用某台机器上直接安装的数据库。在初次部署时大家要记得在容器中执行初始化数据库和用户角色命令（当然也可以写成脚本）。&lt;/p&gt;
&lt;p&gt;测试环境有几个用处，首先是给前端提供联调的API。然后是给产品经理和设计师提供一个线上版本来进行初步测试。因此我们需要给测试环境配置一个域名。但如果直接在DnsPod等等线上解析，要解析的域名数量会很大，很不方便。所以我们采用修改本地hosts文件的办法。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;120.77.8.149 test.share.muxixyz.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意域名是&lt;code&gt;muxixyz.com&lt;/code&gt;的子域名&lt;/strong&gt;，因为阿里云会检测DNS解析的域名是否备案。如果随便写一个域名是不行的（当然理论上你用baidu.com或者其他知名的域名也行）。&lt;/p&gt;
&lt;p&gt;这个hosts文件的配置要写在Github文档中。Tower项目里最好也写一个操作指南文档给设计师和PM看。&lt;/p&gt;
&lt;h3 id=&quot;上线&quot;&gt;&lt;a href=&quot;#上线&quot; class=&quot;headerlink&quot; title=&quot;上线&quot;&gt;&lt;/a&gt;上线&lt;/h3&gt;&lt;p&gt;上线一个版本，比如1.2版。首先在主分支打上这个tag。然后在阿里云的镜像仓库里build这个tag的镜像。&lt;/p&gt;
&lt;p&gt;最后由负责部署的同学，SSH到集群更新Deployment配置文件中的image版本号。升级Deployment即可。&lt;/p&gt;
&lt;p&gt;这一步在将来会由开发应用的同学自行在MAE上操作完成。目前暂时还是需要有人在服务器上部署。开发的同学只要交付镜像就可以了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;相比于之前的工作流，目前的工作流不同的地方主要是，需要写单元测试，PR需要CI通过才能merge，大型的应用必须要部署测试环境并用本地DNS解析访问，进行部署时是用Docker镜像而不是在服务器build。这套工作流需要大家用&lt;strong&gt;微服务&lt;/strong&gt;的观点去看待将来的开发。随着时间的推移，这套工作流也会不断的变化，大致还是朝Cloud Native的方向发展。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;木犀后端的技术经历了一个不断演进的过程，从最初的LNMP式的简单直接的部署方式，到Docker容器部署，到现在的Kubernetes集群部署。相比当年艰难的调试由于操作系统环境不同而导致的各种部署问题，现在的部署流程可以说是相当简单而且可靠的。这也要求我们有一套标准化的开发部署流程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>云端木犀-MAE初步构想</title>
    <link href="http://yoursite.com/2017/05/27/mae/"/>
    <id>http://yoursite.com/2017/05/27/mae/</id>
    <published>2017-05-27T13:29:43.000Z</published>
    <updated>2017-05-28T01:49:49.000Z</updated>
    
    <content type="html">&lt;p&gt;Muxi App Engine，简称MAE，是木犀的私有PaaS方案，也是木犀云的重要组成部分。MAE主要基于Docker和Kubernetes，为木犀所有应用的构建、部署、监控和扩容提供了一个统一的入口，让我们能专注于服务本身的开发。同时MAE也为木犀提供了一套标准化的运维流程，使得团队开发中的工程化程度进一步提高。&lt;/p&gt;
&lt;p&gt;说的这么厉害，那如果你是一个技术小白，我应该如何来解释MAE呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;TD-LR&quot;&gt;&lt;a href=&quot;#TD-LR&quot; class=&quot;headerlink&quot; title=&quot;TD;LR&quot;&gt;&lt;/a&gt;TD;LR&lt;/h3&gt;&lt;p&gt;比如我们有一个应用，华师匣子。华师匣子是由很多的服务构成的，比如成绩服务，课表服务，图书馆服务等等。每个服务都实现了对应的接口。我们使用Docker来运行这些服务。Docker是一种容器技术。我们可以简单的理解为一种沙盒环境。这些容器的存在，已经很大程度上方便了我们的部署。因为容器可以实现系统资源的隔离，使得服务器上可以同时运行很多不同的服务，而相互不打扰。&lt;/p&gt;
&lt;p&gt;但手动部署容器，还是太复杂了。我们要登录服务器手动部署容器。容器如果出现问题，我们也需要亲自去重启。如果我们需要横向拓展，部署多个相同的容器以应对高负载，也需要一个个去手动部署。这个时候就需要一个调度者来帮我们自动完成这个任务。&lt;/p&gt;
&lt;p&gt;我们可以把MAE理解为容器的调度者。我们在MAE中新建一个应用和下属的服务，填写相关的信息。比如我们只要提供Docker镜像的地址，就可以一键部署。MAE会帮我们将容器部署到合适的服务器上。如果容器因为某些原因崩溃了，MAE会自动重启容器。如果我们需要横向拓展，那只要在控制台里填写一下需要拓展的数量就可以了。如果需要更新代码，我们只需要提供镜像的新版本号，MAE会自动终止旧版本的容器，新建新版本的容器。一切都是这么简单。可以自动化的事情，我们都会做到自动化。&lt;/p&gt;
&lt;p&gt;MAE提供Web UI和CLI。Web UI主要用于日常的使用以及查看监控数据。CLI适合在shell脚本等自动化环境下使用。&lt;/p&gt;
&lt;p&gt;MAE带来的最大变革是，今后我们的应用从一开始就应该按Cloud Native的思路去编写。要拥抱云计算，我们必须编写Cloud Native的应用，具体的说，使用微服务架构，写无状态的功能单元，容器技术，将数据库等等持久化的组件作为单独的部分等等，都是Cloud Native的体现。只有这样，我们的应用才能和目前公有云和私有云的基础设施完美结合。&lt;/p&gt;
&lt;p&gt;下面就是纯粹的技术讨论了，请耐心阅读。&lt;/p&gt;
&lt;h3 id=&quot;MAE的技术选型&quot;&gt;&lt;a href=&quot;#MAE的技术选型&quot; class=&quot;headerlink&quot; title=&quot;MAE的技术选型&quot;&gt;&lt;/a&gt;MAE的技术选型&lt;/h3&gt;&lt;p&gt;简单的说，就是Docker和Kubernetes。Docker是容器技术的实现，Kubernetes主要提供了容器编排管理的功能。上一节中说到的大部分自动化功能，都是Kubernetes实现的。MAE中需要我们研发的主要是MAE API服务、Web UI还有CLI程序。除了这些，还有就是在MAE中实现一套最适合我们的&lt;strong&gt;对应用的抽象&lt;/strong&gt;。这套抽象是非常重要的。Kubernetes的概念并不是所有人都可以理解的，也没有必要对使用者暴露最底层的概念。PaaS的用户是从是应用和服务这些逻辑上的概念去看待问题的。所以MAE就提供了针对应用和服务的抽象，并且和Kubernetes整合起来。&lt;/p&gt;
&lt;h3 id=&quot;MAE的组成部分&quot;&gt;&lt;a href=&quot;#MAE的组成部分&quot; class=&quot;headerlink&quot; title=&quot;MAE的组成部分&quot;&gt;&lt;/a&gt;MAE的组成部分&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/large/64c45edcly1fg0dnygziij212a0ue4e7.jpg&quot; alt=&quot;mae parts&quot;&gt;&lt;/p&gt;
&lt;p&gt;MAE的组成，从上到下，大致有三层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MAE服务层&lt;/strong&gt; MAE服务层是暴露给用户的一些服务。MAE API Server是MAE是中枢。负责和底层的集群通信，保存应用配置等等。MAE Web UI提供了一个Web界面，用户可以通过Web UI对MAE发出指令，查看监控数据。MAE CLI是一个命令行程序，提供了从命令行和API Server通信的渠道。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑应用层&lt;/strong&gt; 这一层是抽象的应用层。也就是我们概念上的应用。因为实际的集群中是没有应用概念的（当然Kubernetes的Services+Namespace已经非常接近了），所以我们需要在这里提供对应的抽象。我们可以在MAE中新建应用，然后配置这个应用对应的服务。MAE中的服务（以后简称MAE服务，区别于Kubernetes Service），其实就对应一个微服务。一个应用由至少一个微服务构成。MAE服务是用户可以控制的部署的最小单元。我们可以对某个MAE服务单独进行拓展。比较特殊的MAE服务就是Nginx入口服务，这个服务为所有应用提供反向代理，同时也作为一个MAE下的服务，被MAE部署。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes层&lt;/strong&gt; Kubernetes这层就是底层的实现层了。包括了Service，Deployment和Pods。其中Service和Deployment在上层共同支撑了MAE服务。Pods则属于最底层的调度单元。在MAE层是完全不可见的。一个Pod由至少一个容器构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MAE的流量分发&quot;&gt;&lt;a href=&quot;#MAE的流量分发&quot; class=&quot;headerlink&quot; title=&quot;MAE的流量分发&quot;&gt;&lt;/a&gt;MAE的流量分发&lt;/h3&gt;&lt;p&gt;那么作为一个分布式系统，一个用户的请求究竟是经过怎样的路径，到达最底层的Kubernetes Pod的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/large/64c45edcly1fg0etf4yg9j20ku0r4k1f.jpg&quot; alt=&quot;mae request&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先DNS把域名解析到Kubernetes的Master节点的公网IP上，然后部署在Master节点上的Nginx入口服务接管，Nginx根据MAE应用设置的域名和URL规则，将这个请求转发到对应应用的某个服务上。Kubernetes的服务都是可以通过&lt;code&gt;&amp;lt;Master内网IP&amp;gt;:&amp;lt;Service Port&amp;gt;&lt;/code&gt;来进行访问的。然后Kubernetes proxy用iptables规则，将请求转发到某个节点上的Pod。&lt;/p&gt;
&lt;p&gt;由于Kubernetes proxy提供了均衡负载，我们不用再操心如何分配流量到服务下属的多个Pod中的某一个这样的问题。今后可以做的优化是，实现Kubernetes Master节点的高可用，也就是同时部署多个Master节点。这样的话就需要在Master节点之上再实现一个均衡负载。&lt;/p&gt;
&lt;h3 id=&quot;MAE的实现细节&quot;&gt;&lt;a href=&quot;#MAE的实现细节&quot; class=&quot;headerlink&quot; title=&quot;MAE的实现细节&quot;&gt;&lt;/a&gt;MAE的实现细节&lt;/h3&gt;&lt;p&gt;MAE做的抽象，一个是应用，应用之下是服务。对于这两个抽象，应该各自保存一些什么样的数据，这属于MAE的实现细节。&lt;/p&gt;
&lt;p&gt;每个应用需要的信息有，应用名，域名，Nginx转发规则，应用下属的服务列表。&lt;/p&gt;
&lt;p&gt;每个服务需要的信息有：服务名，当前镜像版本，镜像仓库地址，Github仓库地址，Kubernetes Service和Deployment需要的全部信息，当前服务属于哪个应用，授权管理当前服务的用户列表。&lt;/p&gt;
&lt;p&gt;因为服务是部署的最小单元，因此相对来说服务是MAE中比较核心的一个部分。MAE需要将数据库中保存的服务信息，自动转化为Kubernetes需要的&lt;code&gt;.yaml&lt;/code&gt;文件。将数据库中保存的应用信息，自动转化为nginx的配置文件。这是实现上需要去考虑的一个问题。&lt;/p&gt;
&lt;p&gt;另外，现在还需要仔细考虑的一点，&lt;strong&gt;MAE在全局/应用/服务这几个层面分别需要哪些监控数据&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;MAE时代的部署工作流&quot;&gt;&lt;a href=&quot;#MAE时代的部署工作流&quot; class=&quot;headerlink&quot; title=&quot;MAE时代的部署工作流&quot;&gt;&lt;/a&gt;MAE时代的部署工作流&lt;/h3&gt;&lt;p&gt;部署服务之前，首先我们要构建镜像（构建之前可以引入CI，测试通过才可以构建镜像）。给镜像打上版本号，然后发布到云端的镜像仓库（可以用阿里云/蜂巢/Daocloud）。之后我们就可以在MAE中为某个服务新建一次部署了，填上新的版本号，点击部署，就启动了一次部署了。得益于Kubernetes超强的部署能力，我们可以回滚、暂停、继续每一次部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/64c45edcly1fg0era6a66j214q0mmwoc.jpg&quot; alt=&quot;mae deployment&quot;&gt;&lt;/p&gt;
&lt;p&gt;MAE的API Server把服务目前的配置转换为&lt;code&gt;.yaml&lt;/code&gt;格式，向Kubernetes API Server发送请求。然后Kubernetes会进行相应的处理。和Service相关的就调整Service，和Deployment相关的就调整Deployment。最终服务更新到目标状态，部署完成。&lt;/p&gt;
&lt;h3 id=&quot;MAE的物理节点组成&quot;&gt;&lt;a href=&quot;#MAE的物理节点组成&quot; class=&quot;headerlink&quot; title=&quot;MAE的物理节点组成&quot;&gt;&lt;/a&gt;MAE的物理节点组成&lt;/h3&gt;&lt;p&gt;MAE的逻辑组成已经介绍了，那MAE和具体的云主机之间是什么关系呢。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/64c45edcly1fg0ftnkesej213a0o07g6.jpg&quot; alt=&quot;mae nodes&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中的一个框对应一台云主机。其中Master节点目前只打算部署在一台机器上。今后会做高可用（具体要看kubeadm的支持情况，自己部署HA也是可以的，参见&lt;a href=&quot;http://tonybai.com/2017/05/15/setup-a-ha-kubernetes-cluster-based-on-kubeadm-part1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;）。Kubernetes Node是负载Pod调度的机器，也就是分布式系统主从节点中的Slave节点。Kubernetes的Pod可能会被调度到其中任意一台机器上。因此应用在物理上运行在哪个节点，在MAE中并没有太多的意义。&lt;/p&gt;
&lt;p&gt;MAE的Server在理论上会单独部署在一台服务器上，MAE Server如果出现问题，其实并不影响当前集群的正常运转。Kubernetes的Master节点才是真正负责调度和管理的，因此才会有做高可用的打算。&lt;/p&gt;
&lt;h3 id=&quot;MAE时代的前端服务化&quot;&gt;&lt;a href=&quot;#MAE时代的前端服务化&quot; class=&quot;headerlink&quot; title=&quot;MAE时代的前端服务化&quot;&gt;&lt;/a&gt;MAE时代的前端服务化&lt;/h3&gt;&lt;p&gt;MAE要求一个应用由几个服务构成。这给了我们一个机会，去改进目前的前端代码部署流程。目前的前端代码是放在后端容器中部署的。每次部署需要后端工程师参与，或者使用配置复杂的Webhook。前端代码部署时需要重启后端容器，因此无法实现无副作用的前端部署。MAE架构下，我们将前端作为一个单独的服务。这个服务主要接受的是从Nginx入口服务转发而来的需要返回HTML的请求，也就是我们一般所说的View层，或者说同步路由层。技术上我们选用Nodejs来实现前端的服务。&lt;/p&gt;
&lt;p&gt;所以今后前端工程师的产出就是前端代码以及Nodejs服务端代码（主要是路由）。两者在同一个仓库中，部署在同一个容器中。&lt;/p&gt;
&lt;p&gt;这样的好处是，前端代码部署时只需要构建前端服务的镜像，然后在MAE单独部署就可以了。和后端完全解耦。前端工程师也可以借助MAE提供的强大的运维能力，来优化自己的工作流。&lt;/p&gt;
&lt;p&gt;前端工程师接管View层，给我们的应用带来了更大的可能性。服务端渲染前端组件变成了非常自然的选择。前端工程师控制的范围扩大，提供了更多发挥的空间。比如前端工程师可以对静态资源缓存，CSRF等等进行更好的控制。&lt;/p&gt;
&lt;h3 id=&quot;MAE的主要API以及CLI工具命令&quot;&gt;&lt;a href=&quot;#MAE的主要API以及CLI工具命令&quot; class=&quot;headerlink&quot; title=&quot;MAE的主要API以及CLI工具命令&quot;&gt;&lt;/a&gt;MAE的主要API以及CLI工具命令&lt;/h3&gt;&lt;p&gt;API在Web UI框架确定之后就可以比较清楚的写成文档了，这里只列一下主要的API。&lt;/p&gt;
&lt;h4 id=&quot;应用层API&quot;&gt;&lt;a href=&quot;#应用层API&quot; class=&quot;headerlink&quot; title=&quot;应用层API&quot;&gt;&lt;/a&gt;应用层API&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;应用列表/信息&lt;/li&gt;
&lt;li&gt;应用网络配置更新&lt;/li&gt;
&lt;li&gt;监控信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;服务层API&quot;&gt;&lt;a href=&quot;#服务层API&quot; class=&quot;headerlink&quot; title=&quot;服务层API&quot;&gt;&lt;/a&gt;服务层API&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;服务列表/信息&lt;/li&gt;
&lt;li&gt;部署服务新版本&lt;/li&gt;
&lt;li&gt;横向拓展服务&lt;/li&gt;
&lt;li&gt;回滚、暂停部署&lt;/li&gt;
&lt;li&gt;监控信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;CLI&quot;&gt;&lt;a href=&quot;#CLI&quot; class=&quot;headerlink&quot; title=&quot;CLI&quot;&gt;&lt;/a&gt;CLI&lt;/h4&gt;&lt;p&gt;CLI提供了和主要API对应的命令。命令需要验证的话，可以通过&lt;code&gt;mae login&lt;/code&gt;这样的命令来进行。&lt;/p&gt;
&lt;h3 id=&quot;木犀云的其他产品展望&quot;&gt;&lt;a href=&quot;#木犀云的其他产品展望&quot; class=&quot;headerlink&quot; title=&quot;木犀云的其他产品展望&quot;&gt;&lt;/a&gt;木犀云的其他产品展望&lt;/h3&gt;&lt;h4 id=&quot;Muxi-Database-Service-MDS&quot;&gt;&lt;a href=&quot;#Muxi-Database-Service-MDS&quot; class=&quot;headerlink&quot; title=&quot;Muxi Database Service(MDS)&quot;&gt;&lt;/a&gt;Muxi Database Service(MDS)&lt;/h4&gt;&lt;p&gt;提供Mongo，Redis等云数据库服务。实现了数据自动备份，多节点高可用等特性。&lt;/p&gt;
&lt;h4 id=&quot;Muxi-Storage-Service-MSS&quot;&gt;&lt;a href=&quot;#Muxi-Storage-Service-MSS&quot; class=&quot;headerlink&quot; title=&quot;Muxi Storage Service(MSS)&quot;&gt;&lt;/a&gt;Muxi Storage Service(MSS)&lt;/h4&gt;&lt;p&gt;基于Ceph的分布式对象存储。负责大文件的存储。比如图片、文档等。&lt;/p&gt;
&lt;h4 id=&quot;鹊桥&quot;&gt;&lt;a href=&quot;#鹊桥&quot; class=&quot;headerlink&quot; title=&quot;鹊桥&quot;&gt;&lt;/a&gt;鹊桥&lt;/h4&gt;&lt;p&gt;木犀接口管理平台。提供了接口的云端管理和Mock服务。&lt;/p&gt;
&lt;h4 id=&quot;Muxi-UI-MUI&quot;&gt;&lt;a href=&quot;#Muxi-UI-MUI&quot; class=&quot;headerlink&quot; title=&quot;Muxi UI(MUI)&quot;&gt;&lt;/a&gt;Muxi UI(MUI)&lt;/h4&gt;&lt;p&gt;基于Vuejs的UI组件库。适用于中后台前端应用的快速开发。&lt;/p&gt;
&lt;h3 id=&quot;写在最后-Why-Cloud&quot;&gt;&lt;a href=&quot;#写在最后-Why-Cloud&quot; class=&quot;headerlink&quot; title=&quot;写在最后: Why Cloud?&quot;&gt;&lt;/a&gt;写在最后: Why Cloud?&lt;/h3&gt;&lt;p&gt;为什么木犀要拥抱云计算？为什么我们要自建私有PaaS平台？&lt;/p&gt;
&lt;p&gt;首先，在当下，计算能力，已经和水电煤一样，成为了一种基础设施。作为小团队，使用现成的基础设施，从成本上以及灵活性上都是最佳的。&lt;/p&gt;
&lt;p&gt;虽然我们使用了IaaS服务，但我们还是可以把云主机当做物理主机来使用，我们完全可以实施云计算出现之前时代的传统运维。运维工程师负责服务器的环境，开发工程师把代码交给运维工程师部署。数据库等服务和业务逻辑部署在同一台机器上，等等等等。很明显，坚持这种做法，将云计算理解为虚拟主机，是非常不明智的。&lt;/p&gt;
&lt;p&gt;既然已经用上了IaaS，那就要利用现有的微服务理论和Docker等等容器技术，打造更加原生的云端体验。我们将代码拆成一个一个单元，将有状态和无状态的服务分离。部署时容器让我们不用在意服务端的环境隔离。Kubernetes让我们不用手动管理容器的生命周期。&lt;/p&gt;
&lt;p&gt;开发MAE是为了解决目前团队部署流程中存在的问题。自建的PaaS平台可以最大程度提供个性化的使用体验。也给我们机会去对Kubernetes等开源技术进行探索和研究，并且用到生产环境之中。&lt;/p&gt;
&lt;p&gt;围绕木犀云而进行的一系列的研究，是木犀拥抱云计算的最好方式。我们不仅要享受云计算的好处，同时也要参与其中，深入的理解技术细节。相信未来我们在云计算上的发展会有无限的可能。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Muxi App Engine，简称MAE，是木犀的私有PaaS方案，也是木犀云的重要组成部分。MAE主要基于Docker和Kubernetes，为木犀所有应用的构建、部署、监控和扩容提供了一个统一的入口，让我们能专注于服务本身的开发。同时MAE也为木犀提供了一套标准化的运维流程，使得团队开发中的工程化程度进一步提高。&lt;/p&gt;
&lt;p&gt;说的这么厉害，那如果你是一个技术小白，我应该如何来解释MAE呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Kubeadm 1.6部署Kubernetes</title>
    <link href="http://yoursite.com/2017/05/24/k8s-setup/"/>
    <id>http://yoursite.com/2017/05/24/k8s-setup/</id>
    <published>2017-05-24T11:52:27.000Z</published>
    <updated>2017-06-10T18:05:54.000Z</updated>
    
    <content type="html">&lt;p&gt;本文介绍了如何用Kubeadm 1.6版在Ubuntu 16.04系统上快速部署一个Kubernetes集群。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;阿里云ECS 华南1 可用区A Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-63-generic x86_64) 专有网络&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;配置&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;内网IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MASTER&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 CPU 1GB RAM&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;172.18.214.46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Node&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 CPU 2GB RAM&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;172.18.214.47&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;依赖安装-amp-amp-代理设置&quot;&gt;&lt;a href=&quot;#依赖安装-amp-amp-代理设置&quot; class=&quot;headerlink&quot; title=&quot;依赖安装&amp;amp;&amp;amp;代理设置&quot;&gt;&lt;/a&gt;依赖安装&amp;amp;&amp;amp;代理设置&lt;/h3&gt;&lt;p&gt;首先要在两个节点都安装Docker和Kubernetes相关的组件。因为相关的镜像都在墙外，所以这里需要挂代理或者自行寻找墙内的源。笔者选择的是挂代理的方案，给Ubuntu配置HTTP代理可以参考&lt;a href=&quot;http://dearmadman.com/2015/08/30/use-shadowsocks-in-ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;。给Docker配置代理可以参考&lt;a href=&quot;https://docs.docker.com/engine/admin/systemd/#httphttps-proxy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装的步骤是按照官网的文档&lt;a href=&quot;https://kubernetes.io/docs/getting-started-guides/kubeadm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt;来的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 升级包管理的镜像列表
apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
# 将docker和kubernetes相关的镜像源加入列表
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
apt-get update
# 安装docker和kubernetes相关组件
apt-get install -y docker-engine
apt-get install -y kubelet kubeadm kubectl kubernetes-cni
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;在MASTER节点运行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubeadm init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果一切正常，最后会有如下的输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Your Kubernetes master has initialized successfully!

To start using your cluster, you need to run (as a regular user):

  sudo cp /etc/kubernetes/admin.conf $HOME/
  sudo chown $(id -u):$(id -g) $HOME/admin.conf
  export KUBECONFIG=$HOME/admin.conf

You should now deploy a pod network to the cluster.
Run &amp;quot;kubectl apply -f [podnetwork].yaml&amp;quot; with one of the options listed at:
  http://kubernetes.io/docs/admin/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join --token 67e1ac.eac65cabb7d2801c 172.18.214.46:6443
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置环境变量&quot;&gt;&lt;a href=&quot;#设置环境变量&quot; class=&quot;headerlink&quot; title=&quot;设置环境变量&quot;&gt;&lt;/a&gt;设置环境变量&lt;/h3&gt;&lt;p&gt;上一步中kubeadm会生成配置文件，输出的消息中要求我们设置环境变量&lt;code&gt;KUBECONFIG&lt;/code&gt;为配置文件的路径。以便后续的使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo cp /etc/kubernetes/admin.conf $HOME/
sudo chown $(id -u):$(id -g) $HOME/admin.conf
export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Pod网络设置：weaver&quot;&gt;&lt;a href=&quot;#Pod网络设置：weaver&quot; class=&quot;headerlink&quot; title=&quot;Pod网络设置：weaver&quot;&gt;&lt;/a&gt;Pod网络设置：weaver&lt;/h3&gt;&lt;p&gt;到这里，我们已经初始化了一个单节点的Kubernetes集群。要想在集群中加入真正负载应用的Node，我们需要初始化一个Overlay Network。&lt;/p&gt;
&lt;p&gt;Overlay Network的选择有很多，比如Flannel和Calico。但经过我个人的踩坑和&lt;a href=&quot;http://tonybai.com/2016/12/30/install-kubernetes-on-ubuntu-with-kubeadm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考博客&lt;/a&gt;后，最终选择了weaver。&lt;/p&gt;
&lt;p&gt;在Master节点运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://git.io/weave-kube-1.6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;稍候片刻，运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods -o wide --all-namespaces
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看pods的运行情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAMESPACE     NAME                                              READY     STATUS    RESTARTS   AGE       IP              NODE
kube-system   etcd-izwz9ap4sedl64wboiyh6cz                      1/1       Running   0          55m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
kube-system   kube-apiserver-izwz9ap4sedl64wboiyh6cz            1/1       Running   0          54m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
kube-system   kube-controller-manager-izwz9ap4sedl64wboiyh6cz   1/1       Running   0          55m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
kube-system   kube-dns-3913472980-l8ghd                         3/3       Running   0          55m       10.32.0.2       izwz9ap4sedl64wboiyh6cz
kube-system   kube-proxy-n5332                                  1/1       Running   0          55m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
kube-system   kube-scheduler-izwz9ap4sedl64wboiyh6cz            1/1       Running   0          54m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
kube-system   weave-net-l86wx                                   2/2       Running   0          48m       172.18.214.46   izwz9ap4sedl64wboiyh6cz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果weave-net和kube-dns这两个pod都处于Running的状态。说明网络初始化成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;weave-net如果出现CrashLoopBackOff的错误，可以参考&lt;a href=&quot;http://tonybai.com/2016/12/30/install-kubernetes-on-ubuntu-with-kubeadm-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;加入Node&quot;&gt;&lt;a href=&quot;#加入Node&quot; class=&quot;headerlink&quot; title=&quot;加入Node&quot;&gt;&lt;/a&gt;加入Node&lt;/h3&gt;&lt;p&gt;在Node上运行之前Master上输出的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubeadm join --token 67e1ac.eac65cabb7d2801c 172.18.214.46:6443
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置配置文件路径的环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export KUBECONFIG=/etc/kubernetes/kubelet.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;稍后，查看Node的运行情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get nodes

NAME                      STATUS    AGE       VERSION
izwz9972b5w4h8a4f1h9z7z   Ready     2h        v1.6.4
izwz9ap4sedl64wboiyh6cz   Ready     4h        v1.6.4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个节点都显示Ready，说明加入成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况Master是不承担负载的，如果要Master节点也参与Pod调度，可以运行&lt;code&gt;kubectl taint nodes --all node-role.kubernetes.io/master-&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;示例应用&quot;&gt;&lt;a href=&quot;#示例应用&quot; class=&quot;headerlink&quot; title=&quot;示例应用&quot;&gt;&lt;/a&gt;示例应用&lt;/h3&gt;&lt;p&gt;节点部署就绪，我们来试着部署一个应用吧：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create namespace sock-shop
kubectl apply -n sock-shop -f &amp;quot;https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两行命令会部署sock-shop相关的deployment和service。这些service共同组成了一个逻辑上的袜子商店网站。&lt;/p&gt;
&lt;p&gt;等所有Pods都是Running状态了，我们可以运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n sock-shop get svc front-end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看front-end服务的端口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
front-end   10.103.179.228   &amp;lt;nodes&amp;gt;       80:30001/TCP   1h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;端口是30001，然后我们就可以用&lt;code&gt;http://&amp;lt;MASTER_IP&amp;gt;:30001&lt;/code&gt;来访问服务了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/64c45edcly1ffysdi2jjfj21kw0yhnpe.jpg&quot; alt=&quot;socks-shop&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看和升级部署&quot;&gt;&lt;a href=&quot;#查看和升级部署&quot; class=&quot;headerlink&quot; title=&quot;查看和升级部署&quot;&gt;&lt;/a&gt;查看和升级部署&lt;/h3&gt;&lt;p&gt;在任意节点运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get depolyment --all-namespaces
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到当前的depolyment：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAMESPACE     NAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kube-system   kube-dns       1         1         1            1           3h
sock-shop     carts          1         1         1            1           1h
sock-shop     carts-db       1         1         1            1           1h
sock-shop     catalogue      1         1         1            1           1h
sock-shop     catalogue-db   1         1         1            1           1h
sock-shop     front-end      1         1         1            1           1h
sock-shop     orders         1         1         1            1           1h
sock-shop     orders-db      1         1         1            1           1h
sock-shop     payment        1         1         1            1           1h
sock-shop     queue-master   1         1         1            1           1h
sock-shop     rabbitmq       1         1         1            1           1h
sock-shop     shipping       1         1         1            1           1h
sock-shop     user           1         1         1            1           1h
sock-shop     user-db        1         1         1            1           1h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们想将其中一个服务横向拓展，比如payment服务，我们只需要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl --namespace=sock-shop scale deployment payment --replicas 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个新的payment pod就被初始化，并被分配到合适的节点上运行。&lt;/p&gt;
&lt;p&gt;关于更多deployment相关的更新、回滚的信息请参考&lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;#一些思考&quot; class=&quot;headerlink&quot; title=&quot;一些思考&quot;&gt;&lt;/a&gt;一些思考&lt;/h3&gt;&lt;p&gt;Kubernetes相对来说还是很容易上手的一个容器集群管理方案。只要我们开发的时候是按cloud native的思路去写，部署就是一件非常简单的事情。可以说几个配置文件就搞定了。Kubernetes接管了部署的更新和回滚，让运维变的轻松、可靠。比如部署的时候不会在新容器没有启动之前就终止旧容器。如果部署出了问题需要回滚，也可以进行一键式的回滚。部署也可以暂定，继续。这样的一套方案相比于手动管理容器，简直就是鸟枪换炮式的升级。&lt;/p&gt;
&lt;p&gt;不仅仅是后端服务，我们的前端代码，也应该融入这套体系之中。前端作为一个单独的服务部署。这样可以更好的解耦。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了如何用Kubeadm 1.6版在Ubuntu 16.04系统上快速部署一个Kubernetes集群。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Travis CI和Github的前端云构建</title>
    <link href="http://yoursite.com/2017/05/22/fe-cloud-building/"/>
    <id>http://yoursite.com/2017/05/22/fe-cloud-building/</id>
    <published>2017-05-22T08:04:00.000Z</published>
    <updated>2017-05-22T12:05:50.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在思考团队里前端代码部署的问题，之前采用的方案是在本地构建，推到Github上一个专门放build后前端代码的仓库，然后Github的Webhook去触发后端的部署逻辑。代码就从这个仓库里拉取。&lt;/p&gt;
&lt;p&gt;这种方案看起来没什么大问题，但总觉得比较awkward。首先这套方案不够自动化，需要大量的人工操作。然后Github的Webhook其实并不是特别好用，如果后期要和我们内部的私有云平台对接起来，还要经过一些桥接才可以。&lt;/p&gt;
&lt;p&gt;本来呢，因为最近学了docker的缘故，我想写一个简单的Node服务，用来自动构建代码，然后通知服务端部署。每个应用就是一个单独的容器，这样环境就可以隔离。这个方案想来也不错。直到我仔细研究了一下Travis CI，才发现这个CI真是不简单。云端构建的任务用Travis CI就可以完美的实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;关于CI&quot;&gt;&lt;a href=&quot;#关于CI&quot; class=&quot;headerlink&quot; title=&quot;关于CI&quot;&gt;&lt;/a&gt;关于CI&lt;/h3&gt;&lt;p&gt;CI是持续集成的意思，持续集成里主要包括构建和测试代码。之前对Travis CI的印象是可以跑测试，仔细看了之后才发现Travis CI其实是一个云服务，提供了一个虚拟的Linux环境。你可以运行自定义的脚本。这个Linux环境的自由度还是非常大的。对于前端构建来说，Travis CI的网络环境可以快速安装npm包，这是一个非常大的优势。&lt;/p&gt;
&lt;h3 id=&quot;travis-yml文件&quot;&gt;&lt;a href=&quot;#travis-yml文件&quot; class=&quot;headerlink&quot; title=&quot;.travis.yml文件&quot;&gt;&lt;/a&gt;&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/h3&gt;&lt;p&gt;Travis CI的配置文件其实就是让你写几个生命周期hook，内容一般是shell命令。比如&lt;code&gt;install&lt;/code&gt;这个hook里主要写一些安装依赖的逻辑，&lt;code&gt;script&lt;/code&gt;这个hook里主要是写测试和构建的逻辑，&lt;code&gt;deploy&lt;/code&gt;这个hook里是写部署的逻辑。另外这几个hook都有各自的&lt;code&gt;before&lt;/code&gt;和&lt;code&gt;after&lt;/code&gt;版本。总而言之自由度是很大的。&lt;/p&gt;
&lt;p&gt;一个示例&lt;code&gt;.travis.yml&lt;/code&gt;文件。虽然我们不能直接&lt;code&gt;.travis.yml&lt;/code&gt;中写逻辑，但我们可以运行任意的脚本，所以可以看出&lt;code&gt;.travis.yml&lt;/code&gt;的能力基本等价于shell脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;language: node_js
node_js:
  - &amp;quot;7&amp;quot;
install:
  - npm install
script:
  - npm run build
after_script:
  - tar -cvf bundle.tar ./dist
  - node deploy.js
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;云端构建&quot;&gt;&lt;a href=&quot;#云端构建&quot; class=&quot;headerlink&quot; title=&quot;云端构建&quot;&gt;&lt;/a&gt;云端构建&lt;/h3&gt;&lt;p&gt;在看过了上节的&lt;code&gt;.travis.yml&lt;/code&gt;文件之后，云端构建的大致逻辑应该已经非常清楚了。我们在Travis CI的虚拟机中安装node依赖，build代码，压缩代码，然后运行一个js脚本。这个脚本的内容就是将代码上传到CDN。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deploy.js&lt;/code&gt;中还可以向后端的平台发送部署的请求，以达到自动部署的目的。如果后端是分布式的架构，向管理的节点发送请求即可。&lt;/p&gt;
&lt;h3 id=&quot;一些展望&quot;&gt;&lt;a href=&quot;#一些展望&quot; class=&quot;headerlink&quot; title=&quot;一些展望&quot;&gt;&lt;/a&gt;一些展望&lt;/h3&gt;&lt;p&gt;Travis CI的能力取决于这个虚拟机里提供了怎样的环境。Travis CI支持docker，因此我们可以用Travis CI进行docker镜像的构建和上传。Travis CI支持Nodejs，因此我们可以在虚拟机中安装hexo，进行博客的云端构建和自动部署。云端的构建，由于保证环境的隔离，因此稳定性会比本地高。以上都是Travis CI可能的用途。Travis CI作为一个云服务，在运维方面，还有无限的可能性等我们去探索&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在思考团队里前端代码部署的问题，之前采用的方案是在本地构建，推到Github上一个专门放build后前端代码的仓库，然后Github的Webhook去触发后端的部署逻辑。代码就从这个仓库里拉取。&lt;/p&gt;
&lt;p&gt;这种方案看起来没什么大问题，但总觉得比较awkward。首先这套方案不够自动化，需要大量的人工操作。然后Github的Webhook其实并不是特别好用，如果后期要和我们内部的私有云平台对接起来，还要经过一些桥接才可以。&lt;/p&gt;
&lt;p&gt;本来呢，因为最近学了docker的缘故，我想写一个简单的Node服务，用来自动构建代码，然后通知服务端部署。每个应用就是一个单独的容器，这样环境就可以隔离。这个方案想来也不错。直到我仔细研究了一下Travis CI，才发现这个CI真是不简单。云端构建的任务用Travis CI就可以完美的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《编程语言实现模式》-阅读笔记</title>
    <link href="http://yoursite.com/2017/03/30/lip-notes/"/>
    <id>http://yoursite.com/2017/03/30/lip-notes/</id>
    <published>2017-03-30T13:34:59.000Z</published>
    <updated>2017-03-31T13:43:42.000Z</updated>
    
    <content type="html">&lt;p&gt;这里记录一下我阅读《编程语言实现模式》这本书的一些感受。一开始，对于编译原理，我的印象是这门课非常的艰深。在正式学习之前其实我已经看了很多编译相关的东西，比如V8，以及前端模板引擎等等。当时的感觉就是十分神奇。上了课之后首先接触的是形式文法、自动机和正规表达式等等。我的感觉就是，这些东西，是如何被前端大神们运用来写相关框架的呢，完全看不出门路嘛！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Jame Kyle的分享—&lt;a href=&quot;https://www.youtube.com/watch?v=Tar4WgAfMr4&amp;amp;t=9s&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《How to write a compiler》&lt;/a&gt;虽然很好，但是和有实际运用价值的编译技能还差的远呢。&lt;/p&gt;
&lt;p&gt;看龙书看的欲哭无泪，后来转而看《自制编程语言》，把crowbar的代码和流程大概了解了一下。最大的收获就是了解了yacc和lex。此前我对于Lexer和Parser还是抱有一定的恐惧心理的。&lt;/p&gt;
&lt;p&gt;最终让我认清门路的是戴嘉华的&lt;a href=&quot;https://github.com/livoras/blog/issues/14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;。后来我去翻了翻编译原理课本，让我彻底搞清楚几个事情：&lt;/p&gt;
&lt;p&gt;第一点，虽然波神说的很对，最关键的是动手去写，但了解必要的理论是很重要的。问题就在于，编译这边理论很多，类似有限自动机和正规表达式的转换等等知识，后端代码生成和优化等等，会加重认知的负担。所以关键就是，对于一个普通的工程师来说，开发文本处理或者DSL相关程序需要掌握的编译原理知识是哪些。&lt;/p&gt;
&lt;p&gt;第二点，需要了解的概念有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主流编译器，解释器的流水线&lt;/li&gt;
&lt;li&gt;形式文法（EBNF）&lt;/li&gt;
&lt;li&gt;LL(1)文法，以及EBNF和LL(1)之间的转换&lt;/li&gt;
&lt;li&gt;根据LL(1)文法写递归下降Parser&lt;/li&gt;
&lt;li&gt;了解不同的AST类型，会设计AST&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第二章-amp-amp-第三章&quot;&gt;&lt;a href=&quot;#第二章-amp-amp-第三章&quot; class=&quot;headerlink&quot; title=&quot;第二章&amp;amp;&amp;amp;第三章&quot;&gt;&lt;/a&gt;第二章&amp;amp;&amp;amp;第三章&lt;/h3&gt;&lt;p&gt;这章主要讲基于LL(1)的Tokenizing和Parsing。&lt;/p&gt;
&lt;p&gt;很妙的一点在于，在写关于形式文法的地方，这本书没有将BNF和乔姆斯基之类的科班教材中讲的，而是讲文法当成是一种DSL，这其实是非常正确的。Parser Generator的输入一般就是某种类似BNF的DSL。本书中的例子是ANTLR（一个parser generator）的DSL。&lt;/p&gt;
&lt;p&gt;这种务实的风格是延续在整个第二章中的，讲LL(1)的First和Follow集的时候，是这样说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正规的定义中通常使用FIRST和FOLLOW两个运算来计算向前看集合，而实际使用时，这个问题可以等价于“哪些词法单元可能会出现在这个解析选项的开头”，这种思维方式更容易掌握，FIRST和严格定义就不在这里解释了，因为它比较复杂，而且这里也用不着其原理。如果有兴趣，可以在网上找到很多相关材料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First集合的数学定义是这样的：&lt;/p&gt;
&lt;p&gt;试想一下，如果初学者接触到的是严谨的数学定义，而不是一个相对直白的解释和代码演示的话，还是会有不少人打退堂鼓的。&lt;/p&gt;
&lt;p&gt;在实际的学习中，还是需要一些如上文中的“等价于”那样的解释。&lt;/p&gt;
&lt;p&gt;LL(1)的parser是最简单的。也是其余递归下降模式的基础框架。实现的方式就是为每一个规则写一个对应的函数，函数里按First集合来编写，规则里的运算符都可以转化为if或者while等到逻辑，如果是终结符就match，如果是非终结符就递归调用对应规则的函数。&lt;/p&gt;
&lt;p&gt;我看了Regularjs中parser的代码以及上文中vdom模板引擎的代码，结合书中的例子，大概搞懂了，接下来可以把书中的例子用js写一遍试试。&lt;/p&gt;
&lt;p&gt;第二章最后讲了LL(k)类型的parser。LL(k)就是任意k个token的lookup。LL(k)的需求，拿mcss来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mcss有点特殊，是个LL(n)的解释器，比如在设计中，函数在mcss是 First-class的，可以被返回或传入函数，并保持作用域信息，所以它是一种特殊的值，定义我设计与一般赋值一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$size = ($width, $height) { 
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里当你不读取到&lt;code&gt;{&lt;/code&gt; 是无法判断 &lt;code&gt;=&lt;/code&gt; 后面是函数定义 还是 普通css中的 compound&lt;br&gt;values  . 众所周知参数列表可能无限长，所以必须是LL(n)的Parser才能够解答。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有些语言语法里有很相似的语言结构，它们只在最后边才有区别。比如C++的函数定义和函数声明的前面都是一样的，直到;或{才能加以区别。&lt;/p&gt;
&lt;p&gt;所以想要能够写DSL解释器的话，LL(k)式的模式也是要懂的。LL(k)的问题就是要要预parse，如果条件满足，再真正parse一遍。这样带来的问题就是运行效率上比较慢。解决的办法是&lt;strong&gt;回溯法&lt;/strong&gt;，通过类似动态规划的空间换时间的方法，缓存parse的结果，加速parse的过程。&lt;/p&gt;
&lt;h3 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h3&gt;&lt;p&gt;Vue的AST。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下我阅读《编程语言实现模式》这本书的一些感受。一开始，对于编译原理，我的印象是这门课非常的艰深。在正式学习之前其实我已经看了很多编译相关的东西，比如V8，以及前端模板引擎等等。当时的感觉就是十分神奇。上了课之后首先接触的是形式文法、自动机和正规表达式等等。我的感觉就是，这些东西，是如何被前端大神们运用来写相关框架的呢，完全看不出门路嘛！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>crowbar-note-1</title>
    <link href="http://yoursite.com/2017/03/28/crowbar-note-1/"/>
    <id>http://yoursite.com/2017/03/28/crowbar-note-1/</id>
    <published>2017-03-28T10:52:55.000Z</published>
    <updated>2017-03-28T10:52:55.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>产品思维碎碎念</title>
    <link href="http://yoursite.com/2017/03/27/product-share-overview/"/>
    <id>http://yoursite.com/2017/03/27/product-share-overview/</id>
    <published>2017-03-27T04:35:28.000Z</published>
    <updated>2017-03-28T10:41:17.000Z</updated>
    
    <content type="html">&lt;p&gt;理论上来说，我们团队的成员都应该是对互联网有特殊热情的同学，或者是对手机里的各种App如数家珍，或者是对各大网站了如指掌。现在看来，之前有这方面的偏好，当然是好，但大多数人对互联网还没有那么深的认知。因此我觉得我们需要通过一系列的分享，来使得大家养成产品思维。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;互联网公司大局&quot;&gt;&lt;a href=&quot;#互联网公司大局&quot; class=&quot;headerlink&quot; title=&quot;互联网公司大局&quot;&gt;&lt;/a&gt;互联网公司大局&lt;/h3&gt;&lt;p&gt;截止目前（2017年3月28日），中国上市互联网公司的市值排名前五位的是：&lt;/p&gt;
&lt;p&gt;1 腾讯 2800亿美元&lt;br&gt;2 阿里巴巴 2668亿美元&lt;br&gt;3 百度 582亿美元&lt;br&gt;4 京东 445亿美元&lt;br&gt;5 网易 387亿美元  &lt;/p&gt;
&lt;p&gt;另外还有一些著名的上市互联网公司，比如微博、搜狐、携程等等。著名的非上市互联网公司有小米、美团和蚂蚁金服。独角兽公司（未上市，估值超过100亿美元的创业公司）有滴滴和今日头条。&lt;/p&gt;
&lt;p&gt;这些公司基本上占据了中国互联网的大部分版图。这些公司之间由合作也有竞争，并不是毫无关系的。腾讯和阿里两个巨无霸都想在竞争对手擅长的领域布局，比如腾讯投资了京东，在腾讯的应用中，会向京东导入流量，京东的支付也会优先支持微信支付。在O2O市场，阿里投资了饿了么，腾讯投资了美团大众点评。在社交方面，阿里投资了微博，目前微博盈利能力增强，但依然和阿里有着很深的合作关系。当然阿里也进行了很多直接的收购，比如优酷和UC等。&lt;/p&gt;
&lt;p&gt;大家要养成的能力就是，看到一家公司时，要能够说出这家公司的主流产品和所属的领域。比如阿里，大家可能觉得主要是电商，但其实阿里目前发展的比较快的还有云计算业务。了解一家公司服务的布局，最好的办法就是看公司的财报。比如大家如果看了网易的财报，就会很轻松的发现网易其实是一家游戏公司，发展的比较快的是跨境电商业务，其他就是广告收入，而其他的众多产品，在营收上贡献不大。公司毕竟是以盈利为目的的，因此盈利多的领域基本就可以认为是公司会主力经营的业务。后面我们会专门做一个《如何解读互联网公司财报》的分享。&lt;/p&gt;
&lt;p&gt;对国外的互联网公司也要了解。虽然因为国内的政治环境、基础设施、用户群体等等原因，国内的互联网世界和国外有很多不同之处，但不可否认的是国内互联网创业的模式大部分还是借鉴国外的。比如Uber和滴滴，Twitter和微博等等。国外互联网公司，主要是美国，主要就是Google、Facebook、Aamazon、Linkedin几家大公司和Twitter、Uber、Airbnb等等有名的创业公司。国外的互联网，在技术、商业、设计和产品上都是领先的，为了拓展自己的视野，大家就更要关注了。&lt;/p&gt;
&lt;h3 id=&quot;产品的分类&quot;&gt;&lt;a href=&quot;#产品的分类&quot; class=&quot;headerlink&quot; title=&quot;产品的分类&quot;&gt;&lt;/a&gt;产品的分类&lt;/h3&gt;&lt;p&gt;产品分类其实是一门玄学。因为分类的标准有很多种。你可以按产品的功能来分，那么自拍类产品应该属于摄影产品。但App Store里自拍相机类产品是分在社交这个分类下的，因为自拍产品最终产出的目的是为了在社交网络上展示。这是自拍产品的特有的属性。&lt;/p&gt;
&lt;p&gt;所以分类这个，因人而异。大家只要在自己脑海里建立一个体系，遇到产品能顺利的归类，就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社交&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主流的社交应用，包括很多类别，即时通讯类的主要就是微信和QQ，钉钉这样的办公应用也是这个类别。匿名社交的比如陌陌。&lt;/p&gt;
&lt;p&gt;早期的博客和论坛，有很强的社交属性，也有一定的内容属性，我们可以叫社区类产品，暂且归类到社交类下。如果你用论坛但是只是默默潜水，那就偏内容属性，所以这个还要看用户的使用。&lt;/p&gt;
&lt;p&gt;互联网发展早期的博客的论坛现在已经进化出了很多的形式，比如微博和贴吧。社交作为一种功能，现在也被广泛的集成到各种“主业”不是社交的应用中，比如天气App里面可以有一个简单的社区。&lt;/p&gt;
&lt;p&gt;因此社交类应用是指，主要功能是社交的应用。其他应用也可以集成社交功能，从而拥有社交属性，比如支付宝，但这样没法改变一个应用的本质属性。大家在分析App的时候，要注意这一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电商&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电商应用的特征相对来说比较鲜明，当然里面也可以分为B2B的比如阿里巴巴，B2C的比如天猫和京东，C2C的比如淘宝和闲鱼。电商领域按售卖商品的类别，也可以细分为，跨境电商（考拉海购、小红书）、美妆电商（蘑菇街、美丽说、聚美优品）、生鲜电商等等各种细分的市场。我们一般把这些App成为垂直领域应用。意思就是这类App的目标用户只是针对某一类人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;O2O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;O2O（Online To Offline）类的应用，其实应该是电商下的一个子类，和B2C和C2C并列。但由于这块市场这几年的增长非常快，潜力很大，因此现在我们一般单独拿出来讨论。&lt;/p&gt;
&lt;p&gt;O2O主要涉及的是人的衣食住行以及吃喝玩乐，比如各种外卖（饿了么）、团购（美团大众点评）、出行（滴滴、Ofo）等等。将线下的生意和线上的在线支付和用户体系等等结合起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摄影&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前说了，自拍应用在App Store中是放在社交类别下的。不管如何，摄影类的应用在手机自带相机质量越来越好，社交应用非常普及的今天，需求是非常大的。看一下图片社交应用Instagram的情况，就可以知道图片社交是目前社交网络中最主流的一种形式。&lt;/p&gt;
&lt;p&gt;这个市场的特点是基本没有一款应用能占据大部分份额，各家都有机会。这可能是因为用户对摄影的应用有着个性化的需求，也可能是因为大公司没有进入这一市场的缘故。国内在这方面做的大的是美图，现在已经在香港上市了。这一类的应用要发展，纯粹的工具属性是不够的，一般都需要借助社交平台之力。&lt;/p&gt;
&lt;p&gt;这里要提一下的是最近非常火的短视频应用。短视频应用其实算是一种视频社交应用，放到社交分类下讨论也是可以的，比如秒拍，快手等等。自建社区毕竟是一种高风险的决策，秒拍和微博合作，因此秒拍会的内容会嵌入微博的Feed流，借助了社交平台的力量，给秒拍带来了曝光。关于短视频应用，我们今后也会进行专题的讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;效率类应用有笔记应用、Office类应用、todo类应用、日程规划应用、日记应用，还有一些番茄钟应用，用来协助用户提高工作效率。&lt;br&gt;其他的工具类应用则是五花八门了，天气应用，记账应用等等，这些在App Store里面是有专门的类别的。&lt;/p&gt;
&lt;p&gt;Workflow和Pin这种比较高端的效率App，一般都是由个人开发者开发，可以说是应用商店中的一股清流。这样的App也许是比较适合我们去尝试开发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旅行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旅行这个分类主要是从市场来看的，旅行类应用瞄准的是人们出行时的需求，机票、酒店、景区门票、攻略、行程安排等等。&lt;/p&gt;
&lt;p&gt;主要的玩家是携程去哪儿。最近Airbnb进入中国市场，Airbnb主要的竞争对手是酒店，Airbnb今后的目标是进军整个旅行市场。专注于旅行本身的有蚂蜂窝、蝉游记、面包旅行、氢气球旅行等等。当然携程这样的巨无霸App中也是集成了旅行相关的功能的。&lt;/p&gt;
&lt;p&gt;综上，旅行市场看起来还是比较简单的，酒店机票业务实际也属于O2O的范畴。最近Airbnb的兴起，应该会为这个市场带来一些变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;教育&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在线教育这个市场，是近几年随着MOOC的发展而发展的一个市场。这个市场可以分为几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;职业培训（网易云课堂，特别是里面的微专业）&lt;/li&gt;
&lt;li&gt;K12教育（比如百度作业帮、小猿搜题）&lt;/li&gt;
&lt;li&gt;资格培训（各种托福雅思公务员驾照App，比如猿题库）&lt;/li&gt;
&lt;li&gt;MOOC（国内的有学堂在线、中国大学MOOC，当然也包括Coursera和edX等等老玩家）&lt;/li&gt;
&lt;li&gt;科教类（比如榫卯，烧杯以及各种以交互式的科普知识为目的的App）&lt;/li&gt;
&lt;li&gt;英语类（这类应用也属于广义的工具类应用，背单词是为考试服务的，因此也可以说是属于前面提到的几种类别，但因为需求最大，因此可以单独讨论，主流的比如英语流利说、扇贝单词和百词斩）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有部分应用会同时做职业培训、K12、K17（高考）等等方面，比如有道精品课。&lt;/p&gt;
&lt;p&gt;目前中国中产阶级越来越多，消费升级表现之一就是对于教育的投资。线下和线上的教育市场都会被拉动起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;视频/音乐类&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;视频和音乐类应用的历史很悠久了，这里说的是提供视频和音乐服务的产品。视频方面有优酷土豆、PPTV、乐视、搜狐视频等。音乐方面有QQ音乐、网易云音乐和虾米音乐。&lt;/p&gt;
&lt;p&gt;互联网时代，中国的视频和音乐市场最关键是就是版权之争。10年前版权宽松的时代已经一去不复返了。现在的视频网站的资源主要来自版权的购买。&lt;/p&gt;
&lt;p&gt;除此之外，自制内容也是很火的。国外这方面最典型的就是Netflix。国内比较典型的就是乐视自制的《太子妃升职记》，还有之前在优酷上火的万合天宜系列的网剧。目前国内比较流行的模式就是拿一个IP（知识产权，比如畅销小说）改编网剧（因为国内IP不够优质，最近开始改编日剧，不过质量实在是惨不忍睹）。个人觉得目前来说国内的文化产业还是比较浮躁的，比较着急赚钱变现。&lt;/p&gt;
&lt;p&gt;音乐市场上，网易云音乐也希望能挖掘草根音乐人并与其达成合作，在残酷的版权竞争之外另辟蹊径。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;资讯类&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;资讯类包括了老牌门户网站新浪网易搜狐的新闻客户端，以及新秀今日头条和UC等。今日头条和主打的是个性化的推荐，UC则是用其独特的编辑风格，吸引了很多人的眼球。&lt;/p&gt;
&lt;p&gt;也有好奇心日报和一个这种垂直类的内容提供商。好奇心日报专注于报道互联网、快时尚、消费电子等行业的新闻，同时也有着独特的互动栏目，主要瞄准的是年轻人生活中的种种。一个可以理解为一个平台，培养一些在网络上受欢迎的“网红”作家。&lt;/p&gt;
&lt;p&gt;P.S. 网红这个词，比如网红作家，网红剧等，基本可以等同于，在90后左右的年轻人为主的社交网络中被广泛传播和讨论，有一定人气的意思。不仅仅是Papi酱这种传统意义的网红，知乎大V，甚至支付宝的微信公众号，只要是在社交网络上有很多Follower的，都称为网红。&lt;/p&gt;
&lt;p&gt;P.P.S 好奇心有一个栏目叫“好奇心词典”，专门解释在当前时代语境下的新鲜词汇。上面的解释大概就是这个模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏就不用多说了。国内手机游戏的巨头是腾讯，第二的是网易，但网易和腾讯之间的差距还是非常明显的。腾讯的游戏依托自身的流量平台，以及相对更平民化的研发策略，占据了大部分的市场。游戏这个市场的特点就是寡头瓜分市场，小公司很难生存。利润上来说游戏是互联网行业中最高的之一。&lt;/p&gt;
&lt;h3 id=&quot;产品的盈利模式&quot;&gt;&lt;a href=&quot;#产品的盈利模式&quot; class=&quot;headerlink&quot; title=&quot;产品的盈利模式&quot;&gt;&lt;/a&gt;产品的盈利模式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;广告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广告是历史最悠久的互联网产品盈利模式了。互联网开山鼻祖Google一开始就是靠广告作为收入来源的。&lt;/p&gt;
&lt;p&gt;广告一般嵌入在应用的展示位中，按点击来进行收费。&lt;/p&gt;
&lt;p&gt;Google和Facebook这种掌握了大量流量的公司，会专门有部门来负责广告的投放，也会提供工具来让广告主对自己的广告进行管理和数据分析。&lt;/p&gt;
&lt;p&gt;甚至有Google Ads这种产品，提供给你一个广告平台，你把代码放到自己的产品中，通过用户的点击，获得收入。广告主只需要和Google Ads进行接触。&lt;/p&gt;
&lt;p&gt;除了搜索引擎和社交应用，内容类产品和工具类产品也可以用广告进行变现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电商&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电商是最容易理解的，因为电商的盈利模式和线下的零售业是很相似的。&lt;/p&gt;
&lt;p&gt;B2C的电商比如京东，可以从自营商品的销售中直接获利，而淘宝这样的C2C平台，是通过向店主收取服务费用进行盈利的，O2O的盈利模式也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内购&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏的内购，售卖的是虚拟道具。&lt;/p&gt;
&lt;p&gt;工具类产品的内购，售卖的是高级功能。本质上是将服务标价售卖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识变现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知识变现是最近比较火的一种新的盈利模式，当然本质上还是一种收费的服务。&lt;/p&gt;
&lt;p&gt;常见的知识变现有打赏、收费提问、Live、收费群等等。&lt;/p&gt;
&lt;p&gt;知乎Live售卖的是讲座的门票，小密圈售卖的是和圈主交流的机会。知识变现的本质是提供服务，通过这个服务，用户可以学习到知识。其实和我们熟悉的收费培训道理是一样的，只不过目前的知识变现侧重于碎片化的分享和交流，而不是体系化的培训。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;以上，总结了我个人认为对产品思维入门比较重要的三个点。还有很多地方没有谈到，比如在产品分类时没有提到直播应用（其实是直播应用比较复杂，有点难分类）。这是我心目中一个互联网从业者应该有的认知，在这个基础上，我们才能对具体的产品，具体的行业，进行更深入的研究和思考。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;理论上来说，我们团队的成员都应该是对互联网有特殊热情的同学，或者是对手机里的各种App如数家珍，或者是对各大网站了如指掌。现在看来，之前有这方面的偏好，当然是好，但大多数人对互联网还没有那么深的认知。因此我觉得我们需要通过一系列的分享，来使得大家养成产品思维。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>终端工具翻墙不完全指南</title>
    <link href="http://yoursite.com/2017/03/26/proxy-for-terminal/"/>
    <id>http://yoursite.com/2017/03/26/proxy-for-terminal/</id>
    <published>2017-03-26T14:10:22.000Z</published>
    <updated>2017-03-28T11:24:19.000Z</updated>
    
    <content type="html">&lt;p&gt;写这篇文章的动机是之前Github曾经短暂的被墙过，这样的话，如果终端没有翻墙，那就没法推代码了。之后几天国内访问Github也一直很慢，于是尝试了给终端翻墙。网上的文章很多，但没有特别满意的，因此决定自己写一篇。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;说是不完全指南，因为我这篇文章针对的是macOS下使用Shadowsocks翻墙的用户来说的。当然其他其他的系统，如果是使用Shadowsocks，道理应该差不多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预备工作&lt;/strong&gt;：安装Shadowsocks客户端，配置好服务器。搞清楚Shadowsocks在本地运行的端口，一般是1080或者1086。&lt;/p&gt;
&lt;h3 id=&quot;Homebrew翻墙&quot;&gt;&lt;a href=&quot;#Homebrew翻墙&quot; class=&quot;headerlink&quot; title=&quot;Homebrew翻墙&quot;&gt;&lt;/a&gt;Homebrew翻墙&lt;/h3&gt;&lt;p&gt;macOS下装软件要用Homebrew，但Homebrew的源在国外，国内用是很慢的。首先我们要让Homebrew翻墙，才能顺利的往下进行其他工作。&lt;/p&gt;
&lt;p&gt;Homebrew下载用的是curl。因此我们只要配置curl使用代理就可以了。&lt;/p&gt;
&lt;p&gt;curl的代理在&lt;code&gt;~/.curlrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们在这里加一行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socks5 = “127.0.0.1:1080”&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;1080是之前说的Shadowsocks的本地端口，下文就不再说明了。&lt;/p&gt;
&lt;h3 id=&quot;安装Polipo&quot;&gt;&lt;a href=&quot;#安装Polipo&quot; class=&quot;headerlink&quot; title=&quot;安装Polipo&quot;&gt;&lt;/a&gt;安装Polipo&lt;/h3&gt;&lt;p&gt;&lt;code&gt;brew install polipo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;装好后记得把之前加上的curl的代理删掉。&lt;/p&gt;
&lt;p&gt;然后配置polipo，修改&lt;code&gt;/usr/local/opt/polipo/homebrew.mxcl.polipo.plist&lt;/code&gt;设置&lt;code&gt;parentProxy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;homebrew.mxcl.polipo&amp;lt;/string&amp;gt;
    &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
    &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
    &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
    &amp;lt;array&amp;gt;
        &amp;lt;string&amp;gt;/usr/local/opt/polipo/bin/polipo&amp;lt;/string&amp;gt;
        &amp;lt;string&amp;gt;socksParentProxy=localhost:1080&amp;lt;/string&amp;gt;
    &amp;lt;/array&amp;gt;
    &amp;lt;!-- Set `ulimit -n 20480`. The default OS X limit is 256, that&amp;#39;s
         not enough for Polipo (displays &amp;#39;too many files open&amp;#39; errors).
         It seems like you have no reason to lower this limit
         (and unlikely will want to raise it). --&amp;gt;
    &amp;lt;key&amp;gt;SoftResourceLimits&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
      &amp;lt;key&amp;gt;NumberOfFiles&amp;lt;/key&amp;gt;
      &amp;lt;integer&amp;gt;20480&amp;lt;/integer&amp;gt;
    &amp;lt;/dict&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加了&lt;code&gt;&amp;lt;string&amp;gt;socksParentProxy=localhost:1080&amp;lt;/string&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后配置polipo开机自启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样polipo就设置完成了，polipo的http代理默认在&lt;code&gt;localhost:8123&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;NPM翻墙&quot;&gt;&lt;a href=&quot;#NPM翻墙&quot; class=&quot;headerlink&quot; title=&quot;NPM翻墙&quot;&gt;&lt;/a&gt;NPM翻墙&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;npm config set proxy http://127.0.01:8123
npm config set https-proxy http://127.0.0.1:8123
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Git翻墙&quot;&gt;&lt;a href=&quot;#Git翻墙&quot; class=&quot;headerlink&quot; title=&quot;Git翻墙&quot;&gt;&lt;/a&gt;Git翻墙&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;git config --global http.proxy http://localhost:8123
git config --global https.proxy http://localhost:8123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用&lt;code&gt;git config --list&lt;/code&gt;查看是否设置成功。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;上面讲了NPM和Git的代理。其他工具的话，道理是一样的，如果直接支持socks5代理，那是最好。一般都支持Http代理，比如Genymotion。遇到工具网络请求很慢的情况，设置具体工具的代理就可以了。我之前以为在终端设置&lt;code&gt;export http_proxy=http://localhost:8123&lt;/code&gt;就可以。结果并不是这样，并不是所有的工具都走这个终端的代理。&lt;/p&gt;
&lt;p&gt;终端也有了代理，从此我们就可以愉快的进行开发了。妈妈再也不用担心我的cnpm出什么问题了，推代码到Github的心情也更轻松了，连更新博客都勤快了很多呢！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为终端设置Shadowsocks代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的动机是之前Github曾经短暂的被墙过，这样的话，如果终端没有翻墙，那就没法推代码了。之后几天国内访问Github也一直很慢，于是尝试了给终端翻墙。网上的文章很多，但没有特别满意的，因此决定自己写一篇。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊云计算</title>
    <link href="http://yoursite.com/2017/03/21/about-cloud/"/>
    <id>http://yoursite.com/2017/03/21/about-cloud/</id>
    <published>2017-03-21T07:17:18.000Z</published>
    <updated>2017-03-24T14:00:46.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要是写我对团队在云计算方向上现状的一些思考。并没有什么关于云计算的干货，毕竟我在这方面还需要大量的实践才能有足够的发言权。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;IaaS&quot;&gt;&lt;a href=&quot;#IaaS&quot; class=&quot;headerlink&quot; title=&quot;IaaS&quot;&gt;&lt;/a&gt;IaaS&lt;/h3&gt;&lt;p&gt;我们用的最多的就是IaaS（Infrastructure as a Service）了。阿里云中的ECS和RDS就是典型的IaaS，另外阿里云OSS或者亚马逊S3那样的存储服务也是。&lt;/p&gt;
&lt;p&gt;IaaS，简单的理解就是，将计算资源，作为一种基础设施，提供给用户。用户可以像消费水和电一样来按需进行使用计算资源。&lt;/p&gt;
&lt;p&gt;IaaS是基于虚拟化和分布式技术来提供服务的。在云计算之前的时代，公司的网站是部署在一台台实体的服务器上的。一般来说，一家小公司，可能只需要一两台服务器就可以满足业务需求了。有服务器也自然有传统的运维人员，这种工程师精通硬件、网络和安全方面的知识，全权负责机房里服务器的正常运转和性能优化。&lt;/p&gt;
&lt;p&gt;然而维护一台实体服务器的成本是很高的，需要雇佣一个服务器运维人员，需要付出电费和购置服务器的费用，以及架设网络的成本。&lt;/p&gt;
&lt;p&gt;大公司会建立数据中心，其实就是有着大量服务器的厂房。大公司有着足够的人力去维护自有的服务器。&lt;/p&gt;
&lt;p&gt;在那个年代，后端工程师部署服务是直接部署在实体机器上的，在部署时需要和运维人员确定服务器的环境等，经常会有一些沟通上的问题。&lt;/p&gt;
&lt;p&gt;还有一个问题则是，那时的网站是很难动态伸缩的，一个应用往往同时部署在多台服务器上。然而，要使得一个服务能抗下更多的流量，就需要更多的服务器，如果不能在短时间内配置好新服务器，网站在压力之下往往会崩溃。&lt;/p&gt;
&lt;p&gt;云计算对于小公司的好处在于，消除了维护实体服务器需要的各种繁杂的成本。维护实体服务器的责任交给了云服务厂商。小公司只需要购买服务就可以。&lt;/p&gt;
&lt;p&gt;对于大公司来说，云计算可以动态扩容，一键部署，使得应用在压力之下可以弹性伸缩。将计算资源利用率最大化。&lt;/p&gt;
&lt;p&gt;我们使用的ECS其实并不对应一台实体的服务器，但我们在使用的时候可以将ECS当成一台完整的服务器来使用。这就是虚拟化技术的好处。我们可以按需使用计算资源（一台实体服务器往往是8核或者16核CPU这样的配置，我们用不到这么多的CPU）。&lt;/p&gt;
&lt;p&gt;我们也不用担心服务器会被攻击或者数据丢失。ECS提供了自动快照的服务。&lt;/p&gt;
&lt;p&gt;在我看来云计算是对计算资源做的一次抽象，将后端应用和实体的服务器硬件资源隔离了。使得基于硬件的备份和维护这些事情抽象出来，开发人员只用关注应用层面的逻辑就可以了。&lt;/p&gt;
&lt;p&gt;而RDS和OSS这些服务，也是同理。我们不用关心存储具体的物理位置在哪台服务器上，只需要调用这个服务就可以了。&lt;/p&gt;
&lt;p&gt;而RDS、ECS和OSS三个服务的分离，也是一种抽象。ECS只关心业务逻辑，OSS和RDS只关心数据存储。只有无状态的服务才能轻松实现横向的拓展。如果ECS上的应用和数据库一起部署的话，会对应用的可拓展性造成影响。&lt;/p&gt;
&lt;p&gt;具体说到我们团队，ECS和RDS我们使用阿里云的服务。对象存储我们则打算自建。一个是利用手上的物理服务器，降低一些成本，还有一个就是研究一下分布式存储相关的技术，加深团队在云计算方面的技术深度（Ceph这个开源的分布式存储框架已经非常强大了，我们目前打算先尝试Ceph）。&lt;/p&gt;
&lt;h3 id=&quot;PaaS&quot;&gt;&lt;a href=&quot;#PaaS&quot; class=&quot;headerlink&quot; title=&quot;PaaS&quot;&gt;&lt;/a&gt;PaaS&lt;/h3&gt;&lt;p&gt;PaaS（Platform as a Service）方面的服务的代表就是Google的App Engine（以下简称GAE）。在App Engine中你只需要写业务逻辑，不需要关心服务和数据的部署。GAE号称会根据你应用的流量实时拓展服务的部署。&lt;/p&gt;
&lt;p&gt;GAE带来的其实是更高的一层抽象。将基础设施的使用也屏蔽了。其实这个就将当于大家写了一个Flask应用，push到Github，写一个简单的配置文件，然后就可以访问了。你不用关心Nginx的配置，也不用关心部署多个实例以及均衡负载这些问题。It just works。&lt;/p&gt;
&lt;p&gt;另外你还可以在控制台用GUI控制你的应用，以及读取监控数据等等。&lt;/p&gt;
&lt;p&gt;我对此是非常感兴趣的，特别是Docker的出现，使得自动化的部署，环境的隔离以及标准化变成了一件比较简单的事情。&lt;/p&gt;
&lt;p&gt;我构想中的Muxi App Engine（以下简称MAE）是这样的：&lt;/p&gt;
&lt;p&gt;支持Python和Node两种环境，会根据ECS上的实时部署情况，自动将容器实例部署在最合适的ECS上，并且在流量变大时会自动伸缩。在MAE控制台上可以看到常规的Log统计。可以在MAE上用配置中的Git仓库和分支进行一键部署，前端代码也是一样的。&lt;/p&gt;
&lt;p&gt;MAE的目标是将一些应用公共的流程尽量标准化，目前我们的自动化部署还是需要自己写Webhook脚本的。统计的话也是需要手动去配置的。Nginx相关的一些配置也是手动的。&lt;/p&gt;
&lt;p&gt;MAE是一个单独的服务，部署在一台服务器上。MAE对可支配的ECS都有着记录，并且在对应的ECS上都运行着守护进程，和MAE服务通信。&lt;/p&gt;
&lt;p&gt;MAE时代的开发和目前并没有太大的区别，只是每个应用需要有一个MAE的配置文件，里面写了域名、Github仓库、Docker环境等等信息。&lt;/p&gt;
&lt;p&gt;我们在MAE上新建一个应用，然后点击部署，就可以部署了。&lt;/p&gt;
&lt;p&gt;对于我们的大部分，自己托管数据的应用（相比匣子这样需要实时爬取的应用），比如学而、桂声等等，MAE这样的模式可以很好的讲平台层的运维工作简单化、标准化。&lt;/p&gt;
&lt;p&gt;当然MAE如何和微服务结合这个也是一个问题，目前的应用其实是有分拆成服务的空间的，这样的话MAE其实应该是以服务为单位的。&lt;/p&gt;
&lt;h3 id=&quot;SaaS&quot;&gt;&lt;a href=&quot;#SaaS&quot; class=&quot;headerlink&quot; title=&quot;SaaS&quot;&gt;&lt;/a&gt;SaaS&lt;/h3&gt;&lt;p&gt;SaaS（Software as a Service）离普通用户最近的云计算形式。我们用Tower、百度云盘、石墨文档这些，都属于SaaS。&lt;/p&gt;
&lt;p&gt;我们日后推出的服务，比如云简历，或者是其他工具类的应用，都是以软件形式向用户提供了某种基于云计算的服务。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;基于综合的考虑，我认为云计算是目前最有用，也是最触手可及的前沿技术。&lt;/p&gt;
&lt;p&gt;目前后端技术这边，机器学习/人工智能、云计算、大数据，是几个比较火的领域。当然这几个领域目前有融合的趋势。&lt;/p&gt;
&lt;p&gt;对于我们来说，要构筑我们的技术壁垒，云计算是最好的突破口。在知识水平、业务体量等种种的不利因素下，云计算是可以深挖，并且&lt;strong&gt;实践&lt;/strong&gt;的一个领域。&lt;/p&gt;
&lt;p&gt;无论是对于我们内部服务的支持，或者是对于个人技术能力，就业市场竞争力的提升来说，这都是一个最优的方向。&lt;/p&gt;
&lt;p&gt;所以在接下来的很长一段时间，我希望大家能一起努力，在云计算上，达到一个不算太寒碜的水准。这需要所有同学的支持，包括前端、客户端和设计组的同学，因为转向云计算会对目前的开发流程产生很大的影响。然后在UI和品牌方面，自然也需要前端和设计师的配合。PM同学也需要理解这个战略。&lt;/p&gt;
&lt;p&gt;就写这么多吧。祝一切顺利。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是写我对团队在云计算方向上现状的一些思考。并没有什么关于云计算的干货，毕竟我在这方面还需要大量的实践才能有足够的发言权。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://yoursite.com/2016/12/26/my2016/"/>
    <id>http://yoursite.com/2016/12/26/my2016/</id>
    <published>2016-12-26T06:58:46.000Z</published>
    <updated>2017-01-01T08:40:08.000Z</updated>
    
    <content type="html">&lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;回看我的进度，1月的时候我开始写简历生成器和学而的后台，那段时间我对于前端工程化很痴迷。把Dan Abramov的视频看了很多遍。主要用React写东西。&lt;/p&gt;
&lt;p&gt;寒假主要是写学而后台，写个人主页，看YDKJS和《JavaScript忍者秘籍》。寒假里面我发现了大批的电子书，对于JS的语言有了更深入的了解。也开始对公司和业务有一些自己的思考。我对于浏览器的探索也在那个时候开始了，主要是看了Mozilla工程师写的自制浏览器那一系列的博客。从进度上来看，那个时候真是热火朝天的学学学，新事物扑面而来，整个人还是很有干劲的。&lt;/p&gt;
&lt;p&gt;在找工作这问题上，当时我还是很没有底的。&lt;/p&gt;
&lt;p&gt;那段时间还在刷PAT，打算去参加春季的考试，但最后还是没有去，觉得没有准备好。&lt;/p&gt;
&lt;p&gt;接下来就是3月了，开学了，要上课要辅修，事情很多。学习的进度就没有那么快了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.14&lt;/p&gt;
&lt;p&gt;投简历+学而+团队+i华大 = 爆炸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来就是接触简单的算法，去网易面试。&lt;/p&gt;
&lt;p&gt;4月学校的出版社实习期间开始看jQuery源码。&lt;/p&gt;
&lt;h3 id=&quot;找工作&quot;&gt;&lt;a href=&quot;#找工作&quot; class=&quot;headerlink&quot; title=&quot;找工作&quot;&gt;&lt;/a&gt;找工作&lt;/h3&gt;&lt;p&gt;3月开始面试，第一个面的是阿里，二面挂了，一些很简单的问题没有准备，比如正则和简单的DOM API。后来面了饿了么，过了。在面试网易的时候，饿了么表示如果不能确定offer那就算了，于是我就在没有保底offer的情况下，去网易面试了。&lt;/p&gt;
&lt;p&gt;去网易的面试算是我第一次很正式的面试。总的来说，其实很平稳，但对我来说，记忆犹新。最让我感到印象深刻的还是面试期间那种忐忑的心情。好在最后一切顺利。现在看来，觉得还是挺幸福的。&lt;/p&gt;
&lt;h3 id=&quot;团队&quot;&gt;&lt;a href=&quot;#团队&quot; class=&quot;headerlink&quot; title=&quot;团队&quot;&gt;&lt;/a&gt;团队&lt;/h3&gt;&lt;p&gt;5月份的时候，团队出了大事，主要就是工作室要装修。领导为了面子工程，把我们的304改成了展示厅。对当时的我来说这真是和晴天霹雳一般。&lt;/p&gt;
&lt;p&gt;匆忙的租了房子，其实最后也没起多大作用。这次搬家对我们来说，意味着很多。和过去告别。真正的成长，担起团队的责任。&lt;/p&gt;
&lt;p&gt;这个时候，我们确立了核心成员的概念。一个团队，只需要核心成员，不是核心成员的都可以离开了。一个团队的人数并不是关键，团队的凝聚力和战斗力才是最关键的。&lt;/p&gt;
&lt;p&gt;其他的话，其实从我进度里看，关于团队的很多。大部分都是一些消极的抱怨，还有一些思考。暑假的时候，和大家远程交流，开会。很困难，到最后其实很有多的摩擦。但无论如何，事情都算是过去了。&lt;/p&gt;
&lt;p&gt;在12月的时候，我决定从团队的日常事务中抽身，专心做自己的事情。经过这段时间来看，团队是可以自己正常运转的。很开心啊，像是自己的孩子长大了一样。&lt;/p&gt;
&lt;h3 id=&quot;在网易的三个月&quot;&gt;&lt;a href=&quot;#在网易的三个月&quot; class=&quot;headerlink&quot; title=&quot;在网易的三个月&quot;&gt;&lt;/a&gt;在网易的三个月&lt;/h3&gt;&lt;p&gt;在网易的实习经历，在业务上是比较平淡的。做的有数这个平台的确是很复杂的，但我加入的时候这个平台已经比较成熟了，所以也没有太多挑战性的东西。没有见证初期的技术选型和架构的选择，所以在这方面没有学到太多想学到的。在大公司，技术选型这个是一个多方博弈的结果，要考虑公司本身的基础设施，并不是简单的引入开源项目就可以的。&lt;/p&gt;
&lt;p&gt;在网易主要是写了一个Regular-devtool，其他的话就写了一些简单的业务。生活的话，可以说还是非常幸福的。环境这些都挺不错的。现在想来还挺怀念呢。&lt;/p&gt;
&lt;h3 id=&quot;华师匣子&quot;&gt;&lt;a href=&quot;#华师匣子&quot; class=&quot;headerlink&quot; title=&quot;华师匣子&quot;&gt;&lt;/a&gt;华师匣子&lt;/h3&gt;&lt;p&gt;这个可以直接看之前写的&lt;a href=&quot;https://zxc0328.github.io/2016/12/19/ios-story/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;华师匣子开发记&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一些新的探索&quot;&gt;&lt;a href=&quot;#一些新的探索&quot; class=&quot;headerlink&quot; title=&quot;一些新的探索&quot;&gt;&lt;/a&gt;一些新的探索&lt;/h3&gt;&lt;p&gt;函数式编程，以及相关的一些，还有编译原理。这两个Topic是我下半年的核心。这是我最近觉得最感兴趣的方向。对这些方向只进行了一些初步的探索。&lt;/p&gt;
&lt;p&gt;前端工具上，7月我写了Ninja，在团队的项目中用了半年。说实话这个是我最自豪的事情。&lt;/p&gt;
&lt;p&gt;12月开始写Build your own Vuejs，希望能顺利写完。&lt;/p&gt;
&lt;h3 id=&quot;未来打算&quot;&gt;&lt;a href=&quot;#未来打算&quot; class=&quot;headerlink&quot; title=&quot;未来打算&quot;&gt;&lt;/a&gt;未来打算&lt;/h3&gt;&lt;p&gt;我现在的一个理念，就是，你想学什么，那就自己写一个。光用是不行的。比如像了解前端MVVM框架，就自己实现一个。想学编译原理，可以自己实现一个简单的编译器。我认为这是很有趣的事情，也是很了不起的事情。&lt;/p&gt;
&lt;p&gt;未来打算在前端工具和框架这个方向上深入的研究。然后正式学习函数式编程。以及DSL相关的知识。保持好奇心。保持对生活的热爱！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016对我来说当然是很神奇也很重要的一年。团队的进步很快，华师匣子终于上线。我也顺利的找到的工作。&lt;/p&gt;
&lt;p&gt;回想这一年，对于上半年的事情，现在只残存着一些依稀的回忆了。这一年我对前端的理解，有了很大的变化，这其实是一个日积月累的过程。所以Tower里的进度，对于我来说，就是一个非常好的备忘录。自己的学习的历程，在里面可以看到一个很清晰的脉络。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从0到1：我和木犀的故事</title>
    <link href="http://yoursite.com/2016/12/19/muxi-story/"/>
    <id>http://yoursite.com/2016/12/19/muxi-story/</id>
    <published>2016-12-19T03:28:47.000Z</published>
    <updated>2016-12-23T07:12:39.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一个人的i华大技术中心&quot;&gt;&lt;a href=&quot;#一个人的i华大技术中心&quot; class=&quot;headerlink&quot; title=&quot;一个人的i华大技术中心&quot;&gt;&lt;/a&gt;一个人的i华大技术中心&lt;/h3&gt;&lt;p&gt;2014年开始，虽然我们还是习惯说自己是技术部的，但名义上已经是i华大技术中心了。底下分技术研发部和视觉设计部。&lt;/p&gt;
&lt;p&gt;说一个人，我指的是技术方面，设计那边还是很强大的。除了做主任的学姐和炳权学长，其他人并不会技术，然后之前的主任学姐三四月份就跑路了，炳权学长也很早就在名义上退出了。因此这个技术部就只有我一个人了。&lt;/p&gt;
&lt;p&gt;然后就是2014年四月份，技术中心春招。我依稀记得那个时候来了有大概三四十号人。然后我在306做培训，其实就是教他们切页面。&lt;/p&gt;
&lt;p&gt;那个时候也没想着要做一个技术团队，就想要把技术中心做好吧。当时我自己其实也是小白，也教不了他们什么。这三四十号人也并不是完全合适，因此最后待的比较久的，就只有龚红霞一个人。&lt;/p&gt;
&lt;p&gt;2014年的上半年还发生了一件事情，就是桂声10周年庆，请了很多高校的团队来交流，有武大和理工人的来了。当时我们的技术实力几乎为0，然而却在PPT上写了我们用Node，现在想起来还是觉得脸红。我听他们讲JSON，API这些，完全不懂。想来这应该就是我想打造一个技术团队的最初来源吧。&lt;/p&gt;
&lt;h3 id=&quot;木犀&quot;&gt;&lt;a href=&quot;#木犀&quot; class=&quot;headerlink&quot; title=&quot;木犀!&quot;&gt;&lt;/a&gt;木犀!&lt;/h3&gt;&lt;p&gt;木犀这个名字，想来应该就是14年下半年提出的。之所以叫木犀，是因为华师的桂花很出名，但直接叫桂花又太俗。我偶然得知木犀是桂花的学名，于是就选用了这个名字。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有个插曲，炳权曾经提议说我们可以叫handle，现在想起来还是觉得很搞笑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2014年的秋招，来了很多人，胡薇、韩伟、老王、王露晨、梁晓怡，这都是之后设计组的核心，想来之后那段时间也是设计组的黄金时代。小桂漫画，壁纸，表情，都是那段时间做的。&lt;/p&gt;
&lt;p&gt;还有一个人，那就是朱承浩。&lt;/p&gt;
&lt;p&gt;对我建设团队帮助最大的还是炳权，因为炳权那个时候已经在冰岩了（虽然我到15年上半年才知道），他会给我们很多建议，我也拓宽了很多视野。&lt;/p&gt;
&lt;p&gt;2014年下半年我们开始学Python，决定用Python做后端的语言。但那个时候还没有能力去完成一个网站的后台。那段时间我主要是用Drupal这个CMS来做学而的第一版。&lt;/p&gt;
&lt;p&gt;学而第一版其实反响还是很不错的，现在数据库里都还有那个时候的评论。这对我来说是一个鼓励，说明产品是有需求的。然后Drupal这个东西，开发难度很大，这坚定了我们自己学后台的决心。&lt;/p&gt;
&lt;p&gt;2015年的到来，是一切奇迹的开始。放弃Drupal和各种前端插件，真正的踏入Web开发的大门，就是从哪个时候开始的。所以说木犀的成长史，也是技术的成长史。&lt;/p&gt;
&lt;p&gt;首先我们在15年2月全面使用了Tower（这个时间点之前设计组好像就已经在用了）。大家看我和承浩的进度都是从15年2月开始的。至于Tower，对，没错，是炳权告诉我的，因为冰岩在用。&lt;/p&gt;
&lt;p&gt;之后就是承浩的时间了。他学了Flask，我们用Flask搭的第一个网站是什么，我已经忘了。我只记得那个时候，光部署网站，就要花好几天，因为书上讲的是AWS这种云服务的部署。手动的部署还是有一些门槛的。那个时候，因为了解的层次比较低，会觉得很多东西是玄学。&lt;/p&gt;
&lt;p&gt;3月我们去了联创交流，具体可以参见我的&lt;a href=&quot;http://zxc0328.github.io/2015/03/27/联创交流行/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;5月份和6月份其实还有一次转折。5月份的时候，理工的token团队办了十五周年庆，我们去参加了技术交流会。这次是我们第一次以木犀团队的名义出去交流。也是从2015年上半年开始，我们慢慢习惯以木犀团队的身份出现在所有人的眼中。这次交流会上，我们依然没有太多的干货，相比于其他团队，我们感受到了我们还太年轻。&lt;/p&gt;
&lt;p&gt;6月联创Hackday。我们主要是去感受了一下气氛。3月和6月两次去启明，对于我和承浩两个做技术的人来说，这个冲击不亚于工业文明对封建社会的冲击。首先是感受到了华科那边浓厚的技术气氛，其次是感到了一些压力，因为我们团队是如此的弱小，而华师的技术氛围又不想。当然是压力也是动力，不管如何，从2015上半年之后，我们团队在技术上便开始了不断的进步。&lt;/p&gt;
&lt;p&gt;联创Hackday&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150606_230735.jpg&quot; alt=&quot;hackday&quot;&gt;&lt;/p&gt;
&lt;p&gt;暑假承浩买了Mac，从此就一发不可收拾。那个暑假我在极验实习。其他人进行了我们第一次的夏令营（夏令营这个想法也是炳权提供的）。那个夏令营还是很愉快的，我们做出了第一版的内网，对于Flask的掌握已经好很多了。&lt;/p&gt;
&lt;p&gt;夏令营照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/0067HQaegw1ew2zdt5kfvj318g0xc7kh.jpg&quot; alt=&quot;xialy&quot;&gt;&lt;/p&gt;
&lt;p&gt;夏令营最后去落雁岛玩的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/64c45edcjw1fb0mmjzukkj21ci0ya4qp.jpg&quot; alt=&quot;lyd&quot;&gt;&lt;/p&gt;
&lt;p&gt;2015年9月，团队已经初具规模了。后面的事情，15级的同学应该都清楚了。&lt;/p&gt;
&lt;p&gt;接下来的事情就是2015年下半年开发的学而的第二版，完全用Flask写，有同步的路由和REST API组成，前端移动版是一个SPA，用了Webpack和React。这就是我们第一个工程化的产品。&lt;/p&gt;
&lt;p&gt;技术团队的成长，其实就是我的成长，承浩的成长，已经后面14级其他同学和15级同学的成长，每次有一个人成长为核心成员，团队就变的更加的强大。&lt;/p&gt;
&lt;h3 id=&quot;番外：304-306-502&quot;&gt;&lt;a href=&quot;#番外：304-306-502&quot; class=&quot;headerlink&quot; title=&quot;番外：304-306-502&quot;&gt;&lt;/a&gt;番外：304-306-502&lt;/h3&gt;&lt;p&gt;一开始，i华大技术中心的办公地点是在304。那时候我们还是非常自由的，304可以随意的改造。经历过那段时刻的同学应该知道，那段时间是很有归属感的一段时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/0067HQaegw1ew2zdsct9bj30hs0hsgpb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/20150402_202558.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;直到今年5月份，304和306装修。我仓皇中去合租了一间房子，在教工宿舍，作为我们的临时工作室：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xj431.com1.z0.glb.clouddn.com/IMG20160622155941.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那段时光是难忘的，也是别扭的，痛苦的。那只狗，上门的邻居，狭小的空间，和我自己当时的各种压力混合在一起。&lt;/p&gt;
&lt;p&gt;现在我们主要在306活动，也在304。虽然归属感没有以前这么强了，但因为大家更熟悉了，核心成员也更多了，所以团队的气氛要更好一些。&lt;/p&gt;
&lt;p&gt;我还是希望我们能有一间独立的工作室。我们要时刻保持危机感，来应对未来的无限的可能。&lt;/p&gt;
&lt;h3 id=&quot;前端之路&quot;&gt;&lt;a href=&quot;#前端之路&quot; class=&quot;headerlink&quot; title=&quot;前端之路&quot;&gt;&lt;/a&gt;前端之路&lt;/h3&gt;&lt;p&gt;我个人的前端之路，其实也是木犀从0到1的一个很好的注脚。&lt;/p&gt;
&lt;p&gt;我其实在15年的上半年才开始正式学计算机。那个学期在武大开始辅修，然后在团队开始学Flask和Python。5月的时候，我的前端水平是只会写简单的Banner，相比之前Banner都要用插件的水平来说，算是好一些。那个时候是标准的过程式的编程。&lt;/p&gt;
&lt;p&gt;5月的时候看了一本单页应用开发的书，里面讲到了IIFE，闭包等等。我如获至宝，写个什么组件（其实我当时并没有组件的意识）就用IIFE，其实这算是最初的模块化，工程化意识吧。只不过我那个时候并不清楚模块化和工程化，也不知道正常的编程语言都是自带模块的。&lt;/p&gt;
&lt;p&gt;7月和8月我主要在极验实习，切了不少的页面，里面有一些用jQuery做的组件。这个时候我写展示型的页面以及比较熟练了，CSS也掌握的不错（毕竟在写桂声那些主要就是CSS）。但对于前端的那些Grunt什么的工具，其实我并不是很清楚为什么要用。&lt;/p&gt;
&lt;p&gt;所以对于模块的理解，对我来说是一道坎。真正理解模块和工程，还有闭包，大概是今年的事情了。&lt;/p&gt;
&lt;p&gt;9月回学校之后我看了React，后来就开始用Backbone写学而。那个时候我对MVC了解的还是比较多的，因为之前后端用的就是MVC。写React的时候比较初步的理解了组件化。之后对于Webpack之类的工具也用的很顺手了。&lt;/p&gt;
&lt;p&gt;这个学期对面向对象也略有了解。但对于View和Model的分层，以及组件的抽象，还没有到能手写的地步。那个时候我看Backbone源码，并没有太多感觉。而现在我回头看，就觉得抽象非常的清晰了。&lt;/p&gt;
&lt;p&gt;那个时候我对很多事情的理解都比较的浅薄。对于React Native很崇拜，觉得Web的目标就是取代原生应用。觉得Web就是要做单页应用。也没有很深入的理解前端工具为什么存在，以及组件化的发展史。&lt;/p&gt;
&lt;p&gt;现在来看，其实Web有Web的特点，需要动态化、快速上线、展示型的东西都可以用Web来做，这只是一个简单的技术选型的问题。&lt;/p&gt;
&lt;p&gt;总得来说，这是一个&lt;strong&gt;技术视野&lt;/strong&gt;的问题。如果你用过很多别的语言，那你就应该很容易的理解模块的存在。如果你开发过原生应用，那你就应该很好的理解为什么Web开发的UI应该是组件化的。&lt;/p&gt;
&lt;p&gt;今年开始，我把兴趣移到了函数式，编程语言，还有计算机基础上面。对于前端，我主要在开发工具解决我们自己的工作流中的问题，还有就是研究框架和工具的源码，进一步深入。&lt;/p&gt;
&lt;p&gt;现在回过头来看，我就能发现前端学习的一个最佳的路径，DOM可以不用花很多心思，但组件一定要自己去手动实现。模块可以直接用标准的模块。前端无非是普通的客户端软件开发，从这个视角去看的话，事情就清楚多了。&lt;/p&gt;
&lt;p&gt;计算机基础加上足量的工程经验，应该就可以成就一个好的工程师了。我的前端之路还算顺利，大家的学习道路，在我们这些先行者的踩坑之后，肯定会更加顺利。但有一点是肯定的，要把一样事情学好，需要你的热情，时间，和精力。&lt;/p&gt;
&lt;p&gt;还有一点，就是你的视野是随着你的经验而增长的，视野对你理解一些技术是非常有帮助的。平时我们在安排学习路线时也会特意的去安排背景阅读材料，或者是讲一些思想和Lab结合起来，努力让大家能够尽快的熟悉那些方法论层面的东西。同时，你自己的思考也是离不开的。我经常会思考，踱步。好的书常看常新，经典的思想，也是需要反复的思忖才能领悟的。&lt;/p&gt;
&lt;h3 id=&quot;我们在路上，前方不会太远&quot;&gt;&lt;a href=&quot;#我们在路上，前方不会太远&quot; class=&quot;headerlink&quot; title=&quot;我们在路上，前方不会太远&quot;&gt;&lt;/a&gt;我们在路上，前方不会太远&lt;/h3&gt;&lt;p&gt;2016年，团队最大的新闻当然就是华师匣子的上线。这个是我们的第一款移动应用，也是将来一切产品的推广基础。&lt;/p&gt;
&lt;p&gt;在我看来，团队最大的成长，一个是技术团队在工程化上慢慢摸索，有了自己的方向。我们的方向就是&lt;strong&gt;通过造轮子来深入原理，积极的实践最新的技术，写完善的文档，在社区中争取拥有一定的影响力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在团队的管理上，确立了早读制度，试行了导师制度，管理工作组共同管理团队，成功的进行了秋游，招新算是顺利，团队管理层平滑更换。这些都是一个团队平稳运行的基石。如果说这个大框架搭好了，我们就可以把精力投入到具体的产品和新人培养中去了。&lt;/p&gt;
&lt;p&gt;在接下里的日子里，我们要把产品的汇报制度完善，项目组的气氛要更好，全员大会要常态化，组内技术积累要抓紧，新人双轨培养的计算机基础方向需要花很大的力气建设，UED部门要重新上路。&lt;/p&gt;
&lt;p&gt;对于团队的期望，我不想说太多，我只能说，作为一个木犀人，你就算毕业了，也依然要参与到团队的建设中去，只是不在第一线了而已。只有这样才能慢慢的把事情做好。我们追求的是理想中的团队，可能我们永远都无法到达那个理想中的境界，但一直在成长，一直在进步的话，大家开开心心的，就挺好。&lt;/p&gt;
&lt;p&gt;我们在路上，前方不会太远。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘起：华大桂声技术部&quot;&gt;&lt;a href=&quot;#缘起：华大桂声技术部&quot; class=&quot;headerlink&quot; title=&quot;缘起：华大桂声技术部&quot;&gt;&lt;/a&gt;缘起：华大桂声技术部&lt;/h3&gt;&lt;p&gt;2013年10月我加入华大桂声技术部。其实一开始我加的是华大青年，但因为那里没有专门的技术部，面试的时候也没有做技术的人面我，所以我在得知桂声招新的情况下，放弃了华青那边的录取。&lt;/p&gt;
&lt;p&gt;于是就开始了在桂声技术部的日子。那个时候其实i华大已经建立了，但桂声还是比较强势一些。那段时间主要就是在一个2011级学姐的带领下做桂声的专题和网站。我记得我来的那年之前做了110周年校庆专题和迎新网，都很不错。桂声的专题是很有特色的，现在我们也试图去捡起这个传统。&lt;/p&gt;
&lt;p&gt;我接到的第一个任务是做一个恽代英专题，在炳权学长的指导下，顺利的做出来了。关于这个我记得比较清楚的细节，一个是熄灯了之后搬个凳子去走廊里做，还有一个是上线了之后很兴奋，发给很多人看。&lt;/p&gt;
&lt;p&gt;接下来就是下半学期开始的桂声改版，我写了一部分的主页。那个时候，我其实压根就不会写真正的代码，如果要用到JS，比如轮播图，我就去网站下一个功能差不多的插件，然后修改一下。这个过程其实是很痛苦的，因为你心里并没有底。所以每次把插件改好都像是一场战役。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>华师匣子iOS版开发记</title>
    <link href="http://yoursite.com/2016/12/19/ios-story/"/>
    <id>http://yoursite.com/2016/12/19/ios-story/</id>
    <published>2016-12-19T03:28:35.000Z</published>
    <updated>2016-12-21T12:44:19.000Z</updated>
    
    <content type="html">&lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是匣子iOS的Github提交图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-12-21%20at%208.39.43%20PM.png&quot; alt=&quot;iOS Github&quot;&gt;&lt;/p&gt;
&lt;p&gt;上个学期我接下iOS版开发的任务时，其实我心里是没底的。没学过iOS是一方面，关键是我也没有任何客户端开发的经验。当时我对客户端开发的了解几乎为0。之前有接触过一点安卓。但iOS这边玄学的StoryBoard和新语言Swift都让我比较没底。&lt;/p&gt;
&lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h3&gt;&lt;p&gt;我首先看了斯坦福的&lt;a href=&quot;http://web.stanford.edu/class/cs193p/cgi-bin/drupal/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS开发课程&lt;/a&gt;。这个课程是一个非常不错的课程。里面实现一个计算器，代码的结构非常的合理，也充分发挥了Swift的特性。当时我的感觉就是，写APP或者其他业务并不是会调API就好，如果想要写漂亮的代码，那还是需要扎实的计算机基础。&lt;/p&gt;
&lt;p&gt;我看着课程，但我并没有跟着写，因为时间不多了。我在了解了基本的MVC架构、StoryBoard中拖控件、拖Outlet和Action、Auto Layout之后，就开始写匣子的几个界面。&lt;/p&gt;
&lt;p&gt;当时写了界面之后，就有所感触了。首先Auto Layout的确是一个非常好的布局方式，让我不再怀念CSS。然后，原生APP中首先所有的组件都是有与之对应的对象实例的，这是顺理成章的事情。但在Web这边，组件需要自己抽象，而且在Web Component没有普及之前，没有原生级别的支持。写iOS的过程中我越发明白，DOM其实只是Web界面UI的实现细节。我们要用某种方式去封装DOM，在UI抽象层编写代码。iOS就完全符合这种方式。想来客户端软件理应是这样的。只不过Web技术从一开始并不是为客户端软件打造的，因此这几年前端走的路，基本就是补上之前落下的课。&lt;/p&gt;
&lt;p&gt;当然Web前端数据驱动，双向绑定这些，在我看来已经是最前沿的东西了。iOS这边肯定也有。但因为我对前端更了解一些，所以觉得前端要更优雅一些。&lt;/p&gt;
&lt;p&gt;最开始做图书馆，于是就遇到了输入框键盘如何收起的问题。点击return，点击屏幕的其他地方都会收起键盘。这里要提到一点，就是这次0基础做iOS，是我第一次在全英文的环境下从头开始学一门技术。这次我全程一行中文都没有看。回头想想，很难想象如何在中文社区解决这些问题。&lt;/p&gt;
&lt;h3 id=&quot;深入&quot;&gt;&lt;a href=&quot;#深入&quot; class=&quot;headerlink&quot; title=&quot;深入&quot;&gt;&lt;/a&gt;深入&lt;/h3&gt;&lt;p&gt;接下来就是各个技术点的学习了。数据持久化要用Core Data，其实就是一个本地的SQLite数据库。这个我基本是当Key Value存储来用了。对数据库还是不是很了解。然后有触摸事件的处理等等。网络请求用Alamofire和SwiftyJSON。学用iOS的Cocoapad装依赖。&lt;/p&gt;
&lt;p&gt;学习的过程中，说起来只有一个比较理论的知识，就是delegate、protocol、extension这些。&lt;/p&gt;
&lt;p&gt;之前在看斯坦福课程的时候还不是很了解。后来用UITableView以及需要不同VC直接通信的时候，就慢慢了解了delegate。我对delegate的了解就是一种委托的模式。任意一个实现了对应接口的对象都可以作为委托的对象。后来在安卓那边了解了一下，大致有同样的实现。&lt;/p&gt;
&lt;p&gt;UITableView实在是一种很经典的接口设计。除了那几个delegate方法之外，UITableView会对Table Cell进行回收的做法，也让我明白了之前面试时问我的长列表优化问题的答案。在Web端我们也可以控制列表只保留可视区域的DOM元素，来做优化。这样不管列表有多少元素，都可以顺利的渲染。&lt;/p&gt;
&lt;h3 id=&quot;课程表&quot;&gt;&lt;a href=&quot;#课程表&quot; class=&quot;headerlink&quot; title=&quot;课程表&quot;&gt;&lt;/a&gt;课程表&lt;/h3&gt;&lt;p&gt;课程表一度是我迟迟不愿意动手的一个模块。其实匣子里大部分模块的逻辑都是简单的查询和拉取数据。课程表也不例外，但课程表的View相对来说比较复杂。我咨询了安卓的同学之后才知道要自己画View，自己handle触摸事件。于是就写了一个双向的滑动，在触摸事件中修改View的偏移。&lt;/p&gt;
&lt;p&gt;画课表的格子也花了我一段时间，最后算是解决了。后期还要再完善。课程表的实现让我得以一窥iOS开发的常态———自定义View。实际上大部分的控件应该还是需要自己来写的，毕竟大家的APP看上去都很Unique。&lt;/p&gt;
&lt;p&gt;iOS的View可以自定义drawRect方法。这应该就是暴露了底层的2D绘图API，类似于Web中的Canvas。&lt;/p&gt;
&lt;h3 id=&quot;收尾&quot;&gt;&lt;a href=&quot;#收尾&quot; class=&quot;headerlink&quot; title=&quot;收尾&quot;&gt;&lt;/a&gt;收尾&lt;/h3&gt;&lt;p&gt;其他大大小小的问题还有很多，比如我一度纠结于如何取消Navigation bar上面返回按钮的文字，结果发现在Story Board里面的Back Button打一个空格就行了。踩了很多坑，有一个很大的坑就是我一度用中文做了包名，导致后来数据迁移一直报错。&lt;/p&gt;
&lt;p&gt;Banner的话，最后是用原生的UIPageView实现的。之前一度以为要自己实现一个。想来自己的水平还是不够的。&lt;/p&gt;
&lt;p&gt;后期陆续完成了数据迁移，远程推送，本地推送，闪屏处理，还有和后端元信息API的整合。&lt;/p&gt;
&lt;p&gt;上线的时候，担心我们的服务器不支持IPv6，担心不会过审。不过最后很顺利的过审核了。苹果的工作效率没有想象中的那么低。&lt;/p&gt;
&lt;p&gt;苹果要求HTTPS和IPv6，Safari10支持全部ES6属性。这意味着苹果一直走在时代的最前沿。在这一点上我要给苹果点赞。&lt;/p&gt;
&lt;p&gt;这次iOS的开发算是让我获得了iOS的初级开发经验，点亮了客户端开发的技能点。为后续我的Hybrid研究开了一个好头。&lt;/p&gt;
&lt;h3 id=&quot;关于Swift&quot;&gt;&lt;a href=&quot;#关于Swift&quot; class=&quot;headerlink&quot; title=&quot;关于Swift&quot;&gt;&lt;/a&gt;关于Swift&lt;/h3&gt;&lt;p&gt;Swift给我的印象还是很不错的。静态类型，经典的面向对象，外加和JS类似的函数式特性，我用起来觉得很顺手。OC看起来太恐怖了，如果不是有Swift，想来我也不会鼓起勇气去写iOS。Swift未来还会进军服务端，虽然是Apple自家的东西，但开源了，想来发展应该会是不错的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个月华师匣子的iOS版终于上线，历时四个多月的开发告一段落。我达成了从客户端开发0基础到App Store的成就。四个多月，99次提交，10个内测版本，两次App Store发布，这实在是一个值得纪念的时刻。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Build your own Vuejs Chapter1 Vue Overview</title>
    <link href="http://yoursite.com/2016/12/12/build-your-own-vuejs-1/"/>
    <id>http://yoursite.com/2016/12/12/build-your-own-vuejs-1/</id>
    <published>2016-12-12T09:11:50.000Z</published>
    <updated>2016-12-12T09:17:47.000Z</updated>
    
    <content type="html">&lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Chapter1-Vuejs-Overview&quot;&gt;&lt;a href=&quot;#Chapter1-Vuejs-Overview&quot; class=&quot;headerlink&quot; title=&quot;Chapter1: Vuejs Overview&quot;&gt;&lt;/a&gt;Chapter1: Vuejs Overview&lt;/h2&gt;&lt;p&gt;Vuejs is a simple yet powerful MVVM library. It helps us to build a modern user interface for the web.&lt;/p&gt;
&lt;p&gt;By the time of writing, Vuejs has 36,312 stars on Github. And 230,250 monthly downloads on npm. Vuejs 2.0 brings in a lightweight virtual DOM implementation for render layer. This unlock more possibilities like server-side rendering and native component rendering.&lt;/p&gt;
&lt;p&gt;Vuejs claims to be a progressive JavaScript framework. Though the core library of Vuejs is quite small. Vuejs has many accompanying tools &amp;amp; supporting libraries. So you can build large-scale application using the Vuejs ecosystem.&lt;/p&gt;
&lt;h3 id=&quot;Components-of-Vuejs-internals&quot;&gt;&lt;a href=&quot;#Components-of-Vuejs-internals&quot; class=&quot;headerlink&quot; title=&quot;Components of Vuejs internals&quot;&gt;&lt;/a&gt;Components of Vuejs internals&lt;/h3&gt;&lt;p&gt;Let’s get acquaintance with the core components of Vuejs internals. Vue internals falls into serval parts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Vue%20source%20overview.png&quot; alt=&quot;Vue internal&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Instance-lifecycle&quot;&gt;&lt;a href=&quot;#Instance-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;Instance lifecycle&quot;&gt;&lt;/a&gt;Instance lifecycle&lt;/h4&gt;&lt;p&gt;A new Vue instance will go through several phases. Such as observing data, initializing events, compiling the template, and render. And you can register  lifecycle hooks that will be called in the specific phase.&lt;/p&gt;
&lt;h4 id=&quot;Reactivity-system&quot;&gt;&lt;a href=&quot;#Reactivity-system&quot; class=&quot;headerlink&quot; title=&quot;Reactivity system&quot;&gt;&lt;/a&gt;Reactivity system&lt;/h4&gt;&lt;p&gt;The so called &lt;em&gt;reactivity system&lt;/em&gt; is where vue’s data-view binding magic comes from. When you set vue instance’s data, the view updated accordingly, and vice versa. &lt;/p&gt;
&lt;p&gt;Vue use &lt;code&gt;Object.defineProperty&lt;/code&gt; to make data object’s property reactive. Along with the famous &lt;em&gt;Observer Pattern&lt;/em&gt; to link data change and view render together.&lt;/p&gt;
&lt;h4 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h4&gt;&lt;p&gt;Virtual DOM is the tree representation of the actual DOM tree that lives in the memory as JavaScript Objects. &lt;/p&gt;
&lt;p&gt;When data changes, vue will render a brand new virtual DOM tree, and keep the old one. The virtual DOM module diff two trees and patch the change into the actual DOM tree.&lt;/p&gt;
&lt;p&gt;Vue use &lt;a href=&quot;https://github.com/snabbdom/snabbdom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;snabbdom&lt;/a&gt; as the base of its virtual DOM implementation. And modify a bit to make it work with Vue’s other component.&lt;/p&gt;
&lt;h4 id=&quot;Compiler&quot;&gt;&lt;a href=&quot;#Compiler&quot; class=&quot;headerlink&quot; title=&quot;Compiler&quot;&gt;&lt;/a&gt;Compiler&lt;/h4&gt;&lt;p&gt;The job of the compiler is to compile template into render functions(ASTs). It parses HTML along with Vue directives (Vue directives are just plain HTML attribute) and other entities into a tree. It also detects the maximum static sub trees (sub trees with no dynamic bindings) and hoists them out of the render. The HTML parser Vue uses is originally written by &lt;a href=&quot;http://ejohn.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John Resig&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We will not cover the implementation detail of the Compiler in this book. Since we can use build tools to compile vue template into render functions in build time, Compiler is not a part of vue runtime. And we can even write render functions directly, so Compiler is not an essential part to understand vue internals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Set-up-development-environment&quot;&gt;&lt;a href=&quot;#Set-up-development-environment&quot; class=&quot;headerlink&quot; title=&quot;Set up development environment&quot;&gt;&lt;/a&gt;Set up development environment&lt;/h3&gt;&lt;p&gt;Before we can start building our own Vue.js, we need to set up a few things. Including module bundler and testing tools, since we will use a test-driven workflow.&lt;/p&gt;
&lt;p&gt;Since this is a JavaScript project, and we’gonna use some fancy tools, the first thing to do is run &lt;code&gt;npm init&lt;/code&gt; and set up some information about this project. &lt;/p&gt;
&lt;h4 id=&quot;Set-up-Rollup-for-module-bundling&quot;&gt;&lt;a href=&quot;#Set-up-Rollup-for-module-bundling&quot; class=&quot;headerlink&quot; title=&quot;Set up Rollup for module bundling&quot;&gt;&lt;/a&gt;Set up Rollup for module bundling&lt;/h4&gt;&lt;p&gt;We will use Rollup for module bundling. &lt;a href=&quot;http://rollupjs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rollup&lt;/a&gt; is a JavaScript module bundler. It allows you to write your application or library as a set of modules – using modern ES2015 import/export syntax. And Vuejs use Rollup for module bundling too.&lt;/p&gt;
&lt;p&gt;We gotta write a configuration for Rollup to make it work. Under root directory, touch &lt;code&gt;rollup.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  entry: &amp;#39;src/instance/index.js&amp;#39;,
  format: &amp;#39;umd&amp;#39;,
  moduleName: &amp;#39;Vue&amp;#39;,
  dest: &amp;#39;dist/vue.js&amp;#39; 
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And don’t forget to run &lt;code&gt;npm install rollup rollup-watch --save-dev&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;Set-up-Karma-and-Jasmine-for-testing&quot;&gt;&lt;a href=&quot;#Set-up-Karma-and-Jasmine-for-testing&quot; class=&quot;headerlink&quot; title=&quot;Set up Karma and Jasmine for testing&quot;&gt;&lt;/a&gt;Set up Karma and Jasmine for testing&lt;/h4&gt;&lt;p&gt;Testing will require quite a few packages, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install karma jasmine karma-jasmine karma-chrome-launcher
 karma-rollup-plugin --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Under root directory, touch &lt;code&gt;karma.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(config) {
  config.set({
    frameworks: [&amp;#39;jasmine&amp;#39;],
    files: [
      &amp;#39;./test/**/*.js&amp;#39;
    ],
    browsers: [&amp;#39;Chrome&amp;#39;],
    preprocessors: {
     &amp;#39;./test/**/*.js&amp;#39;: [&amp;#39;rollup&amp;#39;]
    },
    rollupPreprocessor: {
      format: &amp;#39;iife&amp;#39;,
      sourceMap: &amp;#39;inline&amp;#39;
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Directory-structure&quot;&gt;&lt;a href=&quot;#Directory-structure&quot; class=&quot;headerlink&quot; title=&quot;Directory structure&quot;&gt;&lt;/a&gt;Directory structure&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- package.json
- rollup.conf.js
- node_modules
- dist
- test
- src
    - observer
    - instance
    - util
    - vdom
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Bootstrapping&quot;&gt;&lt;a href=&quot;#Bootstrapping&quot; class=&quot;headerlink&quot; title=&quot;Bootstrapping&quot;&gt;&lt;/a&gt;Bootstrapping&lt;/h3&gt;&lt;p&gt;We’ll add some npm script for convenience. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;package.json&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
   &amp;quot;build&amp;quot;: &amp;quot;rollup -c&amp;quot;,
   &amp;quot;watch&amp;quot;: &amp;quot;rollup -c -w&amp;quot;,
   &amp;quot;test&amp;quot;: &amp;quot;karma start&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To bootstrap our own Vuejs, let’s write our first test case.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;test/options/options.spec.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &amp;quot;../src/instance/index&amp;quot;;

describe(&amp;#39;Proxy test&amp;#39;, function() {
  it(&amp;#39;should proxy vm._data.a = vm.a&amp;#39;, function() {
      var vm = new Vue({
          data:{
              a:2
          }
      })
    expect(vm.a).toEqual(2);
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This test case tests whether props on vm’s data like &lt;code&gt;vm._data.a&lt;/code&gt; are proxied to vm itself, like &lt;code&gt;vm.a&lt;/code&gt;. This is one of Vue’s little tricks.&lt;/p&gt;
&lt;p&gt;So we can write our first line of real code now, in &lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/index.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initMixin } from &amp;#39;./init&amp;#39;

function Vue (options) {
  this._init(options)
}

initMixin(Vue)

export default Vue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is nothing exciting, just Vue constructor calling &lt;code&gt;this._init&lt;/code&gt;. So let’s find out how the &lt;code&gt;initMixin&lt;/code&gt; fucntion work:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/init.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { initState } from &amp;#39;./state&amp;#39;

export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
      var vm = this
      vm.$options = options
      initState(vm)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The instance method of Vue Class are injected using a mixin pattern. We’ll find this mixin pattern quite common when writing Vuejs’s instance method later. Mixin is just a function that takes a constructor, add some methods to its prototype, and return the constructor.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;initMixin&lt;/code&gt; add &lt;code&gt;_init&lt;/code&gt; method to &lt;code&gt;Vue.prototype&lt;/code&gt;. And this method calls &lt;code&gt;initState&lt;/code&gt; from &lt;code&gt;state.js&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;src/instance/state.js&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
export function initState(vm) {
  initData(vm)
}

function initData(vm) {
  var data = vm.$options.data
  vm._data = data
  // proxy data on instance
  var keys = Object.keys(data)

  var i = keys.length
  while (i--) {
    proxy(vm, keys[i])
  }
}

function proxy(vm, key) {
    Object.defineProperty(vm, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter() {
        return vm._data[key]
      },
      set: function proxySetter(val) {
        vm._data[key] = val
      }
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we got to the place where proxy takes place. &lt;code&gt;initState&lt;/code&gt; calls &lt;code&gt;initData&lt;/code&gt;, and &lt;code&gt;initData&lt;/code&gt; iterates all keys of &lt;code&gt;vm._data&lt;/code&gt;, calls &lt;code&gt;proxy&lt;/code&gt; on each value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt; define a property on &lt;code&gt;vm&lt;/code&gt; using the same key, and this property has both getter and setter, which actually get/set data from &lt;code&gt;vm._data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So that’s how &lt;code&gt;vm.a&lt;/code&gt; is proxied to &lt;code&gt;vm._data.a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;npm run build&lt;/code&gt; and &lt;code&gt;npm run test&lt;/code&gt;. You should see something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn4.snapgram.co/images/2016/12/11/ScreenShot2016-12-12at2.02.17AM.png&quot; alt=&quot;success&quot;&gt;&lt;/p&gt;
&lt;p&gt;Bravo! You successfully bootstrapped your own Vuejs! Keep working!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In the book Build your own Vuejs, we will build a Vuejs from scratch. And you will learn how Vuejs works internally, which helps a lot for your daily development with vue.&lt;/p&gt;
&lt;p&gt;Inspired by the amazing book Build your own Angularjs, the code of Build your own Vuejs will be developed in a test-driven way.&lt;/p&gt;
&lt;p&gt;We’ll focus on Vuejs 2.0. And we assume our reader have played around with Vuejs once and know basics about Vuejs APIs.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊Chrome Devtools的Timeline</title>
    <link href="http://yoursite.com/2016/11/29/timeline/"/>
    <id>http://yoursite.com/2016/11/29/timeline/</id>
    <published>2016-11-29T12:15:49.000Z</published>
    <updated>2016-11-30T08:46:41.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Timeline的使用场景&quot;&gt;&lt;a href=&quot;#Timeline的使用场景&quot; class=&quot;headerlink&quot; title=&quot;Timeline的使用场景&quot;&gt;&lt;/a&gt;Timeline的使用场景&lt;/h3&gt;&lt;p&gt;Timeline的使用场景一个是在页面发生明显的卡顿时，比如CSS动画或者页面滚动时，用来分析卡顿的原因。还有一个场景便是进行页面渲染性能的评估，看页面渲染性能是否有优化的空间，或者通过截图观察页面渲染的过程，优化&lt;a href=&quot;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Speed Index&lt;/a&gt;来提升用户体验。&lt;/p&gt;
&lt;h3 id=&quot;关于渲染&quot;&gt;&lt;a href=&quot;#关于渲染&quot; class=&quot;headerlink&quot; title=&quot;关于渲染&quot;&gt;&lt;/a&gt;关于渲染&lt;/h3&gt;&lt;p&gt;我们知道，如果以每秒16-24帧的速度连续播放图片，那人就会产生动画的幻觉。在UI动画中，因为目前主流显示设备的刷新率达到了60Hz，我们追求的的帧率是60fps。那理想情况下，每一帧的时间应该是&lt;code&gt;1/60=16.67ms&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;又因为JavaScript是单线程事件驱动的模型。所以浏览器在一帧之内要完成JavaScript脚本的运行，然后计算，合成这帧画面，并渲染。&lt;/p&gt;
&lt;h3 id=&quot;Long-Frame&quot;&gt;&lt;a href=&quot;#Long-Frame&quot; class=&quot;headerlink&quot; title=&quot;Long Frame&quot;&gt;&lt;/a&gt;Long Frame&lt;/h3&gt;&lt;p&gt;所谓的Long Frame，也就是我们在Timeline的FPS中被标注为红色（如下图）的那些帧，便是用时超过正常标准的那些帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/longframe.png&quot; alt=&quot;longframe&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;long frame&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Long Frame往往意味着卡顿，因为帧率低于60fps，甚至30fps。我们会通过查看这帧中的JS运行情况，浏览器渲染情况，以及浏览器用户触发事件的情况来分析卡顿的原因。&lt;/p&gt;
&lt;h3 id=&quot;Timeline中有价值的数据&quot;&gt;&lt;a href=&quot;#Timeline中有价值的数据&quot; class=&quot;headerlink&quot; title=&quot;Timeline中有价值的数据&quot;&gt;&lt;/a&gt;Timeline中有价值的数据&lt;/h3&gt;&lt;h4 id=&quot;JS调用栈&quot;&gt;&lt;a href=&quot;#JS调用栈&quot; class=&quot;headerlink&quot; title=&quot;JS调用栈&quot;&gt;&lt;/a&gt;JS调用栈&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/jsstack.png&quot; alt=&quot;jscallstack&quot;&gt;&lt;br&gt;&lt;em&gt;JS Call Stack&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果是JS运行时间过长，比如超过10ms，那我们就有必要检查这个JS的调用栈，可以通过查看Details一栏中的Bottom-up选项卡来看到自顶向下的调用信息。分析那个函数调用占用了过多的时间，并加以解决。&lt;/p&gt;
&lt;h4 id=&quot;浏览器渲染信息&quot;&gt;&lt;a href=&quot;#浏览器渲染信息&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染信息&quot;&gt;&lt;/a&gt;浏览器渲染信息&lt;/h4&gt;&lt;p&gt;浏览器渲染每一帧画面，需要经过这些阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/frame-full.jpg&quot; alt=&quot;render&quot;&gt;&lt;br&gt;&lt;em&gt;render pipeline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其中我们需要避免的主要就是Layout，如果触发了Layout的重新计算，那就意味着你的页面需要重绘，这是一个非常expensive的任务。如果我们在CSS动画时使用了GPU加速，那这些动画就不会造成重绘，而是作为一个单独的层在Compose阶段进行组合。&lt;/p&gt;
&lt;p&gt;如果是浏览器渲染用时过多，我们就需要检查代码中是否触发了不必要的浏览器重绘。这方面的优化主要是针对CSS的优化，是一个专门的专题。一般的措施是采用CSS3 transform进行动画，开启硬件加速来避免浏览器重绘。&lt;/p&gt;
&lt;h4 id=&quot;事件输入&quot;&gt;&lt;a href=&quot;#事件输入&quot; class=&quot;headerlink&quot; title=&quot;事件输入&quot;&gt;&lt;/a&gt;事件输入&lt;/h4&gt;&lt;p&gt;我们可以在Flame Chart的Interaction部分看到浏览器在这段时间触发的事件。&lt;/p&gt;
&lt;p&gt;用户注册的事件，都有对应的回调函数。因此如果这个回调函数包含大量的逻辑，并且这个事件触发非常频繁的话，比如scroll或者touchmove，那我们就需要对事件触发的频率进行限制。在防止回调函数频繁触发层面，对应的办法有JS层面的节流函数。在限制事件注册的数量层面，我们可以使用事件代理，尽量避免在一个DOM元素上注册多个触发频繁的事件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题外话：在调试移动端页面时，我发现Chrome在Timeline里标出了pinch这样的事件。说明浏览器的渲染层是支持这样的高级事件的。但在DOM的标准中没有找到这样的事件。需要大家用touch事件来合成。Chrome的这个做法不知道应该理解成浏览器面向未来的支持，还是浏览器私有的实现。当然，在移动端的操作系统层面，识别pinch应该不是一个难事。DOM的touch event中没有支持pinch，swipe等事件，这个问题值得思考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;其他数据&quot;&gt;&lt;a href=&quot;#其他数据&quot; class=&quot;headerlink&quot; title=&quot;其他数据&quot;&gt;&lt;/a&gt;其他数据&lt;/h4&gt;&lt;p&gt;Timeline中还有很多有价值的数据，比如CPU占有率，JS的Heap大小（可以简单的理解成JS的内存占用情况），DOM节点的数量，事件监听器的数量等等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在进行移动端Web页面的性能调优时用到了Chrome Devtools的Timeline。Timeline主要是针对浏览器渲染引擎的相关数据进行记录。关于Timeline的介绍可以看&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;官方文档&lt;/a&gt;。下面主要说说实际应用时如何来分析Timeline的数据，然后优化页面。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unix·Talk 聊聊工程</title>
    <link href="http://yoursite.com/2016/11/19/unix-talk-engineering/"/>
    <id>http://yoursite.com/2016/11/19/unix-talk-engineering/</id>
    <published>2016-11-19T02:43:14.000Z</published>
    <updated>2016-11-29T14:50:59.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;工程是什么&quot;&gt;&lt;a href=&quot;#工程是什么&quot; class=&quot;headerlink&quot; title=&quot;工程是什么&quot;&gt;&lt;/a&gt;工程是什么&lt;/h3&gt;&lt;p&gt;首先请大家观察这两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/Screen%20Shot%202016-11-27%20at%207.00.59%20PM.png&quot; alt=&quot;vs&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果说左边的小草房是课程作业的话，那右边的高楼大厦，就是我们所说的工程。&lt;/p&gt;
&lt;p&gt;大家可以思考一下，建造两者的过程有何不同。建左边的小房子也许不需要太多的材料，也不需要对材料进行深度的加工。在设计上，只要有基本的构想即可，不需要精准的蓝图。在施工上也相对随性一些。&lt;/p&gt;
&lt;p&gt;而右边的高楼大厦，需要钢筋混凝土这种深度加工的材料去构建，需要严密的蓝图和施工周期。同时也需要数百倍于左图的人力去建造。&lt;/p&gt;
&lt;p&gt;从产出的规模和流程的复杂度来说，软件工程师和建筑工程师或者电气工程师一样，都在一套成熟的流程和体系下，打造大规模的产品。&lt;/p&gt;
&lt;p&gt;所以，在互联网行业，工程就是一套完整的产品研发方法论。同时也包括项目开发周期中的项目管理，前期估算，后期测试等流程。&lt;/p&gt;
&lt;p&gt;那为什么我们需要这套方法论呢？很简单。如果没有这套方法论指导，我们就无法顺利的开发出大型的软件，或者，我们的开发效率会很低。我们需要用工具来加速我们的开发，自动化一些无聊的工作。我们需要用设计模式来解耦我们的代码，让代码的可维护性更高。我们也需要项目管理，来让不同分工的工程师协同工作，顺利完工。&lt;/p&gt;
&lt;p&gt;而这套方法论，学校里是很少有讲到的。这也是因为，工程相关的方法论需要工程师在项目开发的过程中不断的实践总结，毕竟纸上得来终觉浅，而工程这种和实际问题特别相关的方向，则更需要在实际的项目才能有更深入的理解。&lt;/p&gt;
&lt;h3 id=&quot;工程的几个关键词&quot;&gt;&lt;a href=&quot;#工程的几个关键词&quot; class=&quot;headerlink&quot; title=&quot;工程的几个关键词&quot;&gt;&lt;/a&gt;工程的几个关键词&lt;/h3&gt;&lt;h4 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h4&gt;&lt;p&gt;俗话说，没有金刚钻，就不揽瓷器活。无论是客户端还是服务端，大家都有专属的神兵利器。&lt;/p&gt;
&lt;p&gt;其中大家使用频率最高的便是编辑器或者IDE。前端有Sublime，安卓有Android Studio，iOS有Xcode，后端有Vim。强大的IDE往往&lt;br&gt;包含了从代码提示到编译打包的一条路服务。而Sublime这样的轻量级编辑器，需要我们进行各种DIY，打造成自己想要的样子。好用的编辑器往往会提高开发的效率，带来生产力的提高。&lt;/p&gt;
&lt;p&gt;在客户端开发中，打包构建工具也是一个重要的类别。好用的打包工具不仅仅可以降低打包的时间，在前端等领域，好用的打包工具甚至代表了一种工具生态，串联起了一个完整的工具链。&lt;/p&gt;
&lt;p&gt;开发中用到的工具还有很多。很多小工具的诞生，往往是为了解决某一个具体问题的。程序员往往希望一切机械的事务都可以自动化。并且也喜欢将繁杂的数据可视化。这两个动机驱动了很多小工具的诞生。&lt;/p&gt;
&lt;p&gt;趁手的工具代表了先进的生产力。这也是构建大型工程时必须借助的垫脚石。工程化程度高的技术团队，往往都有着自己的先进工具。&lt;/p&gt;
&lt;h4 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h4&gt;&lt;p&gt;编码规范包括代码风格，目录结构等等。这些编码规范的存在，一方面是约束团队成员的代码质量，使得一些低级错误和语言中的bad practice得到提醒和控制。一方面，代码规范中的一些代码风格相关的部分，是为了让团队成员的代码风格统一，这样有利于后期代码库的维护和迭代。&lt;/p&gt;
&lt;p&gt;我们可以使用一些Lint工具和持续集成等技术来将编码规范落地。一个团队的编码规范应该被写在一个单独的仓库或者文档里，以供团队成员参考。&lt;/p&gt;
&lt;h4 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h4&gt;&lt;p&gt;设计模式有很多，从常见的工厂模式，单例模式，观察者模式，装饰器模式等到应用架构层面的MVC，MVVM等。&lt;/p&gt;
&lt;p&gt;设计模式主要帮我们将一个大型的系统解耦成不同的层次。比如将数据层和视图层分离，并用一个中间层将二者联系起来。&lt;/p&gt;
&lt;p&gt;因为大型的系统的模块数量众多，不同模块之间关系复杂。我们要用设计模式来将不同的模块划入不同的层次。&lt;/p&gt;
&lt;p&gt;而观察者模式这样的设计模式主要是为了使模块之间可以实现松耦合下的通信。虽然模块之间有着各种的依赖和调用关系，但我们并不打算让不同模块直接相互调用，而是实现一套接口，并借助中间人通信。这样如果某个模块被替换，只要新的模块实现了相同的接口，整个系统依然可以正常运行。&lt;/p&gt;
&lt;p&gt;在开发软件时，我们一般都遵循一套成熟的模式，在此基础上，完成业务代码的编写。设计模式也是大型软件的基石。&lt;/p&gt;
&lt;p&gt;对于设计模式，关键点往往不是你能说出几个设计模式，而是你懂得在什么情况下使用合适的设计模式。&lt;/p&gt;
&lt;h4 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h4&gt;&lt;p&gt;现在主流的版本控制工具是Git。Git主要的作用是版本控制，同时也帮助我们进行多人的协作。&lt;/p&gt;
&lt;p&gt;没有Git的话，如果我们需要保留多个不同版本的代码，就需要手动保存。在多人协作时，没有Git也是无法想象的。比如用FTP进行协作，每次都覆盖式的保存，这样的的代码管理无疑是非常原始的。&lt;/p&gt;
&lt;p&gt;事实上Git的Branch以及Github的pull request等等机制造就了一套独特的Git工作流。这套工作流无疑是团队协作的最佳选择之一。&lt;/p&gt;
&lt;h4 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h4&gt;&lt;p&gt;其实编程的精华便在于对过程（precedure）以及数据的抽象。这是一种编程的内功。通过对过程的抽象，我们可以将程序中可复用的模块提取成单独的函数，然后进行组合，这样可以大大增强程序的表现力。通过对数据的抽象，我们可以封装数据的细节，从一个更通用的维度来对数据进行操作。&lt;/p&gt;
&lt;p&gt;对于抽象，推荐大家看《计算机程序的构造与解释》这本书。当然抽象要合理才行，过度的抽象也会使代码的易读性受损。&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h4&gt;&lt;p&gt;测试主要是为了保证软件的质量。在软件被开发完成之后，会进行一系列的测试，以保证软件的高可用性。一般团队会有专门的测试工程师。负责测试用例的编写。&lt;/p&gt;
&lt;p&gt;对于后端这样主要负责数据处理的逻辑，我们可以编写自动化的单元测试，并且进行持续集成。单元测试以一个模块为单元进行测试，这样我们在错误发生时，可以准确的定位到具体的模块。单元测试也被用在测试驱动的开发中，测试驱动的开发就是先写测试用例，然后编写可以通过这个测试用例的代码。&lt;/p&gt;
&lt;p&gt;对于客户端代码来说，因为UI复杂多变。所以自动化的单元测试只有在对框架/库的代码进行测试时比较实际，在业务逻辑层面，比如视图层，我们一般采用人工测试。当然现在也有自动化的UI测试方案。&lt;/p&gt;
&lt;h4 id=&quot;项目管理&quot;&gt;&lt;a href=&quot;#项目管理&quot; class=&quot;headerlink&quot; title=&quot;项目管理&quot;&gt;&lt;/a&gt;项目管理&lt;/h4&gt;&lt;p&gt;项目管理，是学校软件工程课程中主要涉及的。这个主要涉及传统软件的开发流程。从需求分析，成本估算，开发流程到最后的测试。&lt;/p&gt;
&lt;p&gt;互联网的开发模型上主要还是比较敏捷的迭代。通常以一个月甚至几周的周期进行迭代。其中Web应用的特点便是可以随时发布更新，所以在这方面显得更突出一些。&lt;/p&gt;
&lt;p&gt;关于项目管理或者软件工程，大家可以去看《人月神话》，《构建之法》等书。虽然这些书主要针对的是传统软件工程，但我们在互联网产品的开发中还是可以从中汲取一些经验的。&lt;/p&gt;
&lt;h3 id=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;a href=&quot;#适合我们团队的一套工程化流程&quot; class=&quot;headerlink&quot; title=&quot;适合我们团队的一套工程化流程&quot;&gt;&lt;/a&gt;适合我们团队的一套工程化流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技术选型&lt;/strong&gt;-选用最合适的技术栈，当然为了把玩新技术而选用比较新的技术栈也是可以的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合适的工具&lt;/strong&gt;-鼓励大家，没有在开源社区找到符合自己要求的工具时，打造自己专属的工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git协作&lt;/strong&gt;-Git工作流&lt;/li&gt;
&lt;li&gt;代码规范&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;项目架构&lt;/strong&gt;-合适的抽象，不仅仅是MVC等架构，也包括其他可以复用的组件和Utility模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码审查&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单元测试（后端）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人肉或自动测试（客户端）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Unix·Talk是今年开始实行的木犀团队系列技术分享，面向的是团队内所有的技术同学，尤其是新人。在这个系列分享里，我们会聊聊计算机硬件，工程化实践，互联网文化，当然也会聊聊和Unix操作系统有关的一切。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自制Vue插件</title>
    <link href="http://yoursite.com/2016/11/13/vue-finger/"/>
    <id>http://yoursite.com/2016/11/13/vue-finger/</id>
    <published>2016-11-13T08:21:56.000Z</published>
    <updated>2016-11-30T08:48:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-finger，一个插件的诞生&quot; class=&quot;headerlink&quot; title=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;/a&gt;Vue-finger，一个插件的诞生&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vue的插件化机制&quot;&gt;&lt;a href=&quot;#Vue的插件化机制&quot; class=&quot;headerlink&quot; title=&quot;Vue的插件化机制&quot;&gt;&lt;/a&gt;Vue的插件化机制&lt;/h3&gt;&lt;h3 id=&quot;Vue-finger，一个插件的诞生&quot;&gt;&lt;a href=&quot;#Vue-fin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊CSS Modules</title>
    <link href="http://yoursite.com/2016/11/12/css-modules/"/>
    <id>http://yoursite.com/2016/11/12/css-modules/</id>
    <published>2016-11-12T12:02:32.000Z</published>
    <updated>2016-11-13T09:22:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决全局作用域：Webpack-css-loader&quot;&gt;&lt;a href=&quot;#解决全局作用域：Webpack-css-loader&quot; class=&quot;headerlink&quot; title=&quot;解决全局作用域：Webpack css-loader&quot;&gt;&lt;/a&gt;解决全局作用域：Webpack css-loader&lt;/h3&gt;&lt;p&gt;Webpack的css-loader首先做出了解决全局作用域的尝试。解决办法就是在写CSS类名时加入&lt;code&gt;:local(...)&lt;/code&gt;这样的标记。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:local(.className) { background: red; }
:local .className { color: green; }
:local(.className .subClass) { color: green; }
:local .className .subClass :global(.global-class-name) { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转化为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;._23_aKvs-b8bW2Vg3fwHozO { background: red; }
._23_aKvs-b8bW2Vg3fwHozO { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 { color: green; }
._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 .global-class-name { color: blue; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的办法就是把CSS类名转化为hash字符串，这样就可以保证每个类名都是独一无二的，自然也就不用在意命名冲突的问题了。只要在类名在当前模块内不会相互冲突就可以了。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules&quot;&gt;&lt;a href=&quot;#CSS-Modules&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules&quot;&gt;&lt;/a&gt;CSS Modules&lt;/h3&gt;&lt;p&gt;上述的办法，还是有一些不便。大多数情况下，比如在JavaScript中，变量都默认是局部变量。你想要声明一个全局变量，只能去全局作用域声明，或者把变量挂到local上（非严格模式下，不写var声明的是全局变量这种坑就不说了）。&lt;/p&gt;
&lt;p&gt;Webpack的开发者之后将css-loader中的local变成了默认设定，于是CSS Modules这个规范就呼之欲出了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/css-modules/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules规范&lt;/a&gt;。我们可以通过&lt;code&gt;css-loader?modules&lt;/code&gt;这个参数来开启CSS Modules。&lt;/p&gt;
&lt;p&gt;CSS Modules中的类名默认就是local的，如果你想要声明全局类名，可以加上&lt;code&gt;:global(...)&lt;/code&gt;这个标记。&lt;/p&gt;
&lt;h3 id=&quot;Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;Single Responsibility Principle&quot;&gt;&lt;/a&gt;Single Responsibility Principle&lt;/h3&gt;&lt;p&gt;讲CSS Modules的下一个特性之前。我们先聊点其他的，我们知道设计模式中有一条叫做Single Responsibility Principle。&lt;/p&gt;
&lt;p&gt;比如我们有一个button：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
    padding:2em;
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其把这些属性写在一个class里，我们可以把它拆分成多个单独的class：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--large{
    padding:2em;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在HTML中组合使用就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--large button--warnning&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的好处是什么呢？我们的UI中，一个组件往往有很多不同的状态。如果我们将每一个class写成只专注于一个属性，做好一件事，那就可以用这些class组合成所有我们想要的不同状态的组件。相比给每个状态的组件写一个单独的class，代码要更优雅简洁一些。&lt;/p&gt;
&lt;p&gt;比如我们想要一个small尺寸的普通button，只要加两个class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button {
    display:inline-block;
}
.button--small{
    padding:1em;
}
.button--large{
    padding:2em;
}
.button--normal{
    background-color:blue;
}
.button--warnning{
    background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后组合就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button button--small button--normal&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;CSS-Classes-Composing&quot;&gt;&lt;a href=&quot;#CSS-Classes-Composing&quot; class=&quot;headerlink&quot; title=&quot;CSS Classes Composing&quot;&gt;&lt;/a&gt;CSS Classes Composing&lt;/h3&gt;&lt;p&gt;要想实现上述的这种组合，可以使用SASS的Mixin，但Mixin主要是提供了源代码中的抽象，最后生成的代码，和手写不同状态class的代码量，是一样的。&lt;/p&gt;
&lt;p&gt;CSS Modules提供的Classes Composing则刚好可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;比如我们想渲染一段文字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text{
  font-size: 20px;
  composes: red from &amp;quot;./common/color.css&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;color.css里是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.red{
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后渲染出的class是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;composes&lt;/code&gt;引入的类被作为一个单独的class引入，而不是和text类合在一起。&lt;/p&gt;
&lt;h3 id=&quot;CSS-Modules和Vue工作流的整合&quot;&gt;&lt;a href=&quot;#CSS-Modules和Vue工作流的整合&quot; class=&quot;headerlink&quot; title=&quot;CSS Modules和Vue工作流的整合&quot;&gt;&lt;/a&gt;CSS Modules和Vue工作流的整合&lt;/h3&gt;&lt;p&gt;Vue-loader在v9.8.0之后加入了对CSS Modules的支持。&lt;/p&gt;
&lt;p&gt;我们只要在&lt;code&gt;.vue&lt;/code&gt;文件的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;处加一个&lt;code&gt;module&lt;/code&gt;就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style lang=&amp;quot;sass&amp;quot; module&amp;gt;
.text{
  font-size: 20px;
  composes: red from &amp;quot;sass!./common/color.scss&amp;quot;;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有一点要注意，就是&lt;code&gt;composes&lt;/code&gt;引入的如果是需要预处理器处理的，要在前面加上预处理器的标记，比如SASS用户就加上&lt;code&gt;sass!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果需要对CSS Modules进行一些配置（其实这个是对Webpack的css-loader的配置，所以配置时可以参考&lt;a href=&quot;https://github.com/webpack/css-loader&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;css-loader的文档&lt;/a&gt;），写在vue-loader的配置的&lt;code&gt;cssModules&lt;/code&gt;属性里即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;loader: &amp;#39;vue&amp;#39;,
options: {
    cssModules: {
        localIdentName: &amp;#39;[name]-[local]-[hash:base64:5]&amp;#39;,
        camelCase: true
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vue-loader会自动将一个&lt;code&gt;$style&lt;/code&gt;属性注入到对应的Vue实例中。在模板中用class binding语法写就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div :class=&amp;quot;$style.app&amp;quot;&amp;gt;
    &amp;lt;div :class=&amp;quot;$style.text&amp;quot;&amp;gt;
      some text
    &amp;lt;/div&amp;gt;
    &amp;lt;main-text&amp;gt;&amp;lt;/main-text&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$style&lt;/code&gt;其实是一个原class名和处理之后class名的hash，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  app: &amp;quot;App-app-3cl75_0&amp;quot;,
  text: &amp;quot;App-text-2AEnE_0 color-red-3ag3h_0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我写一了一个简单的&lt;a href=&quot;https://github.com/zxc0328/css-modules-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO仓库&lt;/a&gt;，可以供参考。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;CSS Modules可以解决全局作用域和Class组合两个问题，加上SASS等预处理器，着实让我们在写CSS时的工程化程度大大提高了。&lt;/p&gt;
&lt;p&gt;对于使用Vue的同学来说，vue-loader可以使CSS Modules可以轻松的整合到已有的工作流中。如果你正在使用Vue，可以试试使用CSS Modules。&lt;/p&gt;
&lt;h3 id=&quot;Links&quot;&gt;&lt;a href=&quot;#Links&quot; class=&quot;headerlink&quot; title=&quot;Links&quot;&gt;&lt;/a&gt;Links&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://glenmaddern.com/articles/css-modules&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Modules Welcome to the Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=zR1lOuyQEt8&amp;amp;index=29&amp;amp;list=LLHdx8Qwo6uxw0fj3gQ5yeTg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The case for CSS modules - Mark Dalgleish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React: CSS in JS by vjeux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;a href=&quot;#CSS在工程化上的一些问题&quot; class=&quot;headerlink&quot; title=&quot;CSS在工程化上的一些问题&quot;&gt;&lt;/a&gt;CSS在工程化上的一些问题&lt;/h3&gt;&lt;p&gt;关于React的CSS in JS，有一个&lt;a href=&quot;https://speakerdeck.com/vjeux/react-css-in-js&quot;&gt;著名的talk&lt;/a&gt;，由Facebook的工程师&lt;a href=&quot;https://github.com/vjeux&quot;&gt;vjeux&lt;/a&gt;带来。&lt;/p&gt;
&lt;p&gt;里面最有名的一张slide是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/Screen%20Shot%202016-11-13%20at%204.28.31%20PM.png&quot; alt=&quot;css in js&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面列举了CSS的一些问题。其中，Dead Code Elimination，Minification，和Sharing Constants这些问题我们已经通过在我们的工作流中加入SASS和PostCSS这样的CSS预处理器解决了。&lt;/p&gt;
&lt;p&gt;然而还有一些问题没有解决，比如全局命名空间。同一个document下的所有CSS的类名，都是在同一个“作用域”下的，因此我们常常要考虑如何避免命名冲突问题。现有的解决办法主要是靠BEM这样的命名惯例，或者是用多层CSS父子选择器来模拟命名空间。然而这样的办法对工程师有许多的限制。多级选择器有比较高的优先级，不容易维护。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>猪场实习感受-项目管理</title>
    <link href="http://yoursite.com/2016/10/03/project-management-in-netease/"/>
    <id>http://yoursite.com/2016/10/03/project-management-in-netease/</id>
    <published>2016-10-03T07:39:01.000Z</published>
    <updated>2016-10-03T08:08:53.000Z</updated>
    
    <content type="html">&lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;总的来说就是PM提出需求，交互出交互稿，然后这时研发和视觉可以同时开始进行。最后进行测试，测试通过后上线。这就是一个互联网产品版本迭代的过程。&lt;/p&gt;
&lt;h3 id=&quot;时间规划&quot;&gt;&lt;a href=&quot;#时间规划&quot; class=&quot;headerlink&quot; title=&quot;时间规划&quot;&gt;&lt;/a&gt;时间规划&lt;/h3&gt;&lt;p&gt;在上一个版本的开发过程中，PM和各个负责人就可以开始讨论下一个版本的需求，然后项目经理和大家一起确定这个版本的研发、测试和上线的时间节点。这个时间一旦确定，就必须严格执行，如果有需求无法完成要移到下一个版本做，必须经各个负责人确认后向大家发邮件说明。&lt;/p&gt;
&lt;h3 id=&quot;评审&quot;&gt;&lt;a href=&quot;#评审&quot; class=&quot;headerlink&quot; title=&quot;评审&quot;&gt;&lt;/a&gt;评审&lt;/h3&gt;&lt;p&gt;在我实习时，我作为开发，主要参加的就是交互的评审。这个评审的时间点在即将进入研发之前。其实主要就是交互设计师讲解交互稿，相关的开发人员提出自己的疑问，完善交互的可行性。&lt;/p&gt;
&lt;p&gt;按理来说应该还有需求评审、设计评审和代码评审。这些在实习时，比如代码评审因为时间的原因，没有做。在木犀的项目实践中，我觉得我们可以加入这些评审。时间的节点在视觉和开发完成，即将进入测试之前。&lt;/p&gt;
&lt;h3 id=&quot;JIRA&quot;&gt;&lt;a href=&quot;#JIRA&quot; class=&quot;headerlink&quot; title=&quot;JIRA&quot;&gt;&lt;/a&gt;JIRA&lt;/h3&gt;&lt;p&gt;JIRA是一款很有名的项目管理工具。在公司，我们一般是按需求创建Story，然后把交互、视觉和开发等任务关联到这个需求上。JIRA还有一个作用就是用来管理Bug。发现Bug的人可以提交Bug并指派给相关的责任人。JIRA有各种面板和筛选，可以方便的管理项目。&lt;/p&gt;
&lt;p&gt;我们暂时可以用Tower的任务来发挥JIRA的作用。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h3&gt;&lt;p&gt;测试主要是由专职的测试进行。测试负责编写测试用例，以及进行测试。&lt;/p&gt;
&lt;p&gt;当然，开发人员自己的自测是第一道防线。在开发完全之后，会进行冒烟测试，由测试提供用例，开发自行测试。用例主要和这一个版本的需求有关，主要就是检测一下需求中的功能是否被实现。只有冒烟测试通过了，才能进入真正的测试阶段。&lt;/p&gt;
&lt;p&gt;在测试人员进行测试的阶段。开发人员往往还要配合进行若干次的回归测试。同时要及时解决测试提出的Bug。&lt;/p&gt;
&lt;p&gt;首先测试开发环境下的项目，然后是测试环境，最后是预发布环境。预发布环境测试通过且Bug都解决的情况下，就可以上线了。&lt;/p&gt;
&lt;p&gt;对于我们这样的小团队来说，专职的测试是不太可能有的。主要就是在项目组中加入一位兼职的同学担任测试这个角色，然后各个模块的同学做到充分的自测。视觉、产品和交互进行走查（就是以用户的角度使用产品，来看是否有问题）。这样就可以保证较好的产品质量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这次实习，我主要学到的倒不是前端方面的东西，而主要是关于一个产品的迭代的流程。&lt;/p&gt;
&lt;p&gt;一个产品迭代的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://occc3ev3l.qnssl.com/zindex/10031.png&quot; alt=&quot;产品流程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个组件的诞生(下)</title>
    <link href="http://yoursite.com/2016/09/30/let-s-build-a-component-2/"/>
    <id>http://yoursite.com/2016/09/30/let-s-build-a-component-2/</id>
    <published>2016-09-30T02:34:07.000Z</published>
    <updated>2016-10-03T03:17:57.000Z</updated>
    
    <content type="html">&lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url1 }}&amp;quot;/&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url2 }}&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot;&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url1: &amp;quot;/somewhere/1.jpg&amp;quot;,
        url2: &amp;quot;/somewhere/2.jpg&amp;quot;
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction
            var indicators = document.querySelector(&amp;quot;.indicator&amp;quot;);
            indicators.map( (item, index) =&amp;gt; {
                _.removeClass(item, &amp;quot;hightLight&amp;quot;);
                if (index === data.index) {
                    _.addClass(item, &amp;quot;highLight&amp;quot;);
                }
            })    
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这的确可以实现我们想要的逻辑，但是看起来还是有点累赘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/4f19d188d43babcf6362d2372307492c_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们能把一部分逻辑写在模板里，然后在组件中，只需要修改数据，模板就会进行对应的渲染，是不是很酷呢？&lt;/p&gt;
&lt;p&gt;这就是所谓的&lt;strong&gt;数据驱动&lt;/strong&gt;。组件帮我们封装了底层的DOM操作细节。我们只需要声明组件的状态就可以了。用户的交互造成组件的状态改变，然后状态的改变又造成了DOM层面的重新渲染。组件就像是一个黑盒子，接收我们输入的数据，输出视图。计算机做的事情其实就是处理数据。因此，我们做这样的抽象，是非常&lt;strong&gt;符合本能的一种抽象&lt;/strong&gt;。可以让我们集中精力来关注业务逻辑。同时也&lt;strong&gt;降低了前端组件的复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那就让我们来试试吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;img src=&amp;quot;{{ url }}&amp;quot; for=&amp;quot;url in urls&amp;quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;div class=&amp;quot;button-left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;button-right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;indicator&amp;quot; &amp;gt;
        &amp;lt;li class=&amp;quot;item&amp;quot; 
        class=&amp;quot;{{ $index === index ? &#39;highLight&#39; : &#39;normal&#39; }}&amp;quot;
          for=&amp;quot;url in urls&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as _ from &amp;quot;utility&amp;quot;

var banner = new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        index:0,
        url: [&amp;quot;/somewhere/1.jpg&amp;quot;, &amp;quot;/somewhere/2.jpg&amp;quot;]
    },
    events: {
        &amp;quot;.left-button.click&amp;quot;: this.onSwitch.bind(this, 1),
        &amp;quot;.right-button.click&amp;quot;: this.onSwitch.bind(this, -1)
    },
    methods: {
        onSwitch: function(event, direction) {
            // 切换banner逻辑    
            data.index += direction //更新index
            this.render() //重新渲染
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有一个新的&lt;code&gt;for=&amp;quot;url in urls&amp;quot;&lt;/code&gt;，我们把这个叫做指令。指令可以理解为为模板增加分支、循环等逻辑的标记。模板引擎在编译这个指令时就会按数据进行对应的渲染。这里用到的是循环指令，作用就是按给定的数据循环遍历，每遍历到一个就讲数据填充到模板中进行渲染。&lt;code&gt;$index&lt;/code&gt;是这个指令中一个特殊的变量，代表当前遍历到的元素的下标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样就清楚多啦。我们修改&lt;code&gt;data.index&lt;/code&gt;，然后调用&lt;code&gt;this.render()&lt;/code&gt;这个生命周期方法。不用操纵任何DOM节点。视图就更新了。是的，我们在某种程度上实现了数据驱动！&lt;/p&gt;
&lt;h3 id=&quot;Vue-and-beyond&quot;&gt;&lt;a href=&quot;#Vue-and-beyond&quot; class=&quot;headerlink&quot; title=&quot;Vue and beyond&quot;&gt;&lt;/a&gt;Vue and beyond&lt;/h3&gt;&lt;p&gt;大家可以对比一下Vue的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Vue({
  el: &amp;#39;#app&amp;#39;,
  data: {
    message: &amp;#39;Hello Vue.js!&amp;#39;
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;)
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和我们的组件的初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Banner({
    el: document.querySelector(&amp;quot;template&amp;quot;),
    data: {
        message: &amp;#39;Hello Vue.js!&amp;#39;
    },
    events: {
        &amp;quot;.some-button.click&amp;quot;: this.oClick,
    },
    methods: {
        onClick: function() {
            // 业务逻辑
        }
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是很像呢，除了&lt;code&gt;events&lt;/code&gt;这个选项。因为Vue把这些逻辑都放到指令中了，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;button v-on:click=&amp;quot;reverseMessage&amp;quot;&amp;gt;Reverse Message&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以Vue的本质，就是一个用来构建用户界面的组件库。和我们一步步的设计API，调整模板，构建出来的这个组件，没有本质的区别。&lt;/p&gt;
&lt;p&gt;但Vue为什么好用呢？首先Vue有完善的指令系统，比如&lt;code&gt;v-for``v-for&lt;/code&gt;和&lt;code&gt;v-if&lt;/code&gt;等。其次是Vue实现了数据的双向绑定。双向绑定就是用户在界面上输入的数据，可以被同步到组件的状态中。刚才，我们在自己的组件中实现了将组件状态同步到界面，而双向绑定就以为着这个同步可以是反向的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双向绑定的实现是一个单独的话题。Angular使用的脏检查是一个流派。Vue使用&lt;code&gt;Object.defineProperty&lt;/code&gt;API来实现。React倒是没有数据绑定的概念，不过React的Virtual DOM Diff从某种角度来说，其实也是脏检查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们所实现的其实是一种粗犷的同步方式。并没有实现所谓的数据“绑定”。数据绑定就以为着为每个模板中被绑定的数据创建一个&lt;code&gt;Watcher&lt;/code&gt;，这个&lt;code&gt;Watcher&lt;/code&gt;决定数据变化时做什么操作。比如对于DOM中的表达式，&lt;code&gt;Watcher&lt;/code&gt;就会对这个表达式重新求值，然后更新这个表达式所在的DOM节点的对应属性。&lt;/p&gt;
&lt;p&gt;按之前我们的做法，如果一个数据变动，就会造成整个组件的重新渲染。这样明显是低效的。数据绑定可以做到特定DOM节点的更新，这是目前前端组件的主流。&lt;/p&gt;
&lt;h3 id=&quot;从MVC到MVVM&quot;&gt;&lt;a href=&quot;#从MVC到MVVM&quot; class=&quot;headerlink&quot; title=&quot;从MVC到MVVM&quot;&gt;&lt;/a&gt;从MVC到MVVM&lt;/h3&gt;&lt;p&gt;前端的MVC或者MVVM，View一般就指模板（模板可以看成是抽象的View，DOM则是这个抽象View的implementation detail）。我们的第一个组件构造器构造出来的对象其实是MVC中的Controller。里面的&lt;code&gt;data&lt;/code&gt;属性应该被单独拿出作为一个Model对象，这个对象可以通过观察者模式和Controller进行通信。&lt;/p&gt;
&lt;p&gt;MVVM中的Model就是一个plain object，比如我们打造的组件中的&lt;code&gt;data&lt;/code&gt;。Vue这样的MVVM框架，Vue实例其实是MVVM中的VM，即ViewModel。Model，如上文说的，是一个挂载在&lt;code&gt;data&lt;/code&gt;属性上的普通的对象。我们修改这个对象，就会驱动View的更新。MVVM的独特处之一就在于此。MVVM的独特处之二就是，Model和View直接数据的双向绑定。VM和MVC中Controller的不同之处在于通信方式的不同。MVVM中各个部分的联动比较复杂，我们叫reactive system。MVC中的事件广播模式，主要是在组件之间的通信这个层面比较明显。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中我们实现了一个通用的组件模型。但这个模型在前端这种用户交互密集的应用场景下，会遇到更多的挑战。&lt;/p&gt;
&lt;h3 id=&quot;数据驱动&quot;&gt;&lt;a href=&quot;#数据驱动&quot; class=&quot;headerlink&quot; title=&quot;数据驱动&quot;&gt;&lt;/a&gt;数据驱动&lt;/h3&gt;&lt;p&gt;你接到了这样一个需求，要在banner上加几个指示的圆点（indicator），当前页面是第几个页面，第几个圆点就会高亮。你想着这个需求很简单啊，刷刷刷就写好了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
